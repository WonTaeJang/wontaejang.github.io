{"pages":[{"title":"about","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","link":"/about/"}],"posts":[{"title":"asp-01-howto-tabs","text":"How To - Tabs (ASP.NET)Learn how to create tabs width CSS and ASP.NET Create Toggleable TabsStep 1) Add ASPX: Example 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;!-- Tab links --&gt; &lt;div class=&quot;tab&quot;&gt; &lt;asp:Button ID=&quot;btn_1&quot; runat=&quot;server&quot; Text=&quot;London&quot; CssClass=&quot;tab-button tablinks&quot; OnCommand=&quot;_Click&quot; CommandName=&quot;tab&quot; CommandArgument=&quot;pnl_1&quot;&gt;&lt;/asp:Button&gt; &lt;asp:Button ID=&quot;btn_2&quot; runat=&quot;server&quot; Text=&quot;Paris&quot; CssClass=&quot;tab-button tablinks&quot; OnCommand=&quot;_Click&quot; CommandName=&quot;tab&quot; CommandArgument=&quot;pnl_2&quot;&gt;&lt;/asp:Button&gt; &lt;asp:Button ID=&quot;btn_3&quot; runat=&quot;server&quot; Text=&quot;Tokyo&quot; CssClass=&quot;tab-button tablinks&quot; OnCommand=&quot;_Click&quot; CommandName=&quot;tab&quot; CommandArgument=&quot;pnl_3&quot;&gt;&lt;/asp:Button&gt; &lt;/div&gt; &lt;!-- Tab content --&gt; &lt;div runat=&quot;server&quot; id=&quot;div1&quot;&gt; &lt;asp:Panel ID=&quot;pnl_1&quot; runat=&quot;server&quot; CssClass=&quot;tabcontent&quot; Visible=&quot;false&quot;&gt; &lt;h3&gt;London&lt;/h3&gt; &lt;p&gt;London is the capital city of England.&lt;/p&gt; &lt;asp:TextBox runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt; &lt;/asp:Panel&gt; &lt;asp:Panel ID=&quot;pnl_2&quot; runat=&quot;server&quot; CssClass=&quot;tabcontent&quot; Visible=&quot;false&quot;&gt; &lt;h3&gt;Paris&lt;/h3&gt; &lt;p&gt;Paris is the capital of France.&lt;/p&gt; &lt;asp:TextBox runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt; &lt;/asp:Panel&gt; &lt;asp:Panel ID=&quot;pnl_3&quot; runat=&quot;server&quot; CssClass=&quot;tabcontent&quot; Visible=&quot;false&quot;&gt; &lt;h3&gt;Tokyo&lt;/h3&gt; &lt;p&gt;Tokyo is the capital of Japan.&lt;/p&gt; &lt;/asp:Panel&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; Step 2) Add CSS:Style the buttons and the tab content: Example 1234567891011121314151617181920212223242526272829303132333435/* Style the tab */ .tab { overflow: hidden; border: 1px solid #ccc; background-color: #f1f1f1; } /* Style the buttons that are used to open the tab content */ .tab-button { background-color: inherit; float: left; border: none; outline: none; cursor: pointer; padding: 14px 16px; transition: 0.3s; } /* Change background color of buttons on hover */ .tab-button:hover { background-color: #ddd; } /* Create an active/current tablink class */ .tab-button.active { background-color: #ccc; } /* Style the tab content */ .tabcontent { /*display: none;*/ padding: 6px 12px; border: 1px solid #ccc; border-top: none; } Step 3) Add ASPX.cs Example 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using System.Web.UI.WebControls; Button _btn = new Button(); protected void Page_Load(object sender, EventArgs e) { if (!IsPostBack) { ActivePanel(); } } protected void _Click(Object sender, CommandEventArgs e) { try { // 이전 버튼 if (ViewState[&quot;old_btn&quot;] != null) { Button old_btn = (Button)form1.FindControl(ViewState[&quot;old_btn&quot;].ToString()); old_btn.CssClass = old_btn.CssClass.Replace(&quot; active&quot;, &quot;&quot;); } // 현재 버튼 _btn = (Button)sender; _btn.CssClass += &quot; active&quot;; ViewState[&quot;old_btn&quot;] = _btn.ID; switch (e.CommandName) { case &quot;tab&quot;: ActivePanel(e.CommandArgument.ToString()); break; default: break; } } catch (Exception ex) { // Exception } } protected void ActivePanel(string pnl = &quot;pnl_1&quot;) { if (pnl_1.ID == pnl) pnl_1.Visible = true; else pnl_1.Visible = false; if (pnl_2.ID == pnl) pnl_2.Visible = true; else pnl_2.Visible = false; if (pnl_3.ID == pnl) pnl_3.Visible = true; else pnl_3.Visible = false; } Referencew3schools.com/howto/howto_js_tabs.asp","link":"/2021/06/21/asp-01-howto-tabs/"},{"title":"check a file exists at a URL(ASP.NET)","text":"web resource를 가져오기 전 HttpWebRequest Class를 이용하여 Head 정보만 가져온다. 123456789101112131415161718192021222324252627string url = &quot;https://www.domain.com/img/test.png&quot;;WebRequest webRequest = WebRequest.Create(url);webRequest.Method = &quot;HEAD&quot;;try{ using (HttpWebResponse response = (HttpWebResponse)webRequest.GetResponse()) { if (response.StatusCode.ToString() == &quot;OK&quot;) { //YOUR_CODE } }}catch(WebException ex){ // error}finally{ // Don't forget to close your response if(response != null) { response.Close(); }} 추가로 일반적인 file path일 경우 1if(File.Exist(path))","link":"/2021/04/19/check-a-file-exists-at-a-URL-ASP-NET/"},{"title":"css3-day-1","text":"CSS3 SyntaxCSS 기본 문법CSS(Cascading Style Sheets)는 HTML이나 XML과 같은 구조화 된 문서(Document)를 화면, 종이 등에 어떻게 렌더링할 것인지를 정의하기 위한 언어이다. 즉, CSS는 HTML의 각 요소(Element)의 style(design, layout etc)을 정의하여 화면(Screen)등에 어떻게 렌더링하면 되는지 브라우저에게 설명하기 위한 언어이다. HTML5 이전 버전의HTML에는 style을 컨트롤할 수 있는 태그(font, center)가 존재하여 CSS가 없이도 어느정도의 스타일 표현이 가능하였으나 정보와 구조를 담당하는 HTML의 본연의 역할과 동떨어진 기능까지 추가됨으로서 복잡하고 혼란스러운 언어가 되어 버렸다. HTML5에서는 HTML는 정보와 구조화, CSS는 styling의 정의라는 본연의 임무에 충실한 명확한 구분이 이루어졌다. HTML과 CSS는 각자의 문법을 갖는 별개의 언어이며 HTML은 CSS를 포함할 수 있다. 그러나 HTML없이 단독으로 존재하는 CSS는 의미가 없다. 새로운 언어를 학습할 때에는 먼저 용어에 익숙해져야 할 필요가 있다. CSS3의 용어에 대해 알아보도록 하자. 셀렉터 (Selector, 선택자) CSS는 HTML 요소의 style(design, layout etc)을 정의하는데 사용된다. 이를 위해서 선행되어야하는 것은 스타일을 적용하고자 하는 HTML 요소를 선택할 수 있어야 한다. 셀렉터는 스타일을 적용하고자 하는 HTML요소를 선택하기 위해 CSS에서 제공하는 수단이다. 위와 같은 구문을 Rule Set(또는 Rule)이라 하며 셀렉터에 의해 선택된 특정 HTML 요소를 어떻게 렌더링(Rendering)할 것인지 브라우저에 지시하는 역할을 한다. 위의 CSS Rule set은 HTML 문서에 속해 있는 셀렉터를 통해 모든 h1 요소를 선택한 후 선택된 h1 요소의 스타일을 선언 블록에서 정의하고 있다. 이와 같은 Rule Set의 집합을 스타일시트(Style Sheet)라 한다. 2. 프로퍼티 (Property / 속성)셀릭터로 HTML 요소를 선택하고 {}내에 프로퍼티(속성)와 값을 지정하는 거으로 다양한 style을 정의 할 수 있다. 프로퍼티는 표준 스펙으로 이미 지정되어 있는 것을 사용하여야 하며 사용자가 임의로 정의할 수 없다. 여러개의 프로퍼티를 연속해서 지정할 수 있으며 세미콜론(;)으로 구분한다. 1234p { color: ...; font-size: ...;} 3. 값 (Value / 속성값)셀렉터로 지정한 HTML 요소에 style을 적용하기 위해 프로퍼티를 사용했다. 프로퍼티의 값은 해당 프로퍼티에 사용할 수 있는 값을 “키워드”나 “크기 단위” 또는 “색상 표현 단위”등의 특정 단위로 지정하여야 한다. 1234p { color: orange; font-size: 16px;} 4. HTML과 CSS의 연동HTML은 CSS를 포함할 수 있다. CSS를 가지고 있지 않은 HTML은 브라우저에서 기본으로 적용하는 CSS(user agent stylesheet)에 의해 렌더링된다. 4.1 Link styleHTML에서 외부에 있는 CSS 파일을 로드하는 방식이다. 가장 일반적으로 사용된다. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;This is a web page.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 12h1 { color: red; }p { background: blue; } 4.2 Embedding styleHTML 내부에 CSS를 포함시키는 방식이다. 매우 간단한 웹페이지의 경우는 문제될 것이 없겠지만 Link style을 사용하는 편이 좋다. HTML과 CSS는 서로 역할이 다르므로 다른 파일로 구분되어 작성하고 관리되는 것이 바람직하다. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; h1 { color: red; } p { background: aqua; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;This is a web page.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 4.3 Inline styleHTML요소의 style 프로퍼티에 CSS를 기술하는 방식이다. JavaScript가 동적으로 CSS를 생성할 때 사용하는 경우가 있다. 하지만 일반적인 경우 Link style을 사용하는 편이 좋다. 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h1 style=&quot;color: red&quot;&gt;Hello World&lt;/h1&gt; &lt;p style=&quot;background: aqua&quot;&gt;This is a web page.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; Hello World This is a web page. 5. Reset CSS 사용하기모든 웹 브라우저는 디폴트 스타일(브라우저가 내장하고 있는 기본 스타일)을 가지고 있어 CSS가 없어도 작동한다. 그런데 웹브라우저에 따라 디폴트 스타일이 상이하고 지원하는 tag나 style도 제각각이어서 주의가 필요하다. Reset CSS는 기본적인 HTML 요소의 CSS를 초기화하는 용도로 사용한다. 즉, 브라우저 별로 제각각인 디폴트 스타일을 하나의 스타일로 통일시켜 주는 역할을 한다. 자주 사용되는 Reset CSS는 다음과 같다. Eric Meyer’s reset normalize.css 6. CSS Versions Version Year CSS3 2005 CSS2 1998 CSS1 1996 참조 사이트: https://poiemaweb.com/css3-syntax","link":"/2021/04/20/css3-day-1/"},{"title":"css3-day-12","text":"CSS3 Shadow그림자텍스트나 요소에 그림자(shadow) 효과를 부여하기 위한 프로퍼티를 선언한다. 1. text-shadow텍스트에 그림자 효과를 부여하는 프로퍼티이다. 1선택자 { text-shadow: Horizontal-offset Vertical-offset Blur-Radius Shadow-Color; } 프로퍼티 값 단위 설명 생략 Horizontal-offset px 그림자를 텍스트의 오른쪽으로 지정값만큼 이동시킨다 Vertical-offset px 그림자를 텍스트의 아래로 지정값만큼 이동시킨다 Blur-Radius px 그림자의 흐림정도를 지정한다. 지정값만큼 그림자가 커지고 흐려진다.(양수) 가능 Shadow-Color color 그림자의 색상을 지정한다 가능 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; h1:nth-child(1) { text-shadow: 5px 5px; } h1:nth-child(2) { text-shadow: 5px 5px red; } h1:nth-child(3) { text-shadow: 5px 5px 3px red; } h1:nth-child(4) { color: white; text-shadow: 5px 5px 3px black; } h1:nth-child(5) { text-shadow: 0 0 3px red; } /*Multiple Shadows*/ h1:nth-child(6) { text-shadow: 0 0 3px red, 0 0 10px blue; } /*Multiple Shadows*/ h1:nth-child(7) { color: white; text-shadow: 1px 1px 2px black, 0 0 25px blue, 0 0 5px darkblue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Text-shadow effect!&lt;/h1&gt; &lt;h1&gt;Text-shadow effect!&lt;/h1&gt; &lt;h1&gt;Text-shadow effect!&lt;/h1&gt; &lt;h1&gt;Text-shadow effect!&lt;/h1&gt; &lt;h1&gt;Text-shadow effect!&lt;/h1&gt; &lt;h1&gt;Text-shadow effect!&lt;/h1&gt; &lt;h1&gt;Text-shadow effect!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; result 2.box-shadow요소에 그림자 효과를 부여하는 프로퍼티이다. 1선택자 { box-shadow: Inset Horizontal-offset Vertical-offset Blur-Radius Spread Shadow-Color; } 프로퍼티 값 단위 설명 생략 Inset inset inset 키워드를 지정하면 그림자가 요소 안쪽에 위치한다 가능 Horizontal-offset px 그림자를 텍스트의 오른쪽으로 지정값만큼 이동시킨다 Vertical-offset px 그림자를 텍스트의 아래로 지정값만큼 이동시킨다 Blur-Radius px 그림자의 흐림정도를 지정한다. 지정값만큼 그림자가 커지고 흐려진다.(양수) 가능 Spread px 그림자를 더 크게 확장시킨다.(음수, 양수) 가능 Shadow-Color color 그림자의 색상을 지정한다 가능 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 300px; height: 100px; padding: 15px; margin: 20px; background-color: yellow; } /*box-shadow: Inset Horizontal-offset Vertical-offset Blur-Radius Spread Shadow-Color;*/ /* Horizontal-offset Vertical-offset */ div:nth-of-type(1) { box-shadow: 10px 10px; } /* Horizontal-offset Vertical-offset Shadow-Color */ div:nth-of-type(2) { box-shadow: 10px 10px blue; } /* Horizontal-offset Vertical-offset Blur-Radius Shadow-Color */ div:nth-of-type(3) { box-shadow: 10px 10px 5px blue; } /* Horizontal-offset Vertical-offset Blur-Radius Spread Shadow-Color */ div:nth-of-type(4) { box-shadow: 10px 10px 5px 5px blue; } /* Inset Horizontal-offset Vertical-offset Blur-Radius Spread Shadow-Color */ div:nth-of-type(5) { box-shadow: inset 10px 10px 5px 5px blue; } /* Horizontal-offset Vertical-offset Blur-Radius Spread Shadow-Color */ div:nth-of-type(6) { background-color: white; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;This is a div element with a box-shadow&lt;/div&gt; &lt;div&gt;This is a div element with a box-shadow&lt;/div&gt; &lt;div&gt;This is a div element with a box-shadow&lt;/div&gt; &lt;div&gt;This is a div element with a box-shadow&lt;/div&gt; &lt;div&gt;This is a div element with a box-shadow&lt;/div&gt; &lt;div&gt;This is a div element with a box-shadow&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result Referencepoiemaweb.com/css3-shadow css3generator","link":"/2021/05/20/css3-day-12/"},{"title":"css3-day-10","text":"CSS3 Inheritance &amp; Cascading스타일의 상속과 적용 우선 순위1. 상속(Inheritance)상속이란 상위(부모, 조상) 요소에 적용된 프로퍼티를 하위(자식, 자손) 요소가 물려 받는 것을 의미한다. 상속 기능이 없다면 각 요소의 Rule set에 프로퍼티를 매번 각각 지정해야 한다. 하지만 모든 프로퍼티가 상속 되는 것은 아니다. 프로퍼티 중에는 상속이 되는 것과 되지 않는 것이 있다. property inherit width/height no margin no padding no border no box-sizing no display no visibility yes opacity yes background no font yes color yes line-height yes text-align yes vertical-align no text-decoration no white-space yes position no top/right/bottom/left no z-index no overflow no float no 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .text-red { color: red; border: 1px solid #bcbcbc; padding: 10px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;text-red&quot;&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;p&gt;Paragraph&lt;strong&gt;strong&lt;/strong&gt;&lt;/p&gt; &lt;button&gt;Button&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result color는 상속되는 프로퍼티로서 자식 요소는 물론 자손 요소까지 적용된다. 하지만 button처럼 요소에 따라 상속 받지 않는 경우도 존재한다. border, padding은 상속되지 않는 요소에 적용되지 않는다. W3C가 제공하는 Full property table의 Inherited? 가 yes인 프로퍼티만 상속된다. 상속되지 않는 경우(상속받지 않는 요소 또는 상속되지 않는 프로퍼티), inherit 키워드를 사용하여 명시적으로 상속받게 할 수 있다. 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; .text-red { color: red; border: 1px solid #bcbcbc; padding: 10px; } .text-red button { color: inherit; } .text-red p { border: inherit; padding: inherit; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;text-red&quot;&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;p&gt;Paragraph&lt;strong&gt;strong&lt;/strong&gt;&lt;/p&gt; &lt;button&gt;Button&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 2. 캐스캐이딩(Cascading)요소는 하나 이상의 CSS 선언에 영향을 받을 수 있다. 이때 충돌을 피하기 위해 CSS 전용 우선순위가 필요한데 이를 캐스캐이딩(Cascading Order)이라고 한다. 캐스캐이딩에는 다음과 같이 세가지 규칙이 있다. 중요도CSS가 어디에 선언 되었는지에 따라서 우선순위가 달라진다. 명시도대상을 명확하게 특정할수록 명시도가 높아지고 우선순위가 높아진다. 선언순서선언된 순서에 따라 우선 순위가 적용된다. 즉, 나중에 선언된 스타일이 우선 적용된다. 2.1 중요도CSS가 어디에 선언되었는지에 따라서 우선순위가 달라진다. head 요소 내의 style 요소 head 요소 내의 style 요소 내의 @import 문 &lt;link&gt; 로 연결된 CSS 파일 &lt;link&gt; 로 연결된 CSS 내의 @import 문 브라우저 디폴트 스타일시트 12345/* style.css */body { background-color: red; color: white;} 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;style&gt; body { background-color: beige; color: navy; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/body&gt;&lt;/html&gt; 2.2 명시도대상을 명확하게 특정할수록 명시도가 높아지고 우선순위가 높아진다. !important &gt; 인라인 스타일 &gt; 아이디 선택자 &gt; 클래스/어트리뷰트/가상 선택자 &gt; 태그 선택자 &gt; 전체 선택자 &gt; 상위 요소에 의해 상속된 속성 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p { color: red !important; } #thing { color: blue; } div.food { color: chocolate; } .food { color: green; } div { color: orange; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;thing&quot;&gt;Will be Red.&lt;/p&gt; &lt;div class=&quot;food&quot;&gt;Will be Chocolate.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 2.3 선언 순서선언된 순서에 따라 우선 순위가 적용된다. 즉, 나중에 선언된 스타일이 우선 적용된다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p { color: blue; } p { color: red; } .red { color: red; } .blue { color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Will be RED.&lt;/p&gt; &lt;p class=&quot;blue red&quot;&gt;Will be BLUE.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result Referencepoiemaweb.com/css3-inheritance-cascading W3C CSS Document","link":"/2021/05/14/css3-day-10/"},{"title":"css3-day-11","text":"CSS3 Vendor Prefix벤터 프리픽스CSS3 표준으로 확정되기 이전 또는 브라우저 개발사가 실험적으로 제공하는 기능을 사용하기 위해서는 벤터 프리픽스(Vendor Prefix)를 사용하여야 한다. Can I use?에서 제공하는 브라우저별 CSS 지원 정보를 보면 텍스트와 요소의 선택을 방지하는 user-select 프로퍼티는 모든 브라우저에 벤터 프리픽스를 사용하여야 한다. 브라우저의 버전이 올라감에 따라 벤터 프리픽스를 사용하지 않아도 될 수 있다. 그러나 구형 브라우저를 지원하기 위하여 벤터 프리칙스를 사용하여야 할 필요가 있다. CSS property: user-select 123456* { -webkit-user-select: none; /* Chrome all / Safari all */ -moz-user-select: none; /* Firefox all */ -ms-user-select: none; /* IE 10+ */ user-select: none; /* Likely future */} 브라우저 별 벤터 프리픽스는 다음과 같다. Browser Vendor Prefix IE or Edge(12-89) -ms- Edge(90) -webkit- Chrome -webkit- Firefox -moz- Safari -webkit- Opera -o- iOS Safari -webkit- Android Browser -webkit- Chrome for Android -webkit- 많은 브라우저를 위한 벤터 프리픽스를 사용하는 것은 코드의 양을 늘게 하고 또한 브라우저는 거의 매달 업데이트가 이루어지고 있어 불필요한 벤터 프리픽스를 사용할 가능성이 크다. 사용하지 않아도 되는 벤터 프리픽스를 사용하는 것은 성능에도 영향을 주기 때문에 Prefix Free 라이브러리를 사용하는 것은 매우 유용한 방법이다. 사용법은 매우 간단하다. Prefix Free 사이트에서 라이브러리를 다운로드하고 include 하기만 하면 이 후에는 벤터 프리픽스없이 모든 CSS를 사용할 수 있다. 1&lt;script src=&quot;prefixfree.min.js&quot;&gt;&lt;/script&gt; Referencepoiemaweb.com/css3-vendor-prefix","link":"/2021/05/20/css3-day-11/"},{"title":"css3-day-13","text":"CSS3 Gradient그레이디언트그레이디언트(Gradient)는 2가지 이상의 색상을 혼합하여 부드러운 색감의 배경 등을 생성하는 것이다. CSS3가 이 기능을 제공하기 이전에는 포토샵 등의 소프트웨어를 사용하여 그레이디언트 효과의 이미지를 제작하여 사용하였다. 그러나 이러한 방법은 이미지 다운로드에 시간이 소요되는 문제와 이미지를 확대하였을 때 해상도가 나빠지는 문제 등을 내포하고 있었다. 그레이디언트는 2가지 종류가 있다. 선형 그레이디언트 (Linear Gradient: goes down/up/left/right/diagonally) 방사형 그레이디언트(Radial Gradient: defined by their center) 그레이디언트는 CSS3가 비교적 최근부터 제공하는 기술로서 대부분의 브라우저에 벤터프리픽스를 사용하여야 하고 브라우저에 따라 조금씩 문법이 상이하여 다루기가 수월하지 않다. 따라서 그레이디언트를 직접 작성하는 것보다 작성 툴을 이용하는 것이 보편적이다. Ultimate CSS Gradient Generator 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0; } div { width: 100vw; height: 100vh; } .dawn { /* Old browsers */ background: #b3cae5; /* FF3.6+ */ background: -moz-linear-gradient(-45deg, #b3cae5 12%, #dbdde4 46%, #e4e3e4 70%, #f7ddbb 94%, #efcab2 100%); /* Chrome,Safari4+ */ background: -webkit-gradient(linear, left top, right bottom, color-stop(12%, #b3cae5), color-stop(46%, #dbdde4), color-stop(70%, #e4e3e4), color-stop(94%, #f7ddbb), color-stop(100%, #efcab2)); /* Chrome10+,Safari5.1+ */ background: -webkit-linear-gradient(-45deg, #b3cae5 12%, #dbdde4 46%, #e4e3e4 70%, #f7ddbb 94%, #efcab2 100%); /* Opera 11.10+ */ background: -o-linear-gradient(-45deg, #b3cae5 12%, #dbdde4 46%, #e4e3e4 70%, #f7ddbb 94%, #efcab2 100%); /* IE10+ */ background: -ms-linear-gradient(-45deg, #b3cae5 12%, #dbdde4 46%, #e4e3e4 70%, #f7ddbb 94%, #efcab2 100%); /* W3C */ background: linear-gradient(135deg, #b3cae5 12%, #dbdde4 46%, #e4e3e4 70%, #f7ddbb 94%, #efcab2 100%); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;dawn&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result Referencepoiemaweb.com/css3-gradient css3generator.com","link":"/2021/05/24/css3-day-13/"},{"title":"css3-day-3","text":"2.3 CSS3 UnitsCSS 프로퍼티 값의 단위CSS 프로퍼티에는 키워드, 크기 단위, 색상 표현 단위 등의 특정 단위를 갖는 값을 지정한다. 출처: https://www.w3schools.com/css/css_syntax.asp 1. 키워드각 프로퍼티에 따라 사용할 수 있는 키워드가 존재한다. 예를 들어 display 프로퍼티 값으로 사용할 수 있는 키워드는 block, inline, inline-block, none 이 있다. 제세한 내용은 각각의 프로퍼티를 참조 2. 크기 단위cm, mm, inch 등의 단위도 존재하나 CSS에서 사용하는 대표적인 크기 단위는 px, em, %이다.px은 절대값이고 em, %는 상대값이다.대부분 브라우저의 폰트 사이즈 기본값은 16px, 1em, 100%이다. 프로퍼티 값이 0인 경우, 단위를 생략할 수 있다. 2.1 pxpx은 픽셀(화소) 단위이다. 1px은 화소 1개 크기를 의미한다. 22인치 LCD 모니터의 경우 해상도가 1680 * 1050 인데 이것은 가로에 1680개의 픽셀, 세로에 1050개의 픽셀을 가진다는 의미이다. 200만 화소(픽셀)의 디지털 카메라로 찍은 사진은 1600 * 1200 = 1,920,000으로 통상 200만 화소라 한다. 픽셀은 디바이스 해상도(resolution)에 따라 상대적인 크기를 갖는다. 대부분의 브라우저는 1px을 1/96 인치의 절대단위로 인식한다. px은 요소의 크기나 이미지의 크기 지정에 주로 사용된다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { text-align: center; } div { font-size: 14px; font-weight: bold; padding: 2em; /* 14px * 2 = 28px */ background-color: rgba(255, 0, 0, 0.2); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Font size: 14px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 2.2 %%는 백분률 단위의 상대 단위이다. 요소에 지정된 사이즈(상속된 사이즈나 디폴트 사이즈)에 상대적인 사이즈를 설정한다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { font-size: 14px; text-align: center; } div { font-size: 120%; /* 14px * 1.2 = 16.8px */ font-weight: bold; padding: 2em; /* 16.8px * 2 = 33.6px */ background-color: rgba(255, 0, 0, 0.2); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Font size: 14px * 120% → 16.8px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 2.3 emem은 배수 단위로 상대 단위이다. 요소에 지정된 사이즈(상속된 사이즈나 디폴트 사이즈)에 상대적인 사이즈를 설정한다. 예를 들어 1em은 요소에 지정된 사이즈와 같고 2em은 요소에 지정된 사이즈의 2배이다. 폰트 사이즈 설정이나 콘텐츠를 포함하는 컨테이너의 크기 설정에 사용하면 상대적인 설정이 가능하여 편리하다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { font-size: 14px; text-align: center; } div { font-size: 1.2em; /* 14px * 1.2 = 16.8px */ font-weight: bold; padding: 2em; /* 16.8px * 2 = 33.6px */ background-color: rgba(255, 0, 0, 0.2); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Font size: 1.2em → 14px * 1.2 = 16.8px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 중첩된 자식 요소에 em을 지정하면 모든 자식 요소의 사이즈에 영향을 미치기 때문에 주의하여야 한다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { font-size: 14px; text-align: center; } div { font-size: 1.2em; /* 14px * 1.2 = 16.8px */ font-weight: bold; padding: 2em; } .box1 { background-color: rgba(255, 0, 0, 0.2); } .box2 { background-color: rgba(255, 0, 0, 0.6); } .box3 { background-color: rgba(255, 0, 0, 0.8); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='box1'&gt; Font size: 1.2em ⇒ 14px * 1.2 = 16.8px &lt;div class='box2'&gt; Font size: 1.2em ⇒ 16.8px * 1.2 = 20.16px &lt;div class='box3'&gt; Font size: 1.2em ⇒ 20.16px * 1.2 = 24.192px &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 2.4 remem의 기준은 상속의 영향으로 바뀔 수 있다. 즉, 상황에 따라 1.2em은 각기 다른 값을 가질 수 있다. rem은 최상위 요소(html)의 사이즈를 기준으로 삼는다. rem의 r 은 root를 의미한다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html { font-size: 14px; /* font-size 미지정 시에는 16px */ } div { font-size: 1.2rem; /* html font-size: 14px * 1.2 = 16.8px */ font-weight: bold; padding: 2em; text-align: center; } .box1 { background-color: rgba(255, 0, 0, 0.2); } .box2 { background-color: rgba(255, 0, 0, 0.6); } .box3 { background-color: rgba(255, 0, 0, 0.8); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='box1'&gt; Font size: 1.2rem ⇒ 14px * 1.2 = 16.8px &lt;div class='box2'&gt; Font size: 1.2rem ⇒ 14px * 1.2 = 16.8px &lt;div class='box3'&gt; Font size: 1.2rem ⇒ 14px * 1.2 = 16.8px &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 사용자가 브라우저의 기본 폰트 크기를 변경하더라도 이에 따라 웹사이트의 레이아웃을 적잘히 조정할 수 있다는 장점이 있다. 따라서 폰트 사이즈 뿐만이 아니라 콘텐츠의 크기에 따라 가변적으로 대응하여야 하는 wrapper 요소(container)등에 적합하다. 123.container { width: 70rem; /* 70rem ⇒ 14px * 70 = 980px */} Reset CSS를 사용하여 사전에 html 요소의 font-size 지정이 필요하다. font-size 미지정 시에는 16px가 적용된다. 2.5 Viewport 단위 (vh, vw, vmin, vmax)반응형 웹디자인은 화명의 크기에 동적으로 대응하기 위해 % 당위를 자주 사용한다. 하지만 % 단위는 em과 같이 상속에 의해 부모 요소에 상대적 영향을 받는다. Viewport 단위는 상대적인 단위로 viewport를 기준으로 한 상대적 사이즈를 의미한다. 단위 Description vw viewport 너비의 1/100 vh viewport 높이의 1/100 vmin viewport 너비 또는 높이 중 작은 쪽의 1/100 vmax viewport 너비 또는 높이 중 큰 쪽의 1/100 예를 들어 viewport 너비가 1000px, 높이가 600px인 경우, 1vw: viewport 너비 1000px의 1%인 10px 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0px; } .item { width: 50vw; height: 100vh; text-align: center; line-height: 100vh; font-size: 4rem; color: white; } .item1 { background-color: red; } .item2 { background-color: orange; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='item item1'&gt;item1&lt;/div&gt; &lt;div class='item item2'&gt;item2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 브라우저에 따라 지원이 완전하지 않을 수 있으므로 주의가 필요하다. 3. 색상 표현 단위색상을 지정하기 위해 키워드(red, blue)를 사용할 수 있다. 사용이 간편하다는 장점이 있으나 표현할 수 있는 색상의 수는 제한된다. 색상을 표현할 수 있는 키워드 리스트는 W3C css3-color를 참조 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h2 style=&quot;background-color:red&quot;&gt; Red background-color &lt;/h2&gt; &lt;h2 style=&quot;background-color:green&quot;&gt; Green background-color &lt;/h2&gt; &lt;h2 style=&quot;background-color:blue;color:white&quot;&gt; Blue background-color and white text color &lt;/h2&gt; &lt;h2 style=&quot;background-color:orange&quot;&gt; Orange background-color &lt;/h2&gt; &lt;h2 style=&quot;background-color:yellow&quot;&gt; Yellow background-color &lt;/h2&gt; &lt;h2 style=&quot;background-color:cyan&quot;&gt; Cyan background-color &lt;/h2&gt; &lt;h2 style=&quot;background-color:black;color:white&quot;&gt; Black background-color and white text color &lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; result 더욱 다양한 색상을 표현하기 위해 다음과 같은 색상 표현 당위를 사용할 수 있다. HTML COLOR CODES Referencepoiemaweb.com/css3-units","link":"/2021/04/26/css3-day-3/"},{"title":"css3-day-5","text":"2.5 CSS3 Displaydisplay, visibility, opacity 프로퍼티1.display 프로퍼티display 프로퍼티는 layout 정의에 자주 사용되는 중요한 프로퍼티이다. 프로퍼티값 키워드 설명 block block 특성을 가지는 요소(block 레벨 요소)로 지정 inline inline 특성을 가지는 요소(inline 레벨 요소)로 지정 inline-block inline-block 특성을 가지는 요소(inline-block 레벨 요소)로 지정 none 해당 요소를 화면에 표시하지 않는다(공간조차 사라진다.) 모든 HTML 요소는 아무런 CSS를 적용하지 않아도 기본적으로 브라우저에 표현되는 디폴트 표시값을 가진다. HTML 요소는 block 또는 inline 튿성을 갖는다. 아래는 p 요소에 대한 크롬 브라우저의 디폴트 css이다. 1234567p { display: block; -webkit-margin-before: 1em; -webkit-margin-after: 1em; -webkit-margin-start: 0px; -webkit-margin-end: 0px;} display 프로퍼티는 상속되지 않는다. 1.1 block 레벨 요소block 특성을 가지는 요소(block 레벨 요소 또는 block 요소)는 아래와 같은 특징을 갖는다. 항상 새로운 라인에서 시작한다. 화면 크기 전체의 가로폭을 차지한다.(width: 100%) width, height, margin, padding 프로퍼티 지정이 가능하다. block 레벨 요소 예 divh1~h6polullihrtableform 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div:nth-of-type(1) { background-color: #FFA07A; padding: 20px; } div:nth-of-type(2) { background-color: #FF7F50; padding: 20px; width: 300px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h2&gt;블록 레벨 요소&lt;/h2&gt; &lt;p&gt;width, height 미지정 → width: 100%; height: auto;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;블록 레벨 요소&lt;/h2&gt; &lt;p&gt;width: 300px → width: 300px; height: auto;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 1.2 inline 레벨 요소inline 특성을 가지는 요소(inline 레벨 요소 또는 inline 요소)는 아래와 같은 특징을 갖는다. 새로운 라인에서 시작하지 않으며 문장의 중간에 들어갈 수 있다. 즉, 줄을 바꾸지 않고 다른 요소와 함께 한 행에 위치한다. content의 너비만큼 가로폭을 차지한다. width, height, margin-top, margin-bottom 프로퍼티를 지정할 수 없다. 상, 하 여백은 line-height로 지정한다. inline 레벨 요소 뒤에 공백(엔터, 스페이스 등)이 있는 경우, 정의하지 않은 space(4px)가 자동 지정된다. inline 레벨 요소 내에 block 레벨 요소를 포함할 수 없다. inline 레벨 요소는 일반적으로 block 레벨 요소에 포함되어 사용된다. span a strong img input select textarea button 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; span { background-color: red; color: white; padding: 10px; /* width, height, margin-top, margin-bottom 프로퍼티를 지정할 수 없다. */ /* width: 200px; */ /* margin: 10px; */ /* 상, 하 여백은 line-height로 지정한다. */ /* line-height: 50px; */ } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My &lt;span&gt;Important&lt;/span&gt; Heading&lt;/h1&gt; &lt;span&gt;Inline&lt;/span&gt; &lt;span&gt;Inline&lt;/span&gt;&lt;span&gt;Inline&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; result 1.3 inline-block 레벨 요소block 과 inline 레벨 요소의 특징을 모두 갖는다. inline 레벨 요소와 같이 한 줄에 표현되면서 width, height, margin 프로퍼티를 모두 지정할 수 있다. 기본적으로 inline 레벨요소와 흡사하게 줄을 바꾸지 않고 다른 요소와 함께 한 행에 위치시킬 수 있다. block 레벨 요소처럼 width, height, margin, padding 프로퍼티를 모두 정의할 수 있다. 상,하 여백을 margin과 line-height 두가지 프로퍼티 모두를 통해 제어할 수 있다. content의 너비만큼 가로폭을 차지한다. inline-block 레벨 요소 뒤에 공백(엔터, 스페이스 등)이 있는 경우, 정의하지 않은 space(4px)가 자동 지정된다. 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .wrapper { font-size: 0; /*요소간 간격을 제거*/ } .inline-block { display: inline-block; vertical-align: middle; /* inline-block 요소 수직 정렬 */ border: 3px solid #73AD21; font-size: 16px; } .box1 { width: 300px; height: 70px; } .box2 { width: 300px; height: 150px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;inline-block box1&quot;&gt;inline-block height 70px&lt;/div&gt; &lt;div class=&quot;inline-block box2&quot;&gt;inline-block height 150px&lt;/div&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;inline-block box1&quot;&gt;inline-block height 70px&lt;/div&gt; &lt;div class=&quot;inline-block box2&quot;&gt;inline-block height 150px&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 2. visibility 프로퍼티visibility 프로퍼티는 요소를 보이게 할 것인지 보이지 않게 할 것인지를 정의한다. 즉, 요소의 렌더링 여부를 결정한다. 프러퍼티값 키워드 설명 visible 해당 요소를 보이게 한다(기본값) hidden 해당 요소를 보이지 않게 한다. display: none; 은 해당 요소의 공간까지 사라지게 하지만 visibility:hidden;은 해당 요소의 공간은 사라지지 않고 남아있게 된다. collapse table 요소에 사용하며 행이나 열을 보이지 않게 한다. none table 요소의 row나 column을 보이지 않게 한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .visible { visibility: visible; } .hidden { visibility: hidden; } table, td { border: 1px solid black; } .collapse { visibility: collapse; } /* .collapse { visibility: hidden; } */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=&quot;visible&quot;&gt;visibility: visible&lt;/h1&gt; &lt;h1 class=&quot;hidden&quot;&gt;visibility: hidden&lt;/h1&gt; &lt;h1 style=&quot;display:none&quot;&gt;display:none&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;B&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;collapse&quot;&gt; &lt;td&gt;C&lt;/td&gt; &lt;td&gt;D&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; result 3. opacity 프로퍼티opacity 프로퍼티는 요소의 투명도를 정의한다. 0.0 ~ 1.0의 값을 입력하며 0.0은 투명, 1.0은 불투명을 의미한다. 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div, img { float: left; width: 150px; height: 150px; margin: 30px; background-color: blue; color: white; opacity: 0.5; transition: opacity 1s; } div:hover, img:hover { opacity: 1.0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;opacity: 0.5&lt;/div&gt; &lt;img src=&quot;../img/cat.png&quot; alt=&quot;cat&quot;&gt;&lt;/body&gt;&lt;/html&gt; result Referencepoiemaweb.com/css3-display W3C CSS Document","link":"/2021/04/29/css3-day-5/"},{"title":"css3-day-6","text":"css3 BackgroundBackground 관련 프로퍼티는 해당 요소의 배경으로 이미지 또는 색상을 정의한다. 자세한 내용은 CSS Background and Borders를 참조한다. 1. background-image 프로퍼티요소에 배경 이미지를 지정한다. MDN:background-image 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { background-image: url('../img/cat.png'); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Background Image&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; result 2.background-repeat 프로퍼티배경 이미지의 반복을 지정한다. 수직, 수평 또는 수직과 수평 모두의 반복을 지정할 수 있다. 설정된 이미지의 크기가 화면보다 작으면 자동으로 이미지가 반복 출력되어 화면을 채우게 된다. 이것을 background-repeat 프로퍼티의 기본값이 repeat 이기 때문이다. x축으로만 배경 이미지를 반복할 경우, background-repeat 프로퍼티값에 repeat-x, y축으로만 배경 이미지를 반복할 경우, repeat-y 를 설정한다. MDN:background-repeat 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { background-image: url('../img/cat.png'); background-repeat: repeat-x; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;background-repeat: repeat-x;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; result 반복 출력을 멈추고 싶은 경우, background-repeat 프로퍼티값에 no-repeat를 설정한다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { background-image: url('../img/cat.png'); background-repeat: no-repeat; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;background-repeat: no-repeat;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; result background-image에 복수개의 이미지를 설정할 경우, 먼저 설정된 이미지가 전면에 출력된다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { background-image: url('../img/cat.png'), url('../img/og_image.png'); background-repeat: no-repeat, repeat; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;background-repeat: no-repeat, repeat;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; result 3. background-size 프로퍼티배경 이미지의 사이즈를 지정한다. 배경 이미지의 고유 비율을 유지하기 때문에 설정에 따라 이미지의 일부가 보이지 않을 수 있다. 프로퍼티값은 px, %, cover, contain 등을 사용한다. 배경이미지의 width, height를 모두 설정할 수 있다. 이때 첫번째 값은 width, 두번째 값은 height를 의미한다. 하나의 값만을 지정한 경우, 지정한 값은 width를 의미하게 되며 height는 auto로 지정된다. MDN: background-size px값 지정 배경이미지 크기가 지정된 px값 그대로 설정된다. 첫번째 값은 width, 두번째 값은 height를 의미한다. 123.bg { background-size: 700px 500px;} %값 지정 배경이미지 크기가 지정된 %값에 비례하여 설정된다. 첫번째 값은 width, 두번째 값은 height를 의미한다. 화면을 줄이거나 늘리면 배경이미지의 크기가 따라서 변경되어 찌그러지는 현상이 나타난다. 123.bg { background-size: 100% 100%;} cover 지정 배경이미지의 크기 비율을 유지한 상태에서 부모 요소의 width, height 중 큰값에 배경이미지를 맞춘다. 따라서 이미지의 일부가 보이지 않을 수 있다. 123.bg { background-size: cover;} contain 지정 배경이미지의 크기 비율을 유지한 상태에서 부모 요소의 영역에 배경이미지가 보이지 않는 부분없이 전체가 들어갈 수 있도록 이미지 스케일을 조정한다. 123.bg { background-size: contain;} width, height의 프로퍼티값은 공백으로 구분하여야 한다. 프로퍼티값을 쉼표로 구분하면 다른 배경이미지의 너비를 지정하는 것으로 인식되기 때문에 주의가 필요하다. 12345body { background-image: url(&quot;front.png&quot;), url(&quot;back.png&quot;); background-repeat: no-repeat, no-repeat; background-size: 100%, 500px;} 4. background-attachment 프로퍼티일반적으로 화면을 스크롤하면 배경 이미지도 함께 스크롤 된다. 화면이 스크롤 되더라도 배경이미지는 스크롤되지 않고 고정되어 있게 하려면 background-attachment 프로퍼티에 fixed 키워드를 지정한다. 1background-attachment: fixed; 5. background-position 프로퍼티일반적으로 background-image는 좌상단부터 이미지를 출력한다. 이때 background-position 프로퍼티를 사용하면 이미지의 좌표(xpos,ypos)를 지정할 수 있다. 기본값은 background-position: 0% 0%; 로 배경이미지는 우측 상단에 위치하게 된다. MDN: background-position 1234567891011121314151617181920212223242526272829.example1 { background-position: top;}.example2 { background-position: bottom;}.example3 { background-position: center;}.example4 { background-position: left;}.example5 { background-position: right;}.example6 { /* &lt;percentage&gt; values */ background-position: 25% 75%;}.example7 { /* &lt;length&gt; values xpos ypos */ background-position: 10px 20px;}.example8 { background-position: 0px 0px, center;} 6. background-color 프로퍼티background-color 프로퍼티는 요소의 배경 색상을 지정한다. 색상값 또는 transparent 키워드를 지정할 수 있다. MDN: background-color 1234567.bg-col-white { background-color: rgb(255, 255, 255);}.bg-col-red { background-color: red;} 7. background Shorthandbackground-color, background-image, background-repeat, background-position를 한번에 정의하기 위한 Shorthand Syntax이다. 12// orderbackground: color || image || repeat || attachment || position MDN: background 1background: #FFEE99 url(&quot;URL&quot;) no-repeat center; Referencepoiemaweb.com/css3-background W3C CSS Document","link":"/2021/05/03/css3-day-6/"},{"title":"css3-day-7","text":"2.7 CSS3 Font &amp; Text폰트와 텍스트폰트 및 텍스트 관련 프로퍼티는 폰트의 크기, 폰트의 지정, 폰트의 스타일, 텍스트 정렬 등을 정의한다. 1. font-size 프로퍼티텍스트의 크기를 정의한다. font-size 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .font-size-40 { font-size: 40px; } .font-size-2x { font-size: 2.0em; } .font-size-150ps { font-size: 150%; } .font-size-large { font-size: large; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;default font size: 16px&lt;/p&gt; &lt;p class='font-size-40'&gt;font-size: 40px&lt;/p&gt; &lt;p class='font-size-2x'&gt;font-size: 2.0em&lt;/p&gt; &lt;p class='font-size-150ps'&gt;font-size: 150%&lt;/p&gt; &lt;p class='font-size-large'&gt;font-size: large&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 2. font-family 프로퍼티폰트를 지정한다. 컴퓨터에 해당 폰트가 설치되어 있지 않으면 적용되지 않는다. font-family 폰트는 여러 개를 동시에 지정이 가능하다. 첫번째 지정한 폰트가 클라이언트 컴퓨터에 설치되어 있지 않은 경우, 다음에 지정된 폰트를 적용한다. 따라서 마지막에 지정하는 폰트는 대부분의 OS에 기본적으로 설치되어 있는 generic-family 폰트(Serif, Sans-serif, Mono spase)를 지정하는 것이 일반적이다. 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .serif { font-family: &quot;Times New Roman&quot;, Times, serif; } .sans-serif { font-family: Arial, Helvetica, sans-serif; } .monospace { font-family: &quot;Courier New&quot;, Courier, monospace; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;font-family&lt;/h1&gt; &lt;p class=&quot;serif&quot;&gt;Times New Roman font.&lt;/p&gt; &lt;p class=&quot;sans-serif&quot;&gt;Arial font.&lt;/p&gt; &lt;p class=&quot;monospace&quot;&gt;Courier New font.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 3. font-style / font-weight 프로퍼티font-style 프로퍼티는 이탤릭체의 지정, font-weight 프로퍼티는 폰트 굵기 지정에 사용된다. font-style font-weight 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p { font-size: 2.0em; } /* font-style normal / italic / oblique */ .italic { font-style: italic; } /* font-weight 100 ~ 900 or normal / bold / lighter / bolder */ .light { font-weight: lighter; } .thick { font-weight: bold; } .thicker { font-weight: 900; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;normal style.&lt;/p&gt; &lt;p class=&quot;italic&quot;&gt;font-style: italic&lt;/p&gt; &lt;p class=&quot;light&quot;&gt;font-weight: lighter&lt;/p&gt; &lt;p class=&quot;thick&quot;&gt;font-weight: bold&lt;/p&gt; &lt;p class=&quot;thicker&quot;&gt;font-weight: 900&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 4. font ShorthandShorthand Syntax 1font : font-style(optional) font-variant(optional) font-weight(optional) font-size(mandatory) line-height(optional) font-family(mandatory) 123456789101112/* size | family */font: 2em &quot;Open Sans&quot;, serif;/* style | size | family */font: italic 2em &quot;Open Sans&quot;, sans-serif;/* style | variant | weight | size/line-height | family */font: italic small-caps bolder 16px/1.2 monospace;/* style | variant | weight | size/line-height | family *//* font-variant: small-caps; 소문자를 대문자로 만든다. 단 크기는 일반 대문자에 비해 더 작다.*/font: italic small-caps bolder 16px/3 cursive; 5. line-height 프로퍼티텍스트의 높이를 지정한다. 텍스트 수직 정렬에도 응용되어 사용된다. line-height 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .small { line-height: 70%; /* 16px * 70% */ } .big { line-height: 1.2; /* 16px * 1.2 */ } .lh-3x { line-height: 3.0; /* 16px * 3 */ } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; default line-height.&lt;br&gt; default line-height.&lt;br&gt; 대부분 브라우저의 default line height는 약 110% ~ 120%.&lt;br&gt; &lt;/p&gt; &lt;p class=&quot;small&quot;&gt; line-height: 70%&lt;br&gt; line-height: 70%&lt;br&gt; &lt;/p&gt; &lt;p class=&quot;big&quot;&gt; line-height: 1.2&lt;br&gt; line-height: 1.2&lt;br&gt; &lt;/p&gt; &lt;p class=&quot;lh-3x&quot;&gt; line-height: 3.0&lt;br&gt; line-height: 3.0&lt;br&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 다음은 수직 중앙 정렬 예제이다. a 요소의 line-height 값과 a 요소를 감싸는 div 요소의 height 값을 일치시킨다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .button { width: 150px; height: 70px; background-color: #FF6A00; border-radius: 30px; box-shadow: 5px 5px 5px #A9A9A9; } .button &gt; a { display: block; font: italic bold 2em/70px Arial, Helvetica, sans-serif; text-decoration: none; text-align: center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;button&quot;&gt; &lt;a href=&quot;#&quot;&gt;Click&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 6. letter-spacing 프로퍼티글자 사이의 간격을 지정한다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .loose { letter-spacing: 2px; } .tight { letter-spacing: -1px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/p&gt; &lt;p class=&quot;loose&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/p&gt; &lt;p class=&quot;tight&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 7. text-align 프로퍼티텍스트의 수평 정렬을 정의한다. 12345h1 { text-align: center; }h3 { text-align: right; }p.left { text-align: left; }p.justify { text-align: justify; }a { text-align: center; } 8. text-decoration 프로퍼티text-decoration 프로퍼티를 사용하여 링크 underline 을 제거할 수 있다. 또는 텍스트에 underline, overline, line-through를 추가할 수 있다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; a { text-decoration: none; } p:nth-of-type(1) { text-decoration: overline; } p:nth-of-type(2) { text-decoration: line-through; } p:nth-of-type(3) { text-decoration: underline; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href='#'&gt;text-decoration: none&lt;/a&gt; &lt;p&gt;text-decoration: overline&lt;/p&gt; &lt;p&gt;text-decoration: line-through&lt;/p&gt; &lt;p&gt;text-decoration: underline&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 9. white-space 프로퍼티white space는 공백(space), 들여쓰기(tab), 줄바꿈(line break)을 의미한다. html은 기본적으로 연속된 공백(space), 들여쓰기(tab)는 1번만 실행되며 줄바꿈(line break)은 무시된다. 또한 텍스트는 부모의 가로 영역을 벗어나지 않고 자동 줄바꿈(wrap)된다. white-space 프로퍼티는 이러한 기본 동작을 제어하기 위한 프로퍼티이다. 프로퍼티값 line break space/tab wrapping(자동줄바꿈) normal 무시 1번만 반영 O nowrap 무시 1번만 반영 X pre 반영 그래도 반영 X pre-wrap 반영 그래로 반영 O pre-line 반영 1번만 반영 O 12345.normal { white-space: normal; }.nowrap { white-space: nowrap; }.pre { white-space: pre; }.pre-wrap { white-space: pre-wrap; }.pre-line { white-space: pre-line; } 10. text-overflow 프로퍼티부모 영역을 벗어난 wrapping(자동줄바꿈)이 되지 않은 텍스트의 처리 방법을 정의한다. 이 프로퍼티를 사용하기 위해서는 아래의 조건이 필요하다. width 프로퍼티가 지정되어 있어야 한다. 이를 위해 필요할 경우 block 레벨 요소로 변경하여야 한다. 자동 줄바꿈을 방지하려면 white-space 프로퍼티를 nowrap으로 설정한다. overflow 프로퍼티에 반드시 “visible”이외의 값이 지정되어 이어야 한다. 1234567/* 부모 영역을 벗어난 텍스트를 잘라내어 보이지 않게 하고 말줄임표(...)를 표시한다. */.truncate { width: 150px; /* width가 지정되어 있어야 한다. */ white-space: nowrap; /* 자동 줄바꿈을 방지 */ overflow: hidden; /* 반드시 &quot;visible&quot; 이외의 값이 지정되어 있어야 한다. */ text-overflow: ellipsis; /* ellipsis or clip */} text-overflow 프로퍼티에 설정할 수 있는 프로퍼티 값은 아래와 같다. 프로퍼티값 Description clip 영역을 벗어난 텍스트를 표시하지 않는다. (default) ellipsis 영역을 벗어난 텍스트를 잘라내어 보이지 않게 하고 말줄임표(…)를 표시한다. &lt;!- &lt; string &gt; 프로퍼티값으로 지정한 임의의 문자열을 출력한다. 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; div { width: 150px; /* width가 지정되어 있어야 한다. */ height: 150px; padding: 10px; margin: 40px; border-radius: 6px; border-color: gray; border-style: dotted; white-space: nowrap; /* 자동 줄바꿈을 방지 */ overflow: hidden; /* 반드시 &quot;visible&quot; 이외의 값이 지정되어 있어야 한다. */ } .clip { text-overflow: clip; } .ellipsis { text-overflow: ellipsis; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;text-overflow&lt;/h1&gt; &lt;div class=&quot;clip&quot;&gt; &lt;h3&gt;clip&lt;/h3&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit &lt;/div&gt; &lt;div class=&quot;ellipsis&quot;&gt; &lt;h3&gt;ellipsis&lt;/h3&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 11. word-wrap 프로퍼티한 단어의 길이가 길어서 부모 영역을 벗어난 텍스트의 처리 방법을 정의한다. link 등을 표기할 때 그 길이가 매우 길어지는데 이 프로퍼티를 사용하지 않으면 부모 영역을 넘어가게 된다. 1.word-wrap { word-wrap: break-word; } 12. word-break 프로퍼티한 단어의 길이가 길어서 부모 영역을 벗어난 텍스트의 처리 방법을 정의한다. word-wrap 프로퍼티는 단어를 어느 정도는 고려한다. word-break: break-all; 는 단어를 고려하지 않고 부모 영역에 맞추어 강제 개행한다. Referencepoiemaweb.com/css3-font-text W3C CSS Document","link":"/2021/05/06/css3-day-7/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 깃허브 저장소에 소스 저장하기12345$ git init$ git remote add origin 저장소 주소$ git add .$ git commit -m 'commit msg'$ git push origin master","link":"/2021/04/12/hello-world/"},{"title":"html5 day 1","text":"1. HTML5 HTML(HyperText Markup Language) Markup Language 란? 태그 등을 이용하여 문서나 데이터의 구조를 명기하는 언어의 한가지태그: 문서의 골격에 해당하는 부분을 작성, 원래 텍스트와는 별도로 원고의 교정부호 및 주석을 표현하기 위한 것이었으나 용도가 점차 확장되어 문서의 구조를 표현하는 역할을 하게됨일반적으로는 데이터를 기술하는 정도로만 사용되기 때문에 프로그래밍 언어와는 구분됨 HTML (HyperText Markup Language) 웹페이지를 기술하기 위한 마크업 언어이다. 웹페이지의 내용(content)과 구조(structure)을 담당하는 언어로써 HTML 태그를 통해 정보를 구조화하는 것이다. HTML5 2014년 10월 28일 확정된 차세대 웹 표준으로 아래와 같은 기능들이 추가됨멀티미디어(Multimedia) 플래시와 같은 플러그인의 도움없이 비디오 및 오디오 기능을 자체적으로 지원한다. 그래픽(Graphics &amp; Effects) SVG, 캔버스를 사용한 2차원 그래픽과 CSS3, WebGL을 사용한 3차원 그래픽을 지원한다. 통신(Connectivity) 지금까지의 HTML은 단방향 통신만이 가능하였스나 HTML5는 서버와의 소켓통신을 지원하므로 서버와의 양방향 통신이 가능하다. 디바이스 접근(Device acess) 카메라, 동작센서 등의 하드웨어 기능을 직접적으로 제어할 수 있다. 오프라인 및 저장소(Offline &amp; Storage) 오프라인 상태에서도 애플리케이션을 동작시킬 수 있다. 이는 HTML5가 플랫폼으로서 사용될 수 있음을 의미한다. 시맨틱 태그(Semantics) HTML 요소의 의미를 명확히 설명하는 시맨틱 태그를 도입하여 브라우저, 검색엔진, 개발자 모두에게 콘텐츠의 의미를 명확히 설명할 수 있다. 이를 통해 HTML 요소의 의미를 명확히 해석하고 그 데이터를 활용할 수 있는 시맨틱 웹을 실현할 수 있다. CSS3 CSS3를 지원한다. 2. HTML5의 기본 문법 요소 (Element) HTML요소는 시작태그와 종료태그 그리고 태그사이에 위치한 content로 구성된다.태그는 대소문자를 구별하지 않으나 HTML4의 경우 소문자를 추천하고 있으므로 HTML5에서도 소문자를 사용하는것이 일반적 어브리뷰트 (Attribute) Attribute란 요소의 성질, 특징을 정의하는 명세이다.시작태그에 위치해야 하며 이름과 값의 쌍을 이룬다. 주석 (Comments) 주석은 주로 개발자에게 코드를 설명하기 위해 사용되며 브라우저는 주석을 화면에 표시하지 않는다. 3. 시맨틱 웹 (Semantic Web) - 의미론적 웹? SEO(검색엔진 최적화: Search Engin Optimization) 마케팅 도구를 사용하여 검색엔진이 본인의 웹사이트를 검색하기 알맞은 구조로 웹사이트를 조정하기도 한다.이것은 기본적으로 검색엔진이 웹사이트 정보를 어떻게 수집하는지 아는것으로 부터 시작된다. 검색엔진 검색엔진은 로봇(Robot)이라는 프로그램을 이용해 매일 전세계의 웹사이트 정보를 수집한다.(이것을 크롤링이라 하며 검색엔진의 크롤러가 이를 수행)그리고 검색 사이트 이용자가 검색할 만한 키워드를 미리 예상하여 검색 키워드에 대응하여 검색 키워드에 대응하는 인덱스(색인)을 만들어 둔다.(이것을 인덱싱이라 하며, 검색엔진의 인덱서가 이를 수행)인덱스를 생성할 때 사용되는 정보는 검색 로봇이 수집한 정보인데 결국 웹사이트의 HTML 코드이다.즉, 검색엔진은 HTML 코드만으로 그 의미를 인지하여야 하는데 이때 시맨틱 요소 (Semantic element)를 해석하게 된다. 시맨틱 태그란 브라우저, 검색엔진, 개발자 모두에게 콘텐츠의 의미를 명확히 설명하는 역할을 한다. 시맨틱 웹이란 웹에 존재하는 수많은 웹페이지들에 메타데이터(Metadata)를 부여하여, 기존의 잡다한 데이터 집합이었던 웹페이지를 의미와 관련성을 가지는 거대한 데이터베이스로 구축하고자 하는 발상 HTML 요소는 non-semetic 요소, semantic 요소로 구분할 수 있다. non-semantic 요소: div, span 등이 있으며 이들 태그는 content에 대하여 어떤 설명도 하지 않는다.semantic 요소: form, table, img 등이 있으며 이들 태그는 content의 의미를 명확히 설명한다. 4. HTML5 Tag - Basic 문서 형식 정의 tag HTML5 1&lt;!DOCTYPE html&gt; html tag html 태그는 모든 HTML 요소의 부모 요소이며 웹페이지에 단 하나만 존재한다. 즉, 모든 요소는 html 요소의 자식 요소이며 html 요소 내부에 기술해야한다.단, 1&lt;!DOCTYPE html&gt; 는 예외 head tag head 요소는 메타데이터를 포함하기 위한 요소 1.1 title tag title 요소는 문서의 제목을 정의한다. 정의된 제목은 브라우저의 탭에 표시된다. 1.2 style tag style 요소에는 HTML 문서를 위한 sytle 정보를 정의한다. 1.3 link tag link 요소에는 외부 리소스와의 연계 정보를 정의한다. 주로 HTML과 외부 CSS 파일을 연계에 사용된다. 1.4 script tag script 요소에는 client-side javascript를 정의한다. 1&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; 1.5 meta tag meta 요소는 description, keytwords, author, 기타 메타데이터 정의에 사용된다. 메타데이터는 브라우저, 검색엔진(keywords)등에 의해 사용된다.charset 어브리뷰트는 브라우저가 사용할 문자셋을 정의한다. 1&lt;meta charset=&quot;utf-8&quot;&gt; SEO(검색엔진 최적화)를 위해 검색엔진이 사용할 keywords를 정의한다. 1&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt; 웹페이지의 설명을 정의한다. 1&lt;meta name=&quot;description&quot; content=&quot;Web tutorials on HTML and CSS&quot;&gt; 웹페이지의 저자를 명기한다. 1&lt;meta name=&quot;author&quot; content=&quot;John Doe&quot;&gt; 웹페이지를 30초 마다 Refresh 한다. 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; body tag body tag는 HTML 문서의 내용을 나타내며 웹페이지에 단 하나만 존재한다.메타데이터를 제외한 웹페이지를 구성하는 대부분의 요소가 body 요소내에 기술된다. 123&lt;body&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/body&gt; 메타데이터: 메타데이터(metadata)는 데이터(data)에 대한 데이터이다. 이렇게 흔히들 간단히 정의하지만 엄격하게는, Karen Coyle에 의하면 “어떤 목적을 가지고 만들어진 데이터 (Constructed data with a purpose)”라고도 정의한다. SPA: single page application","link":"/2021/04/12/html5-day-1/"},{"title":"html5-day-2","text":"HTML5 Tag - LinkHTML의 핵심 개념인 HyperLinkHyperText의 Hyper는 컴퓨터 용어로서 텍스트 등의 정보가 동일 선상에 있는것이 아니라 다중으로 연결되어 있는 상태를 의미한다.이것은 HTML의 가장 중요한 특징인 Link의 개념과 연결되는데 기존 문서난 텍스트의 선형성, 고정성의 제약에서 벗어나 사용자가 원하는 순서대로 원하는 정보를 취득할 수 있는 기능을 제공한다.한 텍스트에서 다른 텍스트로 건너 뛰어 읽을 수 있는 이 기능을 하이퍼링크(hyperlink) 라 한다. 123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;a href=&quot;http://www.google.com&quot;&gt;Visit googole.com!&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Visit googole.com! 1. href 어트리뷰트href 어트리뷰트는 이동하고자 하는 파일의 위치(경로)를 값으로 받는다. 경로(path)란 파일 시스템 상에서 특정 파일의 위치를 의미한다. 1.1 디렉터리(Directory)디렉터리는 파일과 다른 디렉터리를 갖는 파일 시스템 내의 존재물로서 폴더라고도 불린다. 루트디렉터리파일 시스템 계층 구조 상의 최상위 디렉터리 Unix: / Window: C:\\ 홈 디렉터리시스템의 사용자에게 각각 할당된 개별 디렉터리이다. Unix: /Users/{계정명} Windows: C:\\Users{계정명} 작업디렉터리작업중인 파일의 위치한 디렉터리이다. ./ 부모 디렉터리작업 디렉터리의 부모 디렉토리이다. ../ 1.2 파일 경로(File path)파일 경로는 파일 시스템에서 파일의 위치를 나타내는 방법이다. 경로에는 절대경로와 상대경로가 있다. 절대경로(Absolute path)현재 작업 디렉터리와 관계없이 특정 파일의 절대적인 위치를 가리킨다. 루트 디렉터리를 기준으로 파일의 위치를 나타낸다. http://www.test.com/index.html /Users/img/testImage.png C:\\users\\img\\testImage.png /index.html 상대경로(Relative path) 현재 작업 디렉터리를 기준으로 특정 파일의 상대적인 위치를 가리킨다. ./index.html ../dist/index.js ../../dist/index.js index.html html/index.html href 어트리뷰트에 사용 가능한 값은 아래와 같다. Value Description 절대 URL 웹사이트 URL(href=”https://wontaejang.github.io/&quot;) 상대 URL 자신의 위치를 기준으로 한 대상의 URL (href=”html/about”) fragment identifier 페이지 내의 특정 id를 갖는 요소의 링크 (href=”#top”) 메일 mailto: script href=”javascript:alert(“Hello World”);” 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;a href=&quot;https://www.google.com&quot;&gt;URL&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;html/index.html&quot;&gt;Local file&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;file/test.pdf&quot; download&gt;Download file&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#top&quot;&gt;fragment identifier&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;mailto:someone@example.com?Subject=Hello again&quot;&gt;Send Mail&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;javascript:alert('Hello World');&quot;&gt;Javascript&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; URL Local file Download file fragment identifier Send Mail Javascript 2. target 어트리뷰트target 어트리뷰트는 링크를 클릭했을 때 윈도우를 어떻게 오픈할 지를 지정한다. Value Description _self 링크를 클릭했을 때 연결문서를 현재 윈도우에서 오픈한다(기본 값) _blank 링크를 클릭했을 때 연결문서를 새로운 윈도우나 탭에서 오픈한다 123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;a href=&quot;http://www.google.com&quot; target=&quot;_blank&quot;&gt;Visit google!&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2021/04/13/html5-day-2/"},{"title":"html5-day-3","text":"HTML5 Tag - List &amp; Table목록(list)와 표(Table)형식 표현을 위한 태그1. 목록(List)1.1 순서없는 목록 (Unordered List)1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h2&gt;순서없는 목록 (Unordered List)&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 순서없는 목록 (Unordered List) Coffee Tea Milk 1.2 순서있는 목록(Ordered List)1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h2&gt;순서있는 목록 (Ordered List)&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt;&lt;/html&gt; 순서있는 목록 (Ordered List) Coffee Tea Milk type 어트리뷰트를 사용하여 순서를 나타내는 문자를 지정할 수 있다. Value Description “1” 숫자 (기본값) “A” 대문자 알파벳 “a” 소문자 알파벳 “I” 대문자 로마숫자 “i” 소문자 로마숫자 12345&lt;ol type=&quot;I&quot;&gt; &lt;li value=&quot;2&quot;&gt;Coffee&lt;/li&gt; &lt;li value=&quot;4&quot;&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; Coffee Tea Milk start 어트리뷰트로 리스트의 시작값을 지정할 수 있다. 12345&lt;ol start=&quot;3&quot;&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; Coffee Tea Milk reversed 어트리뷰트를 지정하면 리스트의 순서값을 역으로 표현한다. 12345&lt;ol reversed&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; Coffee Tea Milk 1.3 중첩 목록12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h2&gt;중첩 목록&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ol&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 중첩 목록 Coffee Tea Black tea Green tea Milk 2. 테이블표(table)를 만들 때 사용하는 태그이다. 과거에는 테이블 태그를 사용하여 레이아웃을 구성하기도 하였으나 모던 웹에서는 주로 공간분할 태그인 div 태그를 사용하여 레이아웃을 구성한다. tag Description table 표를 감싸는 태그 tr 표 내부의 행 (table row) th 행 내부의 제목 셀(table heading) td 행 내부의 일반 셀(table data) 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;First name&lt;/th&gt; &lt;th&gt;Last name&lt;/th&gt; &lt;th&gt;Score&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jill&lt;/td&gt; &lt;td&gt;Smith&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Eve&lt;/td&gt; &lt;td&gt;Jackson&lt;/td&gt; &lt;td&gt;94&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;John&lt;/td&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; First name Last name Score Jill Smith 50 Eve Jackson 94 John Doe 80 테이블 태그의 어트리뷰트는 아래와 같다. attribute Description border 표 테두리 두께 지정 rowspan 해당 셀이 점유하는 행의 수 지정 colspan 해당 셀이 점유하는 열의 수 지정 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; table, th, td { border: 1px solid black; border-collapse: collapse; } th, td { padding: 15px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;2개의 culumn을 span&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;Telephone&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h2&gt;2개의 row를 span&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Name:&lt;/th&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;Telephone:&lt;/th&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;555 77 855&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; table, th, td { border: 1px solid black; border-collapse: collapse; } th, td { padding: 15px; } 2개의 culumn을 span Name Telephone Bill Gates 555 77 854 555 77 855 &lt;h2&gt;2개의 row를 span&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Name:&lt;/th&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;Telephone:&lt;/th&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;555 77 855&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;","link":"/2021/04/14/html5-day-3/"},{"title":"html5-day-4","text":"HTML5 Tag - Image &amp; Multimedia이미지의 표현과 동영상, 음악 등 멀티미디어를 지원하는 태그1. 이미지웹페이지에 이미지를 삽입하는 경우, img tag를 사용한다. attribute Description src 이미지 파일 경로 alt 이미지 파일이 없을 경우 표시되는 문장 width 이미지의 너비 (CSS에서 지정하는 것이 일반적 height 이미지의 높이 (CSS에서 지정하는 것이 일반적) 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;img src=&quot;img/cat.png&quot; alt=&quot;cat&quot; width=&quot;100&quot;&gt; &lt;img src=&quot;img/catcat.gif&quot; alt=&quot;이미지가 없습니다.&quot;&gt; &lt;/body&gt;&lt;/html&gt; 2. 미디어2.1 audioaudio 태그는 HTML5에서 새롭게 추가된 태그이다. IE8 이하에서는 사용할 수 없다. attribute Description src 음악 파일 경로 preload 재생 전에 음악 파일을 모두 불러올 것인지 지정 autoplay 음악 파일을 자동 재생 개시할 것인지 지정 loop 음악을 반복할 것인지 지정 controls 음악 재생 도구를 표시할 것인지 지정. 재생 도구의 외관은 브라우저마다 차이가 있다. 123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;audio src=&quot;/audio/test.mp3&quot; controls&gt;&lt;/audio&gt; &lt;/body&gt;&lt;/html&gt; 2.2 비디오video 태그는 HTML5에서 새롭게 추가된 태그이다. IE8 이하에서는 사용할 수 없다. attribute Description src 동영상 파일 경로 poster 동영상 준비 중에 표시될 이미지 파일 경로 preload 재생 전에 동영상 파일을 모두 불러올 것인지 지정 autoplay 동영상 파일을 자동 재생 개시할 것인지 지정(Chrome의 경우 mute를 설정해야지만 재생가능) loop 동영상을 반복할 것인지 지정 controls 동영상 재생도구를 표시할 것인지 지정, 재생도구의 외관은 브라우저마다 차이가 있다. width 동영상의 너비를 지정 height 동영상의 높이를 지정 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;Your browser does not support the video tag.&lt;/video&gt;","link":"/2021/04/17/html5-day-4/"},{"title":"html5-day-5","text":"HTML5 Tag - Forms사용자와의 커뮤니케이션을 위한 폼 태그1.formform 태그는 사용자가 입력한 데이터를 수집하기 위해 사용되며 input, textarea, button, select, checkbox, rado button, submit button 등의 입력 양식 태그를 포함할 수 있다. 12345&lt;form&gt;...form elements (input, checkbox, radio button, submit button...)...&lt;/form&gt; attribute value Description action URL 입력데이터(form data)가 전송될 URL 지정 method get/post 입력 데이터(form data)전달 방식 지정 GET과 POST는 HTTP프로토콜을 이용해서 사용자 입력 데이터를 서버에 전달하는 방식을 나타내며 HTTP request method라 한다. Get GET 방식은 전송 URL에 입력데이터를 쿼리스트링으로 보내는 방식이다.예) http://testURL.com/id=4444&amp;pw=1234 전송 URL 바로 뒤에 ‘?’를 통해 데이터의 시작을 알려주고, key-value형태의 데이터를 추가한다. 1개 이상의 전송데이터는 ‘&amp;’로 구분한다. URL에 전송 데이터가 모두 노출되기 때문에 보안에 문제가 있으며 전송할 수 있는 데이터의 한계가 있다. (최대 255자). REST API에서 GET 메소드는 모든 또는 특정 리소스의 조회를 요청한다. POST POST 방식은 Request Body에 담아 보내는 방식이다.URL에 전송 데이터가 모두 노출되지 않지만 GET에 비해 속도가 느리다.REST API에서 POST 메소드는 특정 리소스의 생성을 요청한다. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;form action=&quot;https://wontaejang.github.io/&quot; method=&quot;get&quot;&gt; ID: &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;br&gt; username: &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;WT.Jang&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ID: username: submit button이 클릭되면 input 태그에 입력된 데이터가 form 태그의 method어트리뷰트에 지정된 방식으로 action 어트리뷰트에 지정된 서버측의 처리 로직에 전달 된다. 2.inputinput 태그는 form 태그 중에서 가장 중요한 태그로 사용자로부터 데이터를 입력받기위해 사용된다.input 태그는 다양한 종류가 있는데 type 어트리뷰트에 의해 구분된다. form 태그 내에 존재하여야 입력 데이터를 전송할 수 있으나 ajax를 사용할 시에는 form 태그 내에 존재하지 않아도 된다. 서버에 전송되는 데이터는 name 어트리뷰터를 키로, value 어트리뷰트를 값으로하여 key = value의 형태로 전송된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h3&gt;button&lt;/h3&gt; &lt;input type=&quot;button&quot; value=&quot;Click me&quot; onclick=&quot;alert('Hello world!')&quot;&gt; &lt;hr&gt; &lt;h3&gt;checkbox&lt;/h3&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fruit1&quot; value=&quot;apple&quot; checked&gt; 사과&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fruit2&quot; value=&quot;grape&quot;&gt; 포도&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fruit3&quot; value=&quot;peach&quot;&gt; 복숭아&lt;br&gt; &lt;hr&gt; &lt;h3&gt;color&lt;/h3&gt; &lt;input type=&quot;color&quot; name=&quot;mycolor&quot;&gt; &lt;hr&gt; &lt;h3&gt;date&lt;/h3&gt; &lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt; &lt;hr&gt; &lt;h3&gt;datetime&lt;/h3&gt; &lt;input type=&quot;datetime&quot; name=&quot;birthdaytime&quot;&gt; &lt;hr&gt; &lt;h3&gt;datetime-local&lt;/h3&gt; &lt;input type=&quot;datetime-local&quot; name=&quot;birthdaytime&quot;&gt; &lt;hr&gt; &lt;h3&gt;email&lt;/h3&gt; &lt;input type=&quot;email&quot; name=&quot;useremail&quot;&gt; &lt;hr&gt; &lt;h3&gt;file&lt;/h3&gt; &lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt; &lt;hr&gt; &lt;h3&gt;hidden&lt;/h3&gt; &lt;input type=&quot;hidden&quot; name=&quot;country&quot; value=&quot;Norway&quot;&gt; hidden filed는 사용자에 표시되지 않는다. &lt;hr&gt; &lt;h3&gt;image&lt;/h3&gt; &lt;input type=&quot;image&quot; src=&quot;img/img_submit.gif&quot; alt=&quot;Submit&quot; width=&quot;48&quot; height=&quot;48&quot;&gt; &lt;hr&gt; &lt;h3&gt;month&lt;/h3&gt; &lt;input type=&quot;month&quot; name=&quot;birthdaymonth&quot;&gt; &lt;hr&gt; &lt;h3&gt;number&lt;/h3&gt; &lt;input type=&quot;number&quot; name=&quot;quantity&quot; min=&quot;2&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;2&quot;&gt; &lt;hr&gt; &lt;h3&gt;password&lt;/h3&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;hr&gt; &lt;h3&gt;radio&lt;/h3&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt; 남자&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 여자&lt;br&gt; &lt;hr&gt; &lt;h3&gt;range&lt;/h3&gt; &lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;1&quot; value=&quot;5&quot;&gt; &lt;hr&gt; &lt;h3&gt;reset&lt;/h3&gt; &lt;input type=&quot;reset&quot;&gt; &lt;hr&gt; &lt;h3&gt;search&lt;/h3&gt; &lt;input type=&quot;search&quot; name=&quot;googlesearch&quot;&gt; &lt;hr&gt; &lt;h3&gt;submit&lt;/h3&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;hr&gt; &lt;h3&gt;tel&lt;/h3&gt; &lt;input type=&quot;tel&quot; name=&quot;mytel&quot;&gt; &lt;hr&gt; &lt;h3&gt;text&lt;/h3&gt; &lt;input type=&quot;text&quot; name=&quot;myname&quot;&gt; &lt;hr&gt; &lt;h3&gt;time&lt;/h3&gt; &lt;input type=&quot;time&quot; name=&quot;mytime&quot;&gt; &lt;hr&gt; &lt;h3&gt;url&lt;/h3&gt; &lt;input type=&quot;url&quot; name=&quot;myurl&quot;&gt; &lt;hr&gt; &lt;h3&gt;week&lt;/h3&gt; &lt;input type=&quot;week&quot; name=&quot;week_year&quot;&gt; &lt;/body&gt;&lt;/html&gt; button checkbox 사과 포도 복숭아 color date datetime datetime-local email file hidden hidden filed는 사용자에 표시되지 않는다. image month number password radio 남자 여자 range reset search submit tel text time url week 3. select복수개의 리스트에서 복수개의 아이템을 선택할 때 사용한다. 함께 사용할 수 있는 태그는 다음과 같다. 서버에 전송되는 데이터는 select 요소의 name 어트리뷰트를 키로, option 요소의 value 어트리뷰트를 값으로 하여 key=value의 형태로 전송된다. tag Description select select form 생성 option option 생성 optgroup option을 그룹화한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;select name=&quot;cars1&quot;&gt; &lt;option value=&quot;volvo&quot; selected&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot; disabled&gt;Saab&lt;/option&gt; &lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;cars2&quot; size=&quot;4&quot; multiple&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt; &lt;option value=&quot;audi&quot; selected&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;cars3&quot;&gt; &lt;optgroup label=&quot;Swedish Cars&quot;&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=&quot;German Cars&quot; disabled&gt; &lt;option value=&quot;mercedes&quot;&gt;Mercedes&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; &lt;/body&gt;&lt;/html&gt; Volvo Saab Fiat Audi Volvo Saab Fiat Audi Volvo Saab Mercedes Audi 4. textareatextarea 태그는 여러 줄의 글자를 입력할 때 사용한다. 123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;textarea name=&quot;message&quot; rows=&quot;10&quot; cols=&quot;30&quot;&gt;Write something here&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; Write something here 5. buttonbutton 태그는 클릭할 수 있는 버튼을 생성한다. &lt;input type=&quot;button&quot;&gt; 과 유사하지만 input 태그는 빈 태그인 반면 button 태그는 그렇지 않다. 따라서 button 요소에는 텍스트나 이미지 같은 콘텐츠를 사용할 수 있다. type 어트리뷰트는 반드시 지정하는 것이 바람직하며 어트리뷰트 값으로 button, reset, submit를 지정할 수 있다. 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;button type=&quot;button&quot; onclick=&quot;alert('Hello World!')&quot;&gt;Click Me!&lt;/button&gt; &lt;input type=&quot;button&quot; value=&quot;Click Me!&quot; onclick=&quot;alert('Hello world!')&quot;&gt; &lt;/body&gt;&lt;/html&gt; Click Me! button 태그는 어트리뷰트만을 받아들이는 input 태그와 달리 콘텐츠로 문자열은 물론 HTML 요소를 받을 수도 있다는 장점이 있다. submit의 경우 브라우저마다 다를 수 있다. 1&lt;button type=&quot;submit&quot; name=&quot;myButton&quot; value=&quot;foo&quot;&gt;Click me&lt;/button&gt; 6.fieldset / legendfieldset 태그는 관련된 입력 양식들을 그룹화 할 때 사용한다. legend 태그는 fieldset 태그 내에서 사용되야 하며 그룹화된 fieldset의 제목을 정의한다. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;fieldset&gt; &lt;legend&gt;Login&lt;/legend&gt; Username &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; Password &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;/fieldset&gt; &lt;/body&gt;&lt;/html&gt; Login Username Password","link":"/2021/04/18/html5-day-5/"},{"title":"js-day1-javascript-environment","text":"브라우저 동작 원리구글의 Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경(Runtime Environment)인 Node.js의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 개발 언어가 되었다. 하지만 자바스크립트가 가장 많이 사용되는 분야는 역시 웹 브라우저 환경에서 동작하는 웹 페이지/애플리케이션이다. 대부분의 프로그래밍 언어는 운영체제(Operating System, OS) 위에서 실행되지만 웹 애플리케이션의 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다. 따라서 브라우저 환경을 고려할 때 보다 효율적인 자바스크립트 프로그래밍이 가능하다. 브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저는 서버로부터 HTML, CSS, Javascript, 이미지 파일 등을 응답받는다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 표시한다. 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, Javascript를 처리한다. 이것은 script 태그의 위치에 따로 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다. body 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다. Referencepoiemaweb.com/js-browser 브라우저는 어떻게 동작하는가?","link":"/2021/05/31/js-day1-javascript-environment/"},{"title":"html5-day-6","text":"HTML5 Tag - Structure웹페이지의 레이아웃을 구성하기 위해 공간을 분할하는 태그웹페이지의 레이아웃을 구성하기 위해서 공간을 분할할 필요가 있다. 공간을 분할할 수 있는 태그는 div, span, table 등이 있는데, 과거에는 table 태그를 사용하여 레이아웃을 구성하기도 하였으나 모던 웹에서는 주로 div를 사용하여 레이아웃을 구성한다. 그런데 div태그는 의미론적으로 어떠한 의미도 가지고 있지 않기 때문에 아래와 같이 HTML5에서 새롭게 추가된 시맨틱 태그를 사용하는 것이 더 나은 방법이나 IE에서 작동하지 않기 때문에 주의가 필요하다. tag Description header 헤더를 의미 nav 네비게이션을 의미 aside 사이드에 위치하는 공간을 의미 section 분문의 여러 내용(article)을 포함하는 공간을 의미 article 본문의 주 내용이 들어가는 공간을 의미 footer 바닥을 의미 이와 같은 공간 분할 태그는 일반적으로 다른 요소를 포함하는 컨테이너 역할을 하게 된다.div와 span의 차이는 block 레벨 요소와 inline 레벨 요소를 이해하여야 한다.","link":"/2021/04/19/html5-day-6/"},{"title":"js-day2-syntax-basics","text":"Syntax Basics자바스크립트의 기본 문법1. 변수변수(Variable)는 값(Value)을 저장(할당)하고 그 저장된 값을 참조하기 위해 사용한다. 한번 쓰고 버리는 값이 아닌 유지(캐싱)할 필요가 있는 값은 변수에 담아 사용한다. 이름을 통해 값의 의미를 명확히 할 수 있어 코드의 가독성이 좋아진다. 변수는 위치(주소)를 기억하는 저장소이다. 위치란 메모리 상의 주소(address)를 의미한다. 즉, 변수란 메모리 주소(Memory address)에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자(identifier)이다. 변수를 선언할 때 var 키워드를 사용한다. 할당 연산자 = 는 변수에 값을 할당하기 위해 사용한다. 아래의 예에서 x는 변수로 선언되었고 변수 x에는 정수값 6이 할당되었다. 12var x;x = 6; 2. 값1var str = 'Hello World'; 위 예제는 str이라는 이름의 변수를 선언하고 문자열 리터럴 ‘Hello World’를 값으로 할당하였다. 이때 문자열 리터럴 ‘Hello World’는 문자열 타입의 값이다. 용어 의미 데이터 타입(Data Type) 프로그래밍 언어에서 사용할 수 있는 값의 종류 변수(Varialble) 값이 저장된 메모리 공간의 주소를 가르키는 식별자(identifier) 리터럴(literal) 소스코드 안에서 직접 만들어 낸 상수 값 자체를 말하며 값을 구성하는 최소 단위 값(Value)은 프로그램에 의해 조작될 수 있는 대상을 말한다. 값은 다양한 방법으로 생성할 수 있다. 가장 간단한 방법은 리터럴 표기법(literal notation)을 사용하는 것이다. 1234567891011121314151617181920212223242526272829// 숫자 리터럴10.501001// 문자열 리터럴'Hello'&quot;World&quot;// 불리언 리터럴truefalse// null 리터럴null// undefined 리터럴undefined// 객체 리터럴{ name: 'Lee', gender: 'male' }// 배열 리터럴[ 1, 2, 3 ]// 정규표현식 리터럴/ab+c/// 함수 리터럴function() {} 숫자, 문자열, 불리언과 같은 원시 타입의 리터럴은 다양한 연산자의 피연산자가 되어 하나의 값으로 평가될 수 있다. 이렇게 리터럴은 연산에 의해 하나의 값이 될 수 있다. 12// 산술연산10.50 + 1001 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 7가지 데이터 타입을 제공한다. 원시 타입(primitive data type) number string boolean null undefined symbol (new in ECMAScript 6) 객체 타입(object data type) object 자바스크립트는 C나 Java외는 다르게 변수를 선언할 때 데이터 타입을 미리 지정하지 않는다. 다시 말해, 변수에 할당된 값의 타입에 의해 동적으로 변수의 타입이 결정된다. 이를 동적 타이핑이라 하며 자바스크립트가 다른 프로그래밍 언어와 구별되는 특징 중 하나이다. 12345678910111213141516171819202122232425// Numbervar num1 = 1001;var num2 = 10.50;// Stringvar string1 = 'Hello';var string2 = &quot;World&quot;;// Booleanvar bool = true;// nullvar foo = null;// undefinedvar bar;// Objectvar obj = { name: 'Lee', gender: 'male' };// Arrayvar array = [ 1, 2, 3 ];// functionvar foo = function() {}; 연산자연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다. 1234567891011121314151617181920// 산술 연산자var area = 5 * 4; // 20// 문자열 연결 연산자var str = 'My name is ' + 'Lee'; // &quot;My name is Lee&quot;// 할당 연산자var color = 'red'; // &quot;red&quot;// 비교 연산자var foo = 3 &gt; 5; // false// 논리 연산자var bar = (5 &gt; 3) &amp;&amp; (2 &lt; 4); // true// 타입 연산자var type = typeof 'Hi'; // &quot;string&quot;// 인스턴스 생성 연산자var today = new Date(); // (한국 표준시) 12var foo = 1 + '10'; // '110'var bar = 1 * '10'; // 10 4. 키워드키워드(keyword)는 수행할 동작을 규정한 것이다. 예를 들어 var 키워드는 새로운 변수를 생성할 것을 지시한다. 12345678910111213141516171819// 변수의 선언var x = 5 + 6;// 함수의 선언function foo (arg) { // 함수 종료 및 값의 반환 return ++arg;}var i = 0;// 반복문while (1) { if (i &gt; 5) { // 반복문 탈출 break; } console.log(i); i++;} 5. 주석주석(Comment)은 작성된 코드의 의미를 설명하기 위해 사용한다. 코드는 읽기(이해하기) 쉬워야 한다. (가독성이 좋아야 한다.) 내가 작성한 코드를 다른 누군가가 읽는다면 주석을 다는것이 좋다. 한줄 주석은 // 다음에 작성하며 여러줄 주석은 /* 과 */ 의 사이에 작성한다. 주석은 해석기(parser)가 무시하며 실행되지 않는다. 123456// 주석(Comment)은 작성된 코드의 의미를 설명하기 위해 사용한다. 코드는 읽기(이해하기) 쉬워야 한다./* 주석(Comment)은 작성된 코드의 의미를 설명하기 위해 사용한다. 코드는 읽기(이해하기) 쉬워야 한다.*/ 하지만 과도한 주석은 오히려 가독성을 해칠 수 있다. 주석 없이도 읽을 수 있는 코드가 최선이다. 1234567// Bad// 변수 x는 나이를 나타낸다. x에는 정수 10을 할당한다. var x = 10;// Goodvar age = 10; 6. 문프로그램(스크립트)은 컴퓨터(Client-side Javascript의 경우, 엄밀히 말하면 웹브라우저)에 의해 단계별로 수행될 명령들의 집합이다. 각각의 명령을 문(statement)이라 하며 문이 실행되면 무슨 일인가가 일어나게 된다. 문은 리터럴, 연산자(Operator), 표현식(Expression), 키워드(keyword)등으로 구성되며 세미콜론(;)으로 끝나야 한다. 12345var x = 5;var y = 6;var z = x + y;console.log(z); 문은 코드 블록(code block, {…})으로 그룹화할 수 있다. 그룹화의 목적은 함께 실행되어져야 하는 문을 정의하기 위함이다. 1234567891011121314// 함수function myFunction(x, y) { return x + y;}// if 문if(x &gt; 0) { // do something}// for 문for (var i = 0; i &lt; 10; i++) { // do something} 문들은 일반적으로 위에서 아래로 순서대로 실행된다. 이러한 실행 순서는 조건문 (if, switch)이나 반복문(while, for)의 사용으로 제어할 수 있다. 이를 흐름제어(Control Flow)라 한다. 또는 함수 호출로 변경될 수 있다. 123456789101112var time = 10;var greeting;if (time &lt; 10) { greeting = 'Good morning';} else if (time &lt; 20) { greeting = 'Good day';} else { greeting = 'Good evening';}console.log(greeting); 다른 언어와 달리 자바스크립트에서는블록 유효범위(Block-level-scope)를 생성하지 않는다. 함수 단위의 유효범위(Function-level-scope)만이 생성된다. 7. 표현식표현식(Expression)은 하나의 값으로 평가(Evaluation)된다. 값(리터럴), 변수, 객체의 프로퍼티, 배열의 요소, 함수 호출, 메소드 호출, 피연산자와 연산자의 표합은 모두 표현식이며 하나의 값으로 평가(Evaluation)된다. ㅠㅛ현식은 결국 하나의 값이 되기 때문에 다른 표현식의 일부가 되어 조금 더 복잡한 표현식을 구성할 수도 있다. 아래의 예에서 5 * 10은 50으로 평가(연산) 된다. 12345// 표현식5 // 55 * 10 // 505 * 10 &gt; 10 // true(5 * 10 &gt; 10) &amp;&amp; (5 * 10 &lt; 100) // true 8. 문과 표현식의 비교자연어에서 문(Statement)이 마침표로 끝나는 하나의 완전한 문장(Sentence)이라고 한다면 표현식은 문을 구성하는 요소이다. 표현식은 그자체로 하나의 문이 될 수도 있다. 1234// 선언문(Declaration statement)var x = 5 * 10; // 표현식 x = 5 * 10를 포함하는 문이다.// 할당문(Assignment statement)x = 100; // 이 자체가 표현식이지만 완전한 문이기도 하다. 표현식과 문은 매우 유사하여 구별이 어려울 수 있다. 표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. 문은 var, function과 같은 선언 키워드를 사용하여 변수나 함수를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다. 표현식을 통해 평가한 값을 통해 실제로 컴퓨터에게 명령을 하여 무언가를 하는 것은 문이다. 9. 함수함수란 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 불록에 담긴 문들을 일괄적으로 실행할 수 있다. 1234// 함수의 정의(함수 선언문)function square(number) { return number * number;} 함수는 호출에 의해 실행되는데 한번만 호출할 수 있는 것이 효율적이다. 이러한 특성은 코드의 재사용이라는 측면에서 매우 유용하다. 10. 객체자바스크립트는 객체(object) 기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든것”이 객체이다. 원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. 자바스크립트 객체는 키(이름)와 값으로 구성된 프로퍼티(property)의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. 123456789101112var person = { name: 'Lee', gender: 'male', sayHello: function () { console.log('Hi! My name is ' + this.name); }};console.log(typeof person); // objectconsole.log(person); // { name: 'Lee', gender: 'male', sayHello: [Function: sayHello] }person.sayHello(); // Hi! My name is Lee 이와 같이 객체를 데이터를 의미하는 프로퍼티(property)와 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드(method)로 구성된 집합이다. 객체는 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문에 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다. 자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 ‘프로토타입’이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다. 이 프로토타입은 타 언어와 구별되는 중요한 개념이다. 11. 배열배열(array)은 1개의 변수에 여러개의 값을 순차적으로 저장할 때 사용한다. 자바스크립트의 배열은 객체이며 유용한 내장 메소드를 포함하고 있다. 123var arr = [1, 2, 3, 4, 5];console.log(arr[1]); // 2 Referencepoiemaweb.com/js-syntax-basics","link":"/2021/06/01/js-day2-syntax-basics/"},{"title":"js-day7-object","text":"객체 (Object)1. 객체(Object)란?자바스크립트는 객체(object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. 자바스크립트의 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. 이와 같이 객체는 데이터를 의미하는 프로퍼티(property)와 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드(method)로 구성된 집합이다. 객체를 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문에 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다. 자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 “프로토타입(prototype)”이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다. 이 프로토타입은 타 언어와 구별되는 중요한 개념이다. 1.1 프로퍼티프로퍼티는 프로퍼티 키(이름)와 프로퍼티 값으로 구성된다. 프로퍼티는 프로퍼티 키로 유일하게 식별할 수 있다. 즉, 프로퍼티 키는 프로퍼티를 식별하기 위한 식별자(identifier)다. 프로퍼티 키의 명명 규칙과 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다. 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 symbol 값 프로퍼티 값: 모든 값 프로퍼티 키에 문자열이나 symbol 값 이외의 값을 지정하면 암묵적으로 타입이 변환되어 문자열이 된다. 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 배열과는 달리 객체는 프로퍼티를 열거할 때 순서를 보장하지 않는다. 1.2 메소드프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. 즉, 메소드는 객체에 제한되어 있는 함수를 의미한다. 2. 객체 생성 방법자바와 같은 클래스 기반 객체 지향언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 프로토타입 기반 객체 지향 언어로서 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다. ECMAScript 6에서 새롭게 클래스가 도입되었다. 프로토타입 기반 프로그래밍은 클래스가 존재하지 않는 객체지향 프로그래밍 스타일이다. 클래스없이 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현한다. 하지만 클래스 기반 언어에 익숙한 프로그래머들은 혼란을 일으킬 수 있으며 자바스크립트를 어렵게 느끼게하는 하나의 장벽처럼 인식되었다. ES6의 클래스는 기존 프로토타입 기반 객체지향 프로그래밍보다 클래스 기반 언어에 익숙한 프로그래머가 보다 빠르게 학습할 수 있는 단순하고 깨끗한 새로운 문법을 제시하고 있다. ES6의 클래스가 새로운 객체지향 모델을 제공하는 것이 아니며 클래스도 사실 함수이고 기존 프로토타입 기반 패턴의 문법적 설탕(Syntactic sugar)이다. 2.1 객체 리터럴가장 일반적인 자바스크립트의 객체 생성 방식이다. 클래스 기반 객체 지향 언어와 비교할 때 매우 간편하게 객체를 생성할 수 있다. 중괄호({})를 사용하여 객체를 생성하는데 {} 내에 1개 이상의 프로퍼티를 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. {} 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. 123456789101112131415var emptyObject = {};console.log(typeof emptyObject); // objectvar person = { name: 'Lee', gender: 'male', sayHello: function () { console.log('Hi! My name is ' + this.name); }};console.log(typeof person); // objectconsole.log(person); // {name: &quot;Lee&quot;, gender: &quot;male&quot;, sayHello: ƒ}person.sayHello(); // Hi! My name is Lee 2.2 Object 생성자 함수new 연산자와 Object 생성자 함수를 호출하여 빈 객체를 생성할 수 있다. 빈 객체 생성 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성하는 방법이다. 생성자(Constructor) 함수란 new 키워드와 함께 객체를 생성하고 초기화 하는 함수를 말한다. 생성자 함수를 통해 생성된 객체를 인스턴스(instrance)라 한다. 자바스크립트 Object 생성자 함수 이외에도 String, Number, Boolean, Arraym Date, RegExp 등의 빌트인 생성자 함수를 제공한다. 일반 함수와 생성자 함수를 구분하기 위해 생성자 함수의 이름은 파스칼 케이스(PascalCase)를 사용하는 것이 일반적이다. 객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당하면 해당 객체에 프로퍼티를 추가하고 값을 할당한다. 이미 존재하는 프로퍼티 키에 새로운 값을 할당하면 프로퍼티 값은 할당한 값으로 변경된다. 12345678910111213// 빈 객체의 생성var person = new Object();// 프로퍼티 추가person.name = 'Lee';person.gender = 'male';person.sayHello = function () { console.log('Hi! My name is ' + this.name);};console.log(typeof person); // objectconsole.log(person); // {name: &quot;Lee&quot;, gender: &quot;male&quot;, sayHello: ƒ}person.sayHello(); // Hi! My name is Lee 반드시 Object 생성자 함수를 사용해 빈 객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다. Object 생성자 함수 방식은 특별한 이유가 없다면 그다지 유용해 보이지 않는다. 사실 객체 리터럴 방식으로 생성된 객체는 결국 빌트인(Built-in) 함수인 Object 생성자 함수로 객체를 생성하는 것을 단순화시킨 축약 표현(short-hand)이다. 다시말해, 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object 생성자 함수를 사용하여 객체를 생성한다. 따라서 개발자가 일부러 Object 생성자 함수를 사용해 객체를 생성해야 할 일은 거의 없다. 2.3 생성자 함수객체 리터럴 방식과 Object 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러 개의 객체를 생성할 때 불편하다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야 한다. 123456789101112131415var person1 = { name: 'Lee', gender: 'male', sayHello: function () { console.log('Hi! My name is ' + this.name); }};var person2 = { name: 'Kim', gender: 'female', sayHello: function () { console.log('Hi! My name is ' + this.name); }}; 생성자 함수를 사용하면 마치 객체를 생성하기 위한 템플릿(클래스)처럼 사용하여 프로퍼티가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 1234567891011121314151617181920// 생성자 함수function Person(name, gender) { this.name = name; this.gender = gender; this.sayHello = function(){ console.log('Hi! My name is ' + this.name); };}// 인스턴스의 생성var person1 = new Person('Lee', 'male');var person2 = new Person('Kim', 'female');console.log('person1: ', typeof person1);console.log('person2: ', typeof person2);console.log('person1: ', person1);console.log('person2: ', person2);person1.sayHello();person2.sayHello(); 생성자 함수 이름은 일반적으로 대문자로 시작한다. 이것은 생성자 함수임을 익식하도록 도움을 준다. 프로퍼티 또는 메소드명 앞에 기술한 this는 생성자 함수가 생성할 인스턴스(instance)를 가르킨다. this에 연결(바인딩)되어 있는 프로퍼티와 메소드는 public (외부에서 참조 가능)하다. 생성자 함수 내에서 선언된 일반 변수는 private (외부에서 참조 불가능)하다. 즉, 생성자 함수내부에서는 자유롭게 접근이 가능하나 외부에서 접근할 수 없다. 12345678910111213141516function Person(name, gender) { var married = true; // private this.name = name; // public this.gender = gender; // public this.sayHello = function(){ // public console.log('Hi! My name is ' + this.name); };}var person = new Person('Lee', 'male');console.log(typeof person); // objectconsole.log(person); // Person { name: 'Lee', gender: 'male', sayHello: [Function] }console.log(person.gender); // 'male'console.log(person.married); // undefined 자바스크립트의 생성자 함수는 이름 그대로 객체를 생성하는 함수이다. 하지만 자바와 같은 클래스 기반 객체지향 언어의 생성자(constructor)와는 다르게 그 형식이 정해져 있는 것이 아니라 기존 함수와 동일한 방법으로 생성자 함수를 선언하고 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 이는 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것을 의미한다. 따라서 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼락을 방지하려는 노력을 한다. new 연산자와 함꼐 함수를 호출하면 this 바인딩이 다르게 동작한다. 자세한 내용은 생성자 호출 패턴을 참조 3. 객체 프로퍼티 접근3.1 프로퍼티 키프로퍼티 키는 일반적으로 문자열(빈 문자열 포함)을 지정한다. 프로퍼티 키에 문자열이나 symbol 값 이외의 값을 지정하면 암묵적으로 타입이 변환되어 문자열이 된다. 또한 문자열 타입의 값으로 수렴될 수 있는 표현식도 가능하다. 프로ㅓ퍼티 키는 문자열이므로 따옴표 (‘’ 또는 “”)를 사용한다. 하지만 자바스크립트에서 사용 가능한 유효한 이름인 경우, 따옴표를 생략할 수 있다. 반대로 말하면 자바스크립트에서 사용간으한 유효한 이름이 아닌 경우, 반드시 따옴표를 사용하여야 한다. 프로퍼티 값은 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메소드라 한다. 123456789var person = { 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male', 1: 10, function: 1 // OK. 하지만 예약어는 사용하지 말아야 한다.};console.log(person); 프로퍼티 키 first-name에는 반드시 따옴표를 사용해야 하지만 first_name 에는 생략 가능하다. first-name은 자바스크립트에서 사용 간으한 유효한 이름이 아니라 ‘-‘연산자가 있는 표현식이기 때문이다. 123var person = { first-name: 'Ung-mo', // SyntaxError: Unexpected token -}; 표현식을 프로퍼티 키로 사용하려면 키로 사용할 표현식을 대괄호로 묶어야 한다. 이때 자바스크립트 엔진은 표현식을 평가하기 위해 식별자 first를 찾을 것이고 이때 ReferenceError가 발생한다. 123var person = { [first-name]: 'Ung-mo', // ReferenceError: first is not defined}; 예약어를 프로퍼티 키로 사용하여도 에러가 발생하지는 않는다. 하지만 예상치 못한 에러가 발생할 수 있으므로 예약어를 프로퍼티 키로 사용해서는 않된다. 자바스크립트 예약어는 아래와 같다. 1234567891011121314abstract arguments boolean break bytecase catch char class* constcontinue debugger default delete dodouble else enum* eval export*extends* false final finally floatfor function goto if implementsimport* in instanceof int interfacelet long native new nullpackage private protected public returnshort static super* switch synchronizedthis throw throws transient truetry typeof var void volatilewhile with yield// *는 ES6에서 추가된 예약어 3.2 프로퍼티 값 읽기객체의 프로퍼티 값에 접근하는 방법은 마침표(.) 표기법과 대괄호([]) 표기법이 있다. 예제를 통해 이 두 방법의 차이를 살펴보자. 1234567891011121314151617181920var person = { 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male', 1: 10};console.log(person);console.log(person.first-name); // NaN: undefined-undefinedconsole.log(person[first-name]); // ReferenceError: first is not definedconsole.log(person['first-name']); // 'Ung-mo'console.log(person.gender); // 'male'console.log(person[gender]); // ReferenceError: gender is not definedconsole.log(person['gender']); // 'male'console.log(person['1']); // 10console.log(person[1]); // 10 : person[1] -&gt; person['1']console.log(person.1); // SyntaxError 프로퍼티 키가 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다. 프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, 대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열이어야 한다. 객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다. 1234567var person = { 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',};console.log(person.age); // undefined 3.3 프로퍼티 값 갱신객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 갱신 된다. 12345678var person = { 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',};person['first-name'] = 'Kim';console.log(person['first-name'] ); // 'Kim' 3.4 프로퍼티 동적 생성객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당하면 주어진 키와 값으로 프로퍼티를 생성하여 객체에 추가한다. 12345678var person = { 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',};person.age = 20;console.log(person.age); // 20 3.5 프로퍼티 삭제delete 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. 이때 피연산자는 프로퍼티 키이어야 한다. 1234567891011var person = { 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',};delete person.gender;console.log(person.gender); // undefineddelete person;console.log(person); // Object {first-name: 'Ung-mo', last-name: 'Lee'} 3.6 for-in문for-in 문을 사용하면 객체(배열 포함)에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다. 12345678910111213141516171819202122232425262728var person = { 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male'};// prop에 객체의 프로퍼티 이름이 반환된다. 단, 순서는 보장되지 않는다.for (var prop in person) { console.log(prop + ': ' + person[prop]);}/*first-name: Ung-molast-name: Leegender: male*/var array = ['one', 'two'];// index에 배열의 경우 인덱스가 반환된다for (var index in array) { console.log(index + ': ' + array[index]);}/*0: one1: two*/ for-in 문은 객체의 문자열 키(key)를 순회하기 위한 문법이다. 배열에는 사용하지 않는것이 좋다. 객체의 경우, 프로퍼티의 순서가 보장되지 않는다. 그 이유는 원래 객체의 프로퍼티에는 순서가 없기 때문이다. 배열은 순서를 보장하는 데이터 구조이지만 객체와 마찬가지로 순서를 보장하지 않는다. 배열 요소들만을 순회하지 않는다. 12345678910111213// 배열 요소들만을 순회하지 않는다.var array = ['one', 'two'];array.name = 'my array';for (var index in array) { console.log(index + ': ' + array[index]);}/*0: one1: twoname: my array*/ 이와 같은 for-in문의 단점을 극복하기 위해 ES6에서 for-of문이 추가되었다. 12345678910111213141516171819202122const array = [1, 2, 3];array.name = 'my array';for (const value of array) { console.log(value);}/*123*/for (const [index, value] of array.entries()) { console.log(index, value);}/*0 11 22 3*/ for–in 문은 객체의 프로퍼티를 순회하기 위해 사용하고 for–of 문은 배열의 요소를 순회하기 위해 사용한다. 4. Pass-by-referenceobject type을 객체 타입 또는 참조 타입이라 한다. 참조 타입이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다. 원시 타입은 값이한번 정해지면 변경할 수 없지만 (immutable), 객체는 프로퍼티를 변경, 추가, 삭제가 가능하므로 변경 가능(mutable)한 값이라 할 수 있다. 따라서 객체 타입은 동적으로 변화할 수 있으므로 어느 정도의 메모리 공간을 확보해야 하는지 예측할 수 없기 때문에 런타임에 메모리 공간을 확보하고 메모리의 힙 영역(Heap Segment)에 저장된다. 이에 반해 원시 타입은 값(value)으로 전달된다. 즉, 복사되어 전달된다. 이를 pass-by-value라 한다. 123456789101112// Pass-by-referencevar foo = { val: 10}var bar = foo;console.log(foo.val, bar.val); // 10 10console.log(foo === bar); // truebar.val = 20;console.log(foo.val, bar.val); // 20 20console.log(foo === bar); // true foo 객체를 객체 리터럴 방식으로 생성하였다. 이때 변수 foo는 객체 자체를 정항하고 있는것이 아니라 생성된 객체의 참조값(address)를 저장하고 있다. 변수 bar에 변수 foo의 값을 할당하였다. 변수 foo의 값은 생성된 객체를 가리키는 참조값이므로 변수 bar에도 같은 참조값이 저장된다. 즉, 변수 foo, bar 모두 동일한 객체를 참조하고 있다. 따라서 참조하고 있는 객체의 val 값이 변경되면 변수 foo, bar 모두 동일한 객체를 팜조하고 있으므로 두 변수 모두 변경된 객체의 프로퍼티 값을 참조하게 된다. 객체는 참조(Reference)방식으로 전달된다. 결코 복사되지 않는다. foo –&gt; val:10 &lt;– bar 아래의 경우는 위의 경우와 약간 차이가 있다. 12345678910var foo = { val: 10 };var bar = { val: 10 };console.log(foo.val, bar.val); // 10 10console.log(foo === bar); // falsevar baz = bar;console.log(baz.val, bar.val); // 10 10console.log(baz === bar); // true 변수 foo와 변수 bar는 비록 내용은 같지만 별개의 객체를 생성하여 참조값을 할당하였다. 따라서 변수 foo와 변수 bar의 참조값 즉 어드레스는 동일하지 않다. 변수 baz에는 변수 bar의 값을 할당하였다. 결국 변수 baz와 변수 bar는 동일한 객체를 가리키는 참조값을 저장하고 있다. 따라서 변수 baz와 변수 bar의 참조값은 동일하다. foo –&gt; val:10bar –&gt; val:10 &lt;– baz 12345var a = {}, b = {}, c = {}; // a, b, c는 각각 다른 빈 객체를 참조console.log(a === b, a === c, b === c); // false false falsea = b = c = {}; // a, b, c는 모두 같은 빈 객체를 참조console.log(a === b, a === c, b === c); // true true true 5. Pass-by-value원시타입 값(value)으로 전달된다. 즉, 값이 복사되어 전달된다. 이를 pass-by-value(값에 의한 전달)라 한다. 원시타입은 값이 한번 정해지면 변경할 수 없다.(immutable) 또한 이들 값은 런타임(변수 할당 시점)에 메모리의 스택 영역(Stack Segment)에 고정된 메모리 영역을 점유하고 저장된다. immutable에 대한 상세한 내용은 객체와 변경불가성(Immutability)을 참조 12345678910// Pass-by-valuevar a = 1;var b = a;console.log(a, b); // 1 1console.log(a === b); // truea = 10;console.log(a, b); // 1 10console.log(a === b); // false 변수 a는 원시 타입인 숫자 타입 1을 저장하고 있다. 원시 타입의 경우 값이 복사되어 변수에 저장된다. 즉, 참조 타입으로 저장되는 것이 아니라 값 자체가 저장되게 된다. 변수 b에 변수 a를 할당할 경우, 변수 a의 값 1은 복사되어 변수 b에 저장된다. 6. 객체의 분류객체는 아래와 같이 분류할 수 있다. Object Host Obejct Built-in Object Standard Built-in Object Native Object BOM(Browser Object Model) DOM(Document Object Model) Built-in Object(내장 객체)는 웹페이지 등을 표현하기 위한 공통의 기능을 제공한다. 웹페이지가 브라우저에 의해 로드되자마자 별다른 행위없이 바로 사용이 가능하다. Built-in Object는 아래와 같이 구분할 수 있다. Standard Built-in Objects (or Global Objects) BOM (Browser Object Model) DOM (Document Object Model) Standard Built-in Objects(표준 빌트인 객체)를 제외한 BOM과 DOM을 Native Object라고 분류하기도 한다. 또한 사용자가 생성한 객체를 Host Object(사용자 정의 객체)라 한다. Host Object(사용자 정의 객체)사용자가 생성한 객체 들이다. constructor 혹은 객체리터럴을 통해 사용자가 객체를 정의하고 확장시킨 것들이기 때문에 Built-in Object 와 Native Object가 구성된 이후에 구성된다. Referencepoiemaweb.com/js-object","link":"/2021/06/30/js-day7-object/"},{"title":"py-day1-Hello-World","text":"Python 시작1. python 설치하기python.org 해당 페이지로 이동하여 최신버전 Python을 다운 및 설치한다. 설치시 Add Python X.X to PATH 를 클릭해야 Path 설정 따로 안해도 됨 설치후 윈도우키 -&gt; cmd -&gt; python 입력을 했을때 설치 버전이 나오지 않는다면 2.1 참조 2.1 Python Path 설정 2. Hello World설치가 되었다면 파이썬 언어가 제대로 설치되었는지 확인을 위해 ‘Hello World’를 출력해봅니다. cmd -&gt; python 입력 print(‘Hello World’) 입력 후 엔터1print('Hello World')","link":"/2021/07/01/py-day1-Hello-World/"},{"title":"py-day2-syntax-1","text":"Python Syntax 1들여쓰기들여쓰기는 코드 줄의 시작 부분에 있는 공백을 나타냅니다.다른 프로그래밍 언어에서는 코드의 들여쓰기는 가독성만을 위한 것이지만 Python의 들여쓰기는 매우 중요합니다.파이썬은 들여쓰기를 사용하여 코드블록 을 나타냅니다. Example1234567if 5 &gt; 2: print(&quot;Five is greater than two!&quot;)# Syntax Errorif 5 &gt; 2:print(&quot;Five is greater than two!&quot;) 공백의 수는 프로그래머에게 달려있지만 적어도 하나는 있어야합니다. Example1234if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) 동일한 코드 블록에서 동일한 수의 공백을 사용해야합니다. Example123if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) print(&quot;Five is greater than two!&quot;) Referencew3schools python","link":"/2021/07/01/py-day2-syntax-1/"},{"title":"css3-day-15","text":"CSS3 Animation애니메이션애니메이션(Animation)효과는 HTML 요소에 적용되는 CSS 스타일을 다른 CSS 스타일로 부드럽게 변화시킨다. 애니메이션은 애니메이션을 나타내는 CSS 스타일과 애니메이션 sequence를 나타내는 복수의 키프레임(@keyframes)들로 이루어진다. transition으로도 어느정도의 애니메이션 효과를 표현할 수 있으나 animation보다는 제한적이다. 일반적으로 트랜지션 효과는 요소 프로퍼티값이 다른 값으로 변화할 때 주로 사용하며 요소의 로드와 함께 자동으로 발동되지 않는다. :hover와 같은 가상 클래스 선택자(Pseudo-Class Selector)또는 자바스크립트의 이벤트와 같은 부수적 액션에 의해 발동된다. 즉 transition 프로퍼티는 단순히 요소의 프로퍼티 변화에 주안점이 있다면 animation 프로퍼티는 하나의 줄거리를 구성하여 줄거리 내에서 세부 움직임을 시간흐름 단위로 제어할 수 있고 전체 줄거리의 재생과 정지, 반복까지 제어할 수 있다. 일반적으로 CSS 애니메이션을 사용하면 기존의 JavaScript 기반 애니메이션 실행과 비교하여 더 나은 렌더링 성능을 제공한다고 알려져 있다. 그러나 경우에 따라서는 JavaScript를 사용하는 것이 나을 수도 있다. jQuery 등의 애니메이션 기능은 CSS보다 간편하게 애니메이션 효과를 가능케 한다. 비교적 작은 효과나 CSS만으로도 충분한 효과를 볼 수 있는 것은 CSS를 사용한다. 예를 들어 요소의 width 변경 애니메이션은 자바스크립트를 사용하는 것보다 훨씬 간편하며 효과적이다. 세밀한 제어를 위해서는 자바스크립트 사용이 바람직하다. 예를 들어 바운스, 중지, 일시중지, 되감기 또는 감속과 같은 고급 효과는 자바스크립트가 훨씬 유용하다. 가장 중요한 것은 브라우저에서 애니메이션 효과가 부드럽게 실행되는 것이다. 그리고 애니메이션 효과 작성에 소요되는 시간과 수고이다. 여러 사항들을 고려하여 자바스크립트를 사용하여야 할지 CSS를 사용하여야 할지 결정하여야 한다. 프로퍼티 설명 기본값 animation-name @keyframe 애니메이션 이름을 지정한다 animation-duration 한 싸이클의 애니메이션에 소요되는 시간을 초 단위(s) 또는 밀리 초 단위(ms)로 지정한다 0s animation-timing-function 애니메이션 효과를 위한 타이밍 함수를 지정한다 ease animation-delay 요소가 로드된 시점과 애니메이션이 실제로 시작하는 사이에 대기하는 시간을 초 단위(s) 또는 밀리 초 단위(ms)로 지정한다 0s animation-iteration-count 애니메이션 재생 횟수를 지정한다 1 animation-direction 애니메이션이 종료된 이후 반복될 때 진행하는 방향을 지정한다 normal animation-fill-mode 애니메이션 미실행 시(종료 또는 대기) 요소의 스타일을 지정한다. animation-play-state 애니메이션 재생 상태(재생 또는 중지)를 지정한다 running animation 모든 애니메이션 프로퍼티를 한번에 지정한다(shorthand syntax) 1. @keyframes @keyframes CSS 애니메이션과 트랜지션 방식의 주된 차이는 @keyframes rule에 있다. 이 rule을 사용하면 애니메이션의 흐름(sequence)중의 여러 시점(breakpoint)에서 CSS 프로퍼티값을 지정할 수 있다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { position: absolute; width: 100px; height: 100px; background-color: red; animation-name: move; animation-duration: 5s; animation-iteration-count: infinite; } /* @keyframes rule */ @keyframes move { /* keyframe */ from { left: 0; } /* keyframe */ to { left: 300px; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result @keyframes rule은 시간의 흐름에 따라 애니메이션을 정의한다. 여러 개의 키프레임을 정의하거나 애니메이션 중에 특정 CSS프로퍼티에 값을 지정하는 지점을 정의할 수 있다. 위 예제를 보면 @keyframes 뒤에 애니메이션을 대표하는 임의의 이름을 부여하였다. 1@keyframes move {} from, to 키워드를 사용하여 애니메이션의 시작과 끝 시점을 정의하였다. 그리고 애니메이션의 시작 시점을 의미하는 from 키프레임 내에서 left 프로퍼티에 값 0을, 애니메이션의 끝 시점을 의미하는 to 키프레임 내에서 left 프로퍼티에 값 300px을 지정하였다. 그 결과, 정지 상태에서 오른쪽으로 300px 이동하는 애니메이션이 실행된다. 123456@keyframes move { /* 애니메이션 시작 시점 */ from { left: 0; } /* 애니메이션 종료 시점 */ to { left: 300px; }} from, to 키워드 대신 %를 사용할 수 있다. 또한 시작과 끝 키프레임 사이에 % 단위로 키프레임을 삽입할 수 있다. 12345@keyframes move { 0% { left: 0; } 50% { left: 100px; } 100% { left: 300px; }} 2.animation-name위 예제를 보면 @keyframes 뒤에 애니메이션을 대표하는 임의의 이름을 부여하였다. 1@keyframes move{} 이 이름을 animation-name 프로퍼티값으로 지정하여 사용하고자 하는 @keyframes rule을 선택한다. 하나 이상의 애니메이션 이름을 지정할 수 있다. 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { position: absolute; width: 100px; height: 100px; animation-name: move, fadeOut, changeColor; animation-duration: 5s; animation-iteration-count: infinite; } @keyframes move { from { left: 0; } to { left: 300px; } } @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } } @keyframes changeColor { from { background-color: red; } to { background-color: blue; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 3. animation-duration한 싸이클의 애니메이션에 소요되는 시간을 초 단위(s) 또는 밀리 초 단위(ms)로 지정한다. 12animation-duration: .5s;animation-duration: 500ms; animation-duration은 반드시 지정해야 한다. 지정하지 않는 경우 기본값 0s가 셋팅되어 어떠한 애니메이션도 실행되지 않는다. 4. animation-timing-function애니메이션 효과를 위한 수치 함수를 지정한다. 수치 함수에 대한 설명은 트랜지션 transtition-timing-function 프로퍼티를 참조. 5. animation-delay요소가 로드된 시점과 애니메이션이 실제로 시작하는 사이에 대기하는 시간을 초 단위(s) 또는 밀리 초 단위(ms)로 지정한다. 1animation-delay: 2s; 6. animation-iteration-count애니메이션 주기의 재생 횟수를 지정한다. 기본값은 1이며 infinite로 무한반복 할 수 있다. 1animation-iteration-count: 3; 7.animation-direction애니메이션이 종료된 이후 반복될 때 진행하는 방향을 지정한다. 프로퍼티값 설명 normal 기본값으로 from(0%)에서 to(100%)방향으로 진행한다. reverse to에서 from 방향으로 진행한다. alternate 홀수번째는 normal로, 짝수번째는 reverse로 진행한다. alternate-reverse 홀수번째는 reverse로, 짝수번째는 normal로 진행한다. 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 100px; background: red; position: relative; animation: myAnimation 5s infinite; /*홀수번째는 normal로, 짝수번째는 reverse로 진행*/ animation-direction: alternate; } @keyframes myAnimation { 0% { background: red; left: 0px; top: 0px; } 25% { background: yellow; left: 200px; top: 0px; } 50% { background: blue; left: 200px; top: 200px; } 75% { background: green; left: 0px; top: 200px; } 100% { background: red; left: 0px; top: 0px; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result 8.animation-fill-mode애니메이션 미실행 시(대기 또는 종료) 요소의 스타일을 지정한다. 프로퍼티값 상태 설명 none 대기 시작 프레임(from)에 설정한 스타일을 적용하지 않고 대기한다. 종료 애니메이션 실행 전 상태로 애니메이션 요소의 프로퍼티값을 되돌리고 종료한다. forwards 대기 시작 프레임(from)에 설정한 스타일을 적용하지 않고 대기한다. 종료 종료 프레임(to)에 설정한 스타일을 적용하고 종료한다. backwards 대기 시작 프레임(from)에 설정한 스타일을 적용하고 대기한다. 종료 애니메이션 실행 전 상태로 애니메이션 요소의 프로퍼티값을 되돌리고 종료한다. both 대기 시작 프레임(from)에 설정한 스타일을 적용하고 대기한다. 종료 종료 프레임(to)에 설정한 스타일을 적용하고 종료한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 100px; font: bold 1em/100px san-serif; text-align: center; color: #fff; background: red; margin-bottom: 10px; position: relative; /*name duration timing-function delay iteration-count direction fill-mode play-state*/ animation: myAnimation 2s linear 2s; } div:nth-of-type(1) { animation-fill-mode: none; } div:nth-of-type(2) { animation-fill-mode: forwards; } div:nth-of-type(3) { animation-fill-mode: backwards; } div:nth-of-type(4) { animation-fill-mode: both; } @keyframes myAnimation { 0% { left: 0px; background: yellow; } 100% { left: 200px; background: blue; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;animation-fill-mode&lt;/h1&gt; &lt;div&gt;none&lt;/div&gt; &lt;p&gt;대기 : 시작 프레임(from)에 설정한 스타일을 적용하지 않고 대기한다.&lt;/p&gt; &lt;p&gt;종료 : 애니메이션 실행 전 상태로 애니메이션 요소의 프로퍼티값을 되돌리고 종료한다.&lt;/p&gt; &lt;div&gt;forwards&lt;/div&gt; &lt;p&gt;대기 : 시작 프레임(from)에 설정한 스타일을 적용하지 않고 대기한다. &lt;p&gt;종료 : 종료 프레임(to)에 설정한 스타일을 적용하고 종료한다. &lt;div&gt;backwards&lt;/div&gt; &lt;p&gt;대기 : 시작 프레임(from)에 설정한 스타일을 적용하고 대기한다. &lt;p&gt;종료 : 애니메이션 실행 전 상태로 애니메이션 요소의 프로퍼티값을 되돌리고 종료한다. &lt;div&gt;both&lt;/div&gt; &lt;p&gt;대기 : 시작 프레임(from)에 설정한 스타일을 적용하고 대기한다. &lt;p&gt;종료 : 종료 프레임(to)에 설정한 스타일을 적용하고 종료한다.&lt;/body&gt;&lt;/html&gt; result 9.animation-play-state애니메이션 재생 상태(재생 또는 중지)를 지정한다. 기본값은 running이다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 100px; background: red; position: relative; /*name duration timing-function delay iteration-count direction fill-mode play-state*/ animation: move 5s infinite; } div:hover { background: blue; animation-play-state: paused; } div:active { background: yellow; animation-play-state: running; } @keyframes move { from { left: 0px; } to { left: 200px; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;animation-play-state&lt;/h1&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box { position: relative; width: 100px; height: 100px; background-color: red; animation-name: move; animation-duration: 5s; animation-play-state: paused; /* 초기 애니메이션 재생 상태: 정지 */ animation-iteration-count: infinite; } /* @keyframes rule */ @keyframes move { from { left: 0; } to { left: 300px; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;button class=&quot;start&quot;&gt;start animation&lt;/button&gt; &lt;button class=&quot;pause&quot;&gt;pause animation&lt;/button&gt; &lt;script&gt; const box = document.querySelector('.box'); document.querySelector('.start').addEventListener('click', function () { // trigger animation // prefixes would be needed... box.style.animationPlayState = 'running'; }); document.querySelector('.pause').addEventListener('click', function () { // pause animation // prefixes would be needed... box.style.animationPlayState = 'paused'; }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; result 10.animation모든 애니메이션 프로퍼티를 한번에 지정한다. 값을 지정하지 않은 프로퍼티에는 기본값이 지정된다. 지정 방법은 다음과 같다. 1animation: name duration timing-function delay iteration-count direction fill-mode play-state animation-duration은 반드시 지정해야 한다. 지정하지 않는 경우 기본값 0s가 셋팅되어 어떠한 애니메이션도 실행되지 않는다. 기본값은 아래와 같다. 1none 0 ease 0 1 normal none running Referencepoiemaweb.com/css3-animation css3generator.com","link":"/2021/05/26/css3-day-15/"},{"title":"css3-day-14","text":"CSS3 Transition트렌지션트랜지션(transition)은 CSS 프로퍼티의 값이 변화할때, 프로퍼티 값의 변화가 일정시간(duration)에 걸쳐 일어나도록 하는 것이다. 예를 들어 아래의 예제를 살펴보자 div 요소는 기본 상태에서 hover 상태로 변화할 때, CSS 프로퍼티 border-radius와 backround 프로퍼티의 값이 변화한다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 100px; background: red; } div:hover { border-radius: 50%; background: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 상태 변화에 따라 CSS 프로퍼티가 변화되면 프로퍼티 변경에 따른 표시의 변화(transition)는 지체없이 즉시 발생한다. 위 예제의 경우, div 요소에 마우스가 올라가서 hover 상태가 되면 div 요소의 border-radius, background 프로퍼티의 값이 즉시 변경된다. 트랜지션(transition)은 상태 변화에 동반하여 변경되는 CSS 프로퍼티 값에 의한 표시의 변화를 부드럽게 하기 위해 애니메이션 속도를 조절한다. 즉, 프로퍼티 값의 변경이 표시의 변화에 즉시 영향을 미치게 하는 대신 그 프로퍼티 값의 변화가 일정시간(duration)에 걸쳐 일어나도록 하는 것이다. 위 예제에 트랜지션 효과를 부여해 보자. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 100px; background: red; /* 트랜지션 효과: 모든 프로퍼티의 변화를 2초에 걸쳐 전환한다. */ transition: all 2s; } div:hover { border-radius: 50%; background: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 위 예제에서는 div 요소에 마우스가 올라갈 때(hover on)와 마우스가 내려올 때(hover off)border-radius, background 프로퍼티 값의 변화가 발생한다. 그리고 이들 프로퍼티 값의 변화를 2초에 걸쳐 이루어지도록 설정한 것이다. div 셀렉터의 룰셋에 트랜지션을 설정하면 마우스가 올라갈 때(hover on)와 마우스가 내려올 때(hover off)모두 트랜지션이 발동한다. 하지만 div:hover 셀렉터의 룰셋에 트랜지션을 설정하면 마우스가 올라갈 때(hover on)는 트랜지션이 발동하지만 마우스가 내려올 때(hover off)는 트랜지션이 발동하지 않는다. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 100px; background: red; } div:hover { background: blue; border-radius: 50%; /* hover on에서만 발동한다. */ transition: all 2s; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result transition은 자동으로 발동되지 않는다. :hover와 같은 가상 클래스 선택자(Pseudo-Classes)또는 JavaScript의 부수적인 액션에 의해 발동한다. 위 예제의 div 요소에 적용된 트랜지션은 이와 같은 부수적 액션없이는 어떤 효과도 볼 수 없다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 100px; background: red; transition: all 2s; } .hover { background: blue; border-radius: 50%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;script&gt; const elem = document.querySelector('div'); elem.addEventListener('mouseover', function () { this.classList.add('hover'); }); elem.addEventListener('mouseleave', function () { this.classList.remove('hover'); });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; result 만약 트랜지션이 자동 발동(self-invoking transition)하도록 하고 싶다면 CSS 애니메이션을 사용하도록 한다. transition의 프로퍼티는 아래와 같다. 프로퍼티 설명 기본값 transition-property 트랜지션의 대상이 되는 CSS 프로퍼티를 지정한다 all transition-duration 트랜지션이 일어나는 지속시간(duration)을 초 단위(s) 또는 밀리 초 단위(ms)로 지정한다 0s transition-timing-function 트랜지션 효과를 위한 수치 함수를 지정한다. ease transition-delay 프로퍼티가 변화한 시점과 트랜지션이 실제로 시작하는 사이에 대기하는 시간을 초 단위(s) 또는 초 단위 (ms)로 지정한다 0s transition 모두 트랜지션 프로퍼티를 한번에 지정한다(shorthand syntax) 1. transition-propertytransition-proterty 프로퍼티는 트랜지션의 대상이 되는 CSS 프로퍼티명을 지정한다. 지정하지 않는 경우 모든 프로퍼티가 트랜지션의 대상이 된다. 복수의 프로퍼티를 지정하는 경우 쉼표(,)로 구분한다. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 50px; background-color: red; margin-bottom: 10px; transition-property: width, background-color; transition-duration: 2s, 2s; } div:hover { width: 300px; background-color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 주의해야 할 사항은 모든 CSS 프로퍼티가 트랜지션의 대상이 될 수 없다는 것이다. 예를 들어 width, font-size, background-color 등은 하나의 범주(width, font-size는 크기, background-color는 색상)안에서 값이 변화하지만 display 프로퍼티는 그렇지 않다. 트랜지션의 대상이 될 수 있는 CSS 프로퍼티는 다음과 같다. 1234567891011121314// Box modelwidth height max-width max-height min-width min-heightpadding marginborder-color border-width border-spacing// Backgroundbackground-color background-position// 좌표top left right bottom// 텍스트color font-size font-weight letter-spacing line-heighttext-indent text-shadow vertical-align word-spacing// 기타opacity outline-color outline-offset outline-widthvisibility z-index 또한 요소의 프로퍼티 값이 변화하면 브라우저는 프로퍼티 값의 변화에 영향을 받는 모든 요소의 기하값(위치와 크기)를 계산하여 layout 작업을 수행한다. 이것은 브라우저에게 스트레스를 주어 성능 저하의 요인이 된다. 심지어 다수의 자식 요소를 가지고 있는 요소(ex/ body 요소)가 변겨오디면 모든 자식 요소의 기하값이 재계산 될 수도 있다. 따라서 layout에 영향을 주는 트랜지션 효과는 회피하도록 노력해야 한다. 123456width height padding margin borderdisplay position float overflowtop left right bottomfont-size font-family font-weighttext-align vertical-align line-heightclear white-space 2. transition-durationtransition-duration 프로퍼티는 트랜지션에 일어나는 지속시간(duration)을 초 단위(s) 또는 밀리 초 단위(ms)로 지정한다. 프로퍼티값을 지정하지 않을 경우 기본값 0s이 적용되어 어떠한 트랜지션 효과도 볼 수 없다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 100px; height: 50px; padding: 10px; color: white; background-color: red; margin-bottom: 10px; transition-property: width, opacity; } div:nth-child(1) { transition-duration: 0.5s; } div:nth-child(2) { transition-duration: 2s, 1s; } div:nth-child(3) { transition-duration: 5s, 2.5s; } div:hover { width: 300px; opacity: .1; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;0.5s&lt;/div&gt; &lt;div&gt;2s, 1s&lt;/div&gt; &lt;div&gt;5s, 2.5s&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result transition-duration 프로퍼티값은 transition-property 프로퍼티값과 1:1 대응한다. 아래의 경우, width 프로퍼티는 2초의 지속시간을 갖는다(2초 걸쳐 변화한다). 1234div { transition-property: width; transition-duration: 2s;} 아래의 경우, width 프러퍼티 2초, opacity 프로퍼티는 4초의 지속시간을 갖는다. 1234div { transition-property: width, opacity; transition-duration: 2s, 4s;} 또한 transition 프로퍼티만으로 축약 표현이 가능하다. 1234div { /* shorthand syntax */ transition: width 2s, opacity 4s;} 아래의 경우, width 프러퍼티 2초, opacity 프로퍼티는 1초, left 프로퍼티는 2초, top 프로퍼티는 1초의 제속시간을 갖는다. 1234div { transition-property: width, opacity, left, top; transition-duration: 2s, 1s;} 3. transition-timing-function트랜지션 효과의 변화 흐름, 시간에 따른 변화 속도와 같은 일종의 변화의 리듬을 지정한다. 대부분의 타이밍 함수는 큐빅 베이지어(cubic bezier)를 정의하는 네 점에 의해 정의되므로 상응하는 참수의 그래프로 제공해서 명시할 수 있다. transition-timing-function 프로퍼티값으로 미리 정해둔 5개의 키워드가 제공된다. 기본값은 ease이다. 프로퍼티값 효과 ease 기본값. 느리게 시작하여 점점 빨라졌다가 느려지면서 종료한다 linear 시작부터 종료까지 등속 운동을 한다 ease-in 느리게 시작한 후 일정한 속도에 다다르면 그 상태로 등속 운동한다 ease-out 일정한 속도의 등속으로 시작해서 점점 느려지면서 종료한다 ease-in-out ease와 비슷하게 느리게 시작하여 느려지면서 종료한다 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { font: bold 16px/50px &quot;Open Sans&quot;; color: white; text-align: center; width: 100px; height: 50px; background-color: red; margin-bottom: 10px; transition: width 2s; } div:nth-child(1) { transition-timing-function: ease; } div:nth-child(2) { transition-timing-function: linear; } div:nth-child(3) { transition-timing-function: ease-in; } div:nth-child(4) { transition-timing-function: ease-out; } div:nth-child(5) { transition-timing-function: ease-in-out; } div:hover { width: 300px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;transition-timing-function&lt;/h3&gt; &lt;div&gt;ease&lt;/div&gt; &lt;div&gt;linear&lt;/div&gt; &lt;div&gt;ease-in&lt;/div&gt; &lt;div&gt;ease-out&lt;/div&gt; &lt;div&gt;ease-in-out&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 4. transition-delay프로퍼티가 변화한 시점과 트랜지션이 실제로 시작하는 사이에 대기하는 시간을 초 단위(s) 또는 밀리 초 단위(ms)로 지정한다. 즉, transition-delay로 대기 시간을 지정하여 프로퍼티의 값이 변화하여도 즉시 트랜지션이 실행되지 않고, 일정 시간 대기한 후 트랜지션이 실행되도록 한다. 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { font: bold 16px/50px &quot;Open Sans&quot;; color: white; text-align: center; width: 100px; height: 50px; background-color: red; margin-bottom: 10px; transition: width 1s; } div:nth-of-type(1) { transition-delay: 0s; } div:nth-of-type(2) { transition-delay: 1s; } div:nth-of-type(3) { transition-delay: 3s; } div:hover { width: 300px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;transition-delay&lt;/h3&gt; &lt;div&gt;0s&lt;/div&gt; &lt;div&gt;1s&lt;/div&gt; &lt;div&gt;3s&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 5. transition모든 트랜지션 프로퍼티를 한번에 지정할 수 있는 shorthand이다. 값을 지정하지 않은 프로퍼티에는 기본값이 지정된다. 지정 방법은 다음과 같다. 1transition: property duration function delay shorthand syntax transition-duration은 반드시 지정해야 한다. 지정하지 않는 경우 기본값 0이 셋팅되어 어떠한 트랜지션도 실행되지 않는다. 기본값은 아래와 같다. 1all 0 ease 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { font: bold 0.5em/50px &quot;Open Sans&quot;; color: white; text-align: center; width: 100px; height: 50px; margin-bottom: 10px; background-color: red; } div:nth-of-type(1) { /* property duration function delay */ transition: width 1s ease-in 1s; } div:nth-of-type(2) { /* duration */ transition: 1s } div:nth-of-type(3) { /* property duration */ transition: width 1s } div:nth-of-type(4) { /* duration function */ transition: 1s ease-in; } div:nth-of-type(5) { /* duration delay*/ transition: 1s 1s; } div:hover { width: 300px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;width 1s ease-in 1s&lt;/div&gt; &lt;div&gt;1s&lt;/div&gt; &lt;div&gt;width 1s&lt;/div&gt; &lt;div&gt;1s ease-in&lt;/div&gt; &lt;div&gt;1s 1s&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result Referencepoiemaweb.com/css3-transition css3generator.com","link":"/2021/05/24/css3-day-14/"},{"title":"css3-day-8","text":"2.8 CSS3 Position요소의 위치 정의 1. postion 프로퍼티position 프로퍼티는 요소의 위치를 정의한다. top, bottom, left, right 프로퍼티와 함께 사용하여 위치를 지정한다. 1.1 static (기본 위치)static은 position 프로퍼티의 기본값으로 position 프로퍼티를 지정하지 않았을 때와 같다. 기본적인 요소의 배치 순서에 따라 위에서 아래로, 왼쪽ㅇ에서 오른족으로 순서에 따라 배치되며 부요 요소 내에 자식 요소로서 존재할 때는 부모 요소의 위치를 기준으로 배치된다. 기본적으로 이 값을 지정할 일은 없지만 이미 설정된 position을 무력화하기 위해 사용될 수 있다. 좌표 프로퍼티(top, bottom, left, right)를 같이 사용할 수 없으며 사용할 경우에는 무시 된다. 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0; } .parent { width: 150px; height: 150px; background: #bcbcbc; border: 1px solid #bcbcbc; } .static-box { position: static; background: #2E303D; color: #e55c3c; font-weight: bold; text-align: center; line-height: 150px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;static-box&quot;&gt;static box&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 1.2 relative(상대위치)기본 위치(static으로 지정되었을 때의 위치)를 기준으로 좌표 프로퍼티(top, bottom, left, right)를 사용하여 위치를 이동시킨다. static을 선언한 요소와 relative를 선언한 요소의 차이점은 좌표 프로퍼티의 동작 여부뿐이며 그외는 동일하게 동작한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0; } .parent { width: 150px; height: 150px; background: #bcbcbc; border: 1px solid #bcbcbc; margin: 50px; } .relative-box { position: relative; top: 50px; left: 50px; background: #2E303D; color: #e55c3c; font-weight: bold; text-align: center; line-height: 150px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;relative-box&quot;&gt;relative box&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 위 예제를 보면 parent 클래스의 자식인 relative-box 클래스 요소의 width, height가 부모 요소와 동일하다. 이는 상속에 의한 것이 아니라(width, height는 상속되지 않는다.) relative를 적용한 요소는 좌표 프로퍼티가 적용되는 것만 다를 뿐 그 이외는 static을 지정했을 때와 동일하게 동작하기 때문이다. 즉, width는 100%가 적용되어 부모 요소의 width와 동일한 값을 갖게 된 것이고, height는 auto가 적용되지만 line-height: 150px이 적용되어 부모 요소와 hight가 동일하게 된 것이다. 1.3 absolute (절대위치)부모 요소 또는 가장 가까이 있는 조상 요소(static 제외)를 기준으로 좌표 프로퍼티(top, bottom, left, right)만큼 이동한다. 즉, relative, absolute, fixed 프로퍼티가 선언되어 있는 부모 또는 조상 요소를 기준으로 위치가 결정된다. 만일 부모 또는 조상 요소가 static인 경우, dovument body를 기준으로 하여 좌표 프로퍼티대로 위치하게 된다. 따라서 부모 요소를 배치의 기준으로 삼기 위해서는 부모 요소에 relative를 정의하여야 한다. 이때 다른 요소가 먼저 위치를 점유하고 있어도 뒤로 밀리지 않고 덮어쓰게 된다. (이런 특성을 부유 또는 부유 객체라 한다.) absolute 선언 시, block 레벨 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정하여야 한다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0; } .parent { width: 200px; height: 200px; background: #bcbcbc; border: 1px solid #bcbcbc; margin: 50px 0 0 300px; position: relative; } .absolute-box { position: absolute; height: 200px; width: 200px; top: 50px; left: 50px; color: #e55c3c; font-weight: bold; text-align: center; background: #2E303D; line-height: 200px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;absolute-box&quot;&gt;absolute box (in parent)&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;absolute-box&quot;&gt;absolute box (no parent)&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result relative 프로퍼티와 absolute 프로퍼티의 차이점은 아래와 같다. relative 프로퍼티는 기본 위치(static으로 지정되었을 때의 위치)를 기준으로 좌표 프로퍼티(top, bottom, left, right)을 사용하여 위치를 이동시킨다. 따라서 무조건 부모를 기준으로 위치하게 된다. absolute 프로퍼티는 부모에 static 이외의 position 프로퍼티가 지정되어 있을 경우에만 부모를 기준으로 위치하게 된다. 만일 부모, 조상이 모두 static 프로퍼티인 경우, document body를 기준으로 위치하게 된다. 따라서 absolute 프로퍼티 요소는 부모 요소의 영역을 벗어나 자유롭게 어디든지 위치할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0;} .parent { width: 150px; height: 150px; background: #bcbcbc; border: 1px solid #bcbcbc; margin: 50px; float: left; /*position: relative;*/ } .relative-box { position: relative; top: 10px; left: 10px; width: 150px; height: 150px; background: #2E303D; color: #e55c3c; font-weight: bold; text-align: center; line-height: 150px; } .absolute-box { position: absolute; top: 10px; left: 10px; width: 150px; height: 150px; background: #2E303D; color: #e55c3c; font-weight: bold; text-align: center; line-height: 150px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;absolute-box&quot;&gt;absolute box&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;relative-box&quot;&gt;relative box&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 1.4 fixed (고정위치)부모 요소와 관계없이 브라우저의 viewport를 기준으로 좌표프로퍼티(top, bottom, left, right)을 사용하여 위치를 이동시킨다. 스크롤이 되더라도 화면에서 사라지지 않고 항상 같은곳에 위치한다. fixd 프로퍼티 선언 시, block 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정하여야 한다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0; } .fixed-box { position: fixed; color: #e55c3c; font-weight: bold; text-align: center; background: #2E303D; } .sidebar { width: 50px; height: 100%; top: 0; right: 0; padding-top: 100px; } .footer { width: 200px; width: 100%; height: 50px; bottom: 0; left: 0; line-height: 50px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;fixed-box sidebar&quot;&gt;fixed box (side-bar)&lt;/div&gt; &lt;div class=&quot;fixed-box footer&quot;&gt;fixed box (footer)&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 2. z-index 프로퍼티z-index 프로퍼티에 큰 숫자값을 지정할수록 화면 전면에 출력된다. position 프로퍼티가 static 이외인 요소에만 적용된다. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .normal-box { width: 100px; height: 100px; } .absolute-box { width: 100px; height: 100px; position: absolute; } /* z-index는 positon 프로퍼티가 static 이외인 요소에만 적용된다. */ .orange { background-color: orange; z-index: 1000; } .red { background-color: red; left: 50px; top: 50px; z-index: 100; } .green { background-color: green; left: 100px; top: 100px; z-index: 10; } .blue { background-color: blue; left: 150px; top: 150px; z-index: 1; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;normal-box orange&quot;&gt;&lt;/div&gt; &lt;div class=&quot;absolute-box red&quot;&gt;&lt;/div&gt; &lt;div class=&quot;absolute-box green&quot;&gt;&lt;/div&gt; &lt;div class=&quot;absolute-box blue&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 3. overflow 프로퍼티overflow 프로퍼티는 자식 요소가 부모 요소의 영역을 벗어났을 때 처리 방법을 정의한다. 프로퍼티값 Description visible 영역을 벗어난 부분을 표시한다.(기본값) hidden 영역을 벗어난 부분을 잘라내어 보이지 않게 한다. scroll 영역을 벗어난 부분이 없어도 스크롤 표시한다.(현재 대부분 브라우저는 auto과 동일하게 작동한다.) auto 영역을 벗어난 부분이 있을때만 스크롤 표시한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { width: 150px; height: 150px; padding: 10px; margin: 30px; font-size: 1.2em; border-radius: 6px; border-color: gray; border-style: dotted; float: left; } .visible { overflow: visible; } .hidden { overflow: hidden; } .scroll { overflow: scroll; } .auto { overflow: auto; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;overflow&lt;/h1&gt; &lt;div class=&quot;visible&quot;&gt;&lt;h3&gt;visible&lt;/h3&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/div&gt; &lt;div class=&quot;hidden&quot;&gt;&lt;h3&gt;hidden&lt;/h3&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/div&gt; &lt;div class=&quot;scroll&quot;&gt;&lt;h3&gt;scroll&lt;/h3&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/div&gt; &lt;div class=&quot;auto&quot;&gt;&lt;h3&gt;auto&lt;/h3&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 특정방향으로만 스크롤을 표시하고자 할 때는 overflow-x 또는 overflow-y 프로퍼티를 사용한다. 1div {overflow-y: auto;} Referencepoiemaweb.com/css3-position W3C CSS Document","link":"/2021/05/06/css3-day-8/"},{"title":"css3-day-9","text":"CSS3 Float요소 정렬float 프로퍼티는 주로 레이아웃을 구성할 때 블록 레벨 요소를 가로 정렬하기 위해 사용되는 중요한 기법이다. flexbox 레이아웃를 사용한다면 더욱 간단하게 정렬을 구현할 수도 있지만 flexbox 레이아웃을 지원하지 않는 IE를 고려해야 한다면 float 프로퍼티를 사용해야 한다. float 프로퍼티는 본래 아래 예제와 같이 이미지와 텍스트가 있을 때, 이미지 주위를 텍스트로 감싸기 위해 만들어진 것이다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; img { float: left; margin-right: 10px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;img/cat.png&quot;&gt; &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result float 프로퍼티는 해당 요소를 다음 요소 위에 떠 있게(부유하게)한다. 여기서 떠 있다(float)는 의미는 요소가 기본 레이아웃 흐름에서 벗어나 요소의 모서리가 페이지의 왼쪽이나 오른쪽에 이동하는 것이다. float 프로퍼티를 사용할 때 요소의 위치를 고정시키는 position 프로퍼티의 absolute를 사용하면 안된다. 프로퍼티값 Description none 요소를 떠 있게 하지 않는다(기본값) right 요소를 오른쪽으로 이동시킨다 left 요소를 왼쪽으로 이동시킨다 1. 정렬float 프로퍼티를 사용하지 않은 블록 요소들은 수직으로 정렬된다. float: left; 프로퍼티를 사용하면 왼쪽부터 가로 정렬되고, float:right; 프러퍼티를 사용하면 오른쪽부터 가로 정렬 된다. 오른쪽 가로 정렬의 경우, 먼저 기술된 요소가 가장 오른쪽에 출력되므로 출력 순서가 역순이 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box { color: white; font-weight: bold; font-size: 50px; border-radius: 6px; width: 100px; height: 100px; margin: 10px; padding: 10px; } .d1, .d2 { float: left; } .d1 { background: red; } .d2 { background: orange; } .d3, .d4 { float: right; } .d3 { background: red; } .d4 { background: orange; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box d1&quot;&gt; 1 &lt;/div&gt; &lt;div class=&quot;box d2&quot;&gt; 2 &lt;/div&gt; &lt;div class=&quot;box d3&quot;&gt; 3 &lt;/div&gt; &lt;div class=&quot;box d4&quot;&gt; 4 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result float 프로퍼티는 좌측, 우측 가로 정렬만 할 수 있다. 중앙 가로 정렬은 margin 프로퍼티를 사용해야 한다. 1234div { width: 960px; margin: 0 auto;} 2. widthwidth 프로퍼티의 기본값은 100%이므로 width 프러퍼티값을 지정하지 않은 block 요소는 부모 요소의 가로폭을 가득 채운다. 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box { color: white; font-weight: bold; font-size: 30px; line-height: 50px; height: 50px; margin: 0 10px; padding: 10px; } .d1 { background: red; } .d2 { background: orange; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box d1&quot;&gt; div &lt;/div&gt; &lt;div class=&quot;box d2&quot;&gt; div &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result width 프로퍼티를 선언하지 않은 block 레벨 요소에 float 프로퍼티가 선언되면 width가 inline요소와 같이 content에 맞게 최소화되고 요소 위에 떠 있게(부유하게)된다. 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box { color: white; font-weight: bold; font-size: 30px; line-height: 50px; height: 50px; margin: 0 10px; padding: 10px; } .d1 { float: left; background: red; } .d2 { background: orange; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box d1&quot;&gt; float: left; &lt;/div&gt; &lt;div class=&quot;box d2&quot;&gt; div &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 위 예제를 살펴보면 d1 클래스 요소에는 flao: left; 를 선언하였고 d2 클래스 요소에는 float를 선언하지 않았다. 이때 d1 클래스 요소는 width가 inline 요소와 같이 content에 맞게 최소화되고 다음 요소인 d2 클래스 요소 위에 떠 있게(부유하게) 된다. 주의할 것은 d1 클래스 요소가 위에 떠 있게 되어도 d2 클래스 요소의 width는 d1 클래스 요소가 차이한 width 만큼 줄어들지 않고 100%를 유지한다는 것이다. 이는 d2 클래스 요소는 float를 선언하지 않았기 때문에 본래의 width를 유지하기 때문이다. 따라서 d2 클래스 요소는 분래의 width(100%)를 유지한 상태에서 d1 클래스 요소가 그 위에 위치한다. 3.1 float 프로퍼티가 선언된 요소와 float 프로퍼티가 선언되지 않은 요소간 margin이 사라지는 문제위 예제를 보면 두 요소는 차례대로 정렬된 것처럼 보이지만 사실은 float 프로퍼티가 선언된 요소가 다음 요소 위에 떠 있는(부유하고 있는) 상태이다. 따라서 두 요소간의 margin은 제대로 표현되지 않는다. 이것은 두번째 요소에 float 프로퍼티를 선언하지 않았기 때문에 발생하는 박스 모델 상의 문제이다. 이 문제를 해결하는 가장 쉬운 방법은 float 프로퍼티를 선언하지 않은 요소(.d2)에 overflow: hidden 프로퍼티를 선언하는 것이다. overflow: hidden 프로퍼티는 자식 요소가 부모 요소의 영역보다 클 경우 넘치는 부분을 안보이게 해주는 역할을 하는데 여기서는 float 프로퍼티가 없어서 제대로 표현되지 못하는 요소를 제대로 출력해준다. 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .box { color: white; font-weight: bold; font-size: 30px; line-height: 50px; height: 50px; margin: 0 10px; padding: 10px; } .d1 { float: left; background: red; } .d2 { overflow: hidden; background: orange; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box d1&quot;&gt; float: left; &lt;/div&gt; &lt;div class=&quot;box d2&quot;&gt; div &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 두번째 요소에도 float 프로퍼티를 선언하면 overflow: hidden 프로퍼티는 선언하지 않아도 되지만 너비가 최소화 된다. 3.2 float 프로퍼티가 선언된 자식 요소를 포함하는 부모 요소의 높이가 정상적으로 반영되지 않는 문제아래 예제를 보면 float 프로퍼티가 선언된 두개의 자식 요소를 포함하는 부모 요소의 높이가 정상적인 값을 가지지 못하는 문제가 발생한다. float 요소는 일반적인 흐름 상에 존재하지 않기 때문에 float 요소의 높이를 알 수 없기 때문인데 이 문제는 부모 요소 이후에 위치하는 요소의 정렬에 문제를 발생시킨다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .container { color: white; text-align: center; padding: 10px; background-color: #def0c2; } .d1, .d2 { float: left; width: 50%; padding: 20px 0; } .d1 { background-color: #59b1f6; } .d2 { background-color: #ffb5b4; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;background:red;padding:10px;color:white;&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 이 문제를 해결하는 가장 쉬운 방법은 float 프로퍼티가 선언된 자식 요소의 부모요소(.container)에 overflow: hidden 프로퍼티를 선언하는 것이다. 1234.container { ... overflow: hidden;} 다른 방법으로 부모 요소(.container)에 float 프로퍼티를 선언하는 방법도 있다. 하지만 부모 요소의 너비 float된 두개의 자식요소의 콘텐츠를 표현할 수 있는 만큼만으로 작게 줄어들게 된다. 권장할 수 있는 방법은 아니다. container 영역이 끝나기 직전 빈 요소를 만들고 clear:both 를 설정하는 방법도 가능하다. 하지만 의미 없는 빈 요소를 사용하여야 하기 때문에 이방법 역시 권장할 수 있는 방법은 아니다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .container { color: white; text-align: center; padding: 10px; background-color: #def0c2; /*overflow: hidden;*/ } .d1, .d2 { float: left; width: 50%; padding: 20px 0; } .d1 { background-color: #59b1f6; } .d2 { background-color: #ffb5b4; } .clear { height: 0; clear: both; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;background:red; padding:10px; color:white;&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result overflow: hidden; 과 함께 많이 사용되는 방법은 ::after 가상 요소 선택자를 이용하는 것이다. 가상 요소 선택자는 CSS2 문법(:after)과 CSS3 문법(::after)이 있는데 IE8까지 지원하는 CSS2 문법을 사용하는 편이 좋다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .container { color: white; text-align: center; padding: 10px; background-color: #def0c2; /*overflow: hidden;*/ } .clearfix:after { content: &quot;&quot;; display: block; clear: both; } .d1, .d2 { float: left; width: 50%; padding: 20px 0; } .d1 { background-color: #59b1f6; } .d2 { background-color: #ffb5b4; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;background:red;padding:10px;color:white;&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 부모 요소에 위 예제와 같이 사전에 작성한 clearfix 클래스만 추가하거나, 해당 요소를 선택하여 클리어 문법을 선언하면 되기 때문에 가장 깔끔하고 간편하다. 이 방법을 사용하는 것을 추천한다. 12345678910111213.clearfix:after { content: &quot;&quot;; display: block; clear: both;}/* or */selector:after { content: &quot;&quot;; display: block; clear: both;} 또 다른 방법은 float 프로퍼티 대신 display: inline-block; 을 선언하는 것이다. 중의해야 하는 점은 inline-block 프로퍼티 요소를 연속 사용하는 경우, 두 요소 사이에 정의하지 않은 공백(4px)가 자동 지정되는 것이다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .container { color: white; text-align: center; padding: 10px; background-color: #def0c2; } .d1, .d2 { display: inline-block; width: 50%; padding: 20px 0; } .d1 { background-color: #59b1f6; } .d2 { background-color: #ffb5b4; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;background:red;padding:10px;color:white;&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 위 예제를 보면 .d1, .d2 요소에 display: inline-block; 을 선언하여 텍스트와 같이 배치되도록 하였지만 두 요소 사이에 정의하지 않은 공백(4px)이 자동 지정되어 부모 요소의 width를 초과하여 가로 정렬이 되지 않았다. 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .container { color: white; text-align: center; padding: 10px; background-color: #def0c2; /* 폰트 사이즈를 0으로 지정하여 두 요소 사이에 정의하지 않은 공백을 제거 */ font-size: 0; } .d1, .d2 { display: inline-block; width: 50%; padding: 20px 0; /* 폰트 사이즈를 재지정 */ font-size: 1rem; } .d1 { background-color: #59b1f6; } .d2 { background-color: #ffb5b4; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;background:red;padding:10px;color:white;&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result Referencepoiemaweb.com/css3-float W3C CSS Document","link":"/2021/05/12/css3-day-9/"},{"title":"js-day3-datatype-variable","text":"Data type &amp; Variable데이터 타입과 변수프로그래밍은 변수를 통해 값을 저장하고 참조하며 연산자로 값을 연산, 평가하고 조건문과 반복문에 의한 흐름제어로 데이터의 흐름을 제어하고 함수로 재사용이 가능한 구문의 집합을 만들며 객체, 배열 등으로 자료를 구조화하는 것이다. 변수는 값의 위치(주소)를 기억하는 저장소이다. 값의 위치란 값이 위치하고 있는 메모리 상의 주소(address)를 의미한다. 즉, 변수란 값이 위치하고 있는 메모리 주소(Memory address)에 접근하기 위해 사람이 이해할 수 있는 언어로 명명한 식별자(identifier)이다. 메모리에 값을 저장하기 위해서는 먼저 메모리 공간을 확보해야 할 메모리의 크기(byte)를 알아야한다. 이는 값의 종류에 따라 확보해야 할 메모리의 크기가 다르기 때문이다. 이때 값의 종류, 즉 데이터의 종류를 데이터 타입(Data Type)이라 한다. 예를 들어 1byte(8bit)로 표현할 수 있는 경우의 수, 즉 값의 총 개수는 256개(2^8)로 아스키코드(ASCII)를 표현할 수 있으며, 4byte(32bit)로 표현할 수 있는 값의 총수는 4,294,967,296개(2^32)로 -2,147,483,648 ~ 2,147,483,647의 정수를 표현할 수 있다. C나 Java 같은 C-family 언어는 정적 타입(Static/Strong Type)언어로 변수 선언 시 변수에 저장할 값의 종류를 사전에 타입 지정(Type annotation)하여야 한다. 다음은 C에서 정수형 변수를 선언하는 예이다. 12345// 1byte 정수형: -128 ~ 127char c;// 4byte 정수형: -2,124,483,648 ~ 2,124,483,647int num; C 언어의 경우, 4byte 정수형인 int형 선언을 만나면 시스템은 이후 할당될 값과는 상관없이 4byte의 메모리 영역을 확보한다. 이후 int형 변수에 할당할 때에는 int형 값을 할당해야한다. 다음은 C에서 정수형 변수에 문자열을 잘못 할당한 예이다. 12345678int main(void) { int num = 46; char * str = &quot;String&quot;; num = &quot;String&quot;; // warning: incompatible pointer to integer conversion assigning to 'int' from 'char [7]' return 0;} 자바스크립트는 동적타입(Dynamic/Weak Type)언어이다. 변수의 타입 지정(Type annotation)없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정(타입추론, Type Inference)된다. 즉, 변수는 고정된 타입이 없다. 따라서 같은 변수에 여러 타입의 값을 자유롭게 할당할 수 있다. 12345678var str = 'Hello';var num = 1;var bool = true;var foo = 'string';console.log(typeof foo); // stringfoo = 1;console.log(typeof foo); // number 자바스크립트에는 어떠한 데이터 타입이 있는지 그리고 변수는 어떻게 사용하는지 알아보도록 하자. 1. 데이터 타입데이터 타입(Data Type)은 프로그래밍 언어에서 사용할 수 있는 데이터(숫자, 문자열, 불리언 등)의 종류를 말한다. 코드에서 사용되는 모든 데이터는 메모리에 저장하고 참조할 수 있어야 한다. 데이터 타입은 데이터를 메모리에 저장할 떄 확보해야 하는 메모리 공간의 크기와 할당할 수 있는 유효한 값에 대한 저옵, 그리고 메모리에 저장되어 있는 2진수 데이터를 어떻게 해석할지에 대한 정보를 컴퓨터와 개발자에게 제공한다. 데이터 다입은 한정된 메모리 공간을 효율적으로 사용하기 위해서, 그리고 2진수 데이터로 메모리에 저장된 데이터를 다양한 형태로 사용하기 위해 존재한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. ECMAScript 표준(ECMAScript 2015(6th Edition), 이하 ES6)은 7개의 데이터 타입을 제공한다. 원시 타입(primitive data type) boolean null undefined number string symbol (ES6에서 추가) 객체 타입(object) 예를 들어 숫자(number)타입 1과 문자열(string) 타입 ‘1’은 비슷하게 보이지만 다른 타입의 값이다. 숫자 타입의 값은 주로 산술 연산을 위해 만들지만 문자열 타입의 값은 주로 텍스트로 출력하기 위해 만든다. 이처럼 개발자는 명확한 의도를 가지고 타입을 구별하여 값을 만들 것이고 자바스크립트 엔진은 타입을 구별하여 값을 취급할 것이다. 자바스크립트에서 제공하는 7개의 데이터 타입은 크게 원시 타입(primitive data type)과 객체 타입(object/reference type)으로 구분할 수 있다. 1.1 원시타입 (Primitive Data Type)원시 타입의 값은 변경 불가능한 값(immutable value)이며 pass-by-value(값에 의한 전달)이다. 1.1.1 numberC나 Java의 경우, 정수와 실수를 구분하여 int, long, float, double 등과 같은 다양한 숫자 타입이 존재한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다. ECMAScript 표준에 따르면, 숫자 타입의 값은 배정밀도 64비트 부동소수점 형(double-precision 64-bit floating-point format : -(2^53-1)와 2^53-1 사이의 숫자값)을 따른다. 즉, 모든 수를 실수를 처리하며 정수만을 표현하기 위한 특별한 데이터 타입(integer type)은 없다. 123456var integer = 10; // 정수var double = 10.12; // 실수var negative = -20; // 음의 정수var binary = 0b01000001; // 2진수var octal = 0o101; // 8진수var hex = 0x41; // 16진수 2진수, 8진수, 16진수 리터럴은 메모리에 동일한 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다. 1234567console.log(binary); // 65console.log(octal); // 65console.log(hex); // 65// 표기법만 다를뿐 같은 값이다.console.log(binary === octal); // trueconsole.log(octal === hex); // true 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수를 처리한다. 정수로 표시된다해도 사실은 실수다. 따라서 정수로 표시되는 수 끼리 나누더라도 실수가 나올 수 있다. 123456console.log(1 === 1.0); // truevar result = 4 / 2;console.log(result); // 2result = 3 /2;console.log(result); // 1.5 추가적으로 3가지 특별한 값들도 표현할 수 있다. Infinity: 양의 무한대 -Infinity: 음의 무한대 NaN: 산술 연산 불가(not-a-number) 12345678var pInf = 10 / 0; // 양의 무한대console.log(pInf); // Infinityvar nInf = 10 / -0; // 음의 무한대console.log(nInf); // -Infinityvar nan = 1 * 'string'; // 산술 연산 불가console.log(nan); // NaN 수학적 의미의 실수(real number)는 허수(imaginary number)가 아닌 유리수와 무리수를 통틀은 말이지만 프로그래밍 언어에서 실수는 일반적으로 소수를 가리킨다. 1.1.2 string문자열(String) 타입은 텍스트 데이터를 나타내는데 사용한다. 문자열은 0개 이상의 유니코드 문자(UTF-16)들의 집합으로 대부분의 전세계의 문자를 표현 할 수 있다. 문자열은 작은 따옴표(‘’) 또는 큰 따옴표(“”)안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다. 123456var str = &quot;string&quot;; // 큰 따옴표str = 'string'; // 작은 따옴표str = `string`; // 백틱(ES6 템플릿 리터럴)str = &quot;큰 따옴표로 감싼 문자열 내의 '작은 따옴표'는 문자열이다.&quot;;str = '작은 따옴표로 감싼 문자열 내의 &quot;큰 따옴표&quot;는 문자열이다.'; C와 같은 언어와는 다르게, 자바스크립트의 문자열은 원시 타입이며 변경 불가능(immutable)하다. 이것은 한 번 문자열이 생성되면, 그 문자열을 변경할 수 없다는 것을 의미한다. 아래의 코드를 살펴보자. 12var str = 'Hello';str = 'world'; 첫번째 구문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 메모리에 생성된 문자열’Hello’의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 변수 str은 문자열 ‘world’를 가리키도록 변경되었을 뿐이다. 123456789var str = 'string';// 문자열은 유사배열이다.for (var i = 0; i &lt; str.length; i++) { console.log(str[i]);}// 문자열을 변경할 수 없다.str[0] = 'S';console.log(str); // string 문자열은 배열처럼 인덱스를 통해 접근할 수 있다. 이와 같은 특성을 갖는 데이터를 유사배열이라 한다. str[0] = ‘S’처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다(이때 에러가 발생하지 않는다). 한번 생성된 문자열은 read only로서 변경할 수 없다. 이것을 변경 불가능(immutable)이라 한다. 그러나 새로운 문자열을 재할당하는 것은 물론 가능하다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문이다. 1234567891011121314var str = 'string';console.log(str); // stringstr = 'String';console.log(str); // Stringstr += ' test';console.log(str); // String teststr = str.substring(0, 3);console.log(str); // Strstr = str.toUpperCase();console.log(str); // STR 1.1.3 boolean불리언(boolean)타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다. 123456var foo = true;var bar = false;// typeof 연산자는 타입을 나타내는 문자열을 반환한다.console.log(typeof foo); // booleanconsole.log(typeof bar); // boolean 불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용한다. 비어있는 문자열과 null, undefined, 숫자 0은 false로 간주된다. 이에 대해서는 타입 변환에서 살펴볼 것이다. 1.1.4 undefinedundefined 타입의 값은 undefined가 유일하다. 선언 이후 값을 할당하지 않은 변수는 undefined 값을 가진다. 즉, 선언은 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 undefined가 반환된다. 이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값(Garbage value)이 들어 있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문이다. 12var foo;console.log(foo); // undefined 이처럼 undefined는 개발자가 의도적으로 할당한 값이 아니라 자바스크립트 엔진에 의해 초기화된 값이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는 변수라는 것을 개발자는 간파할 수 있다. 그렇다면 개발자가 의도적으로 undefined를 할당해야하는 경우가 있을까? 자바스크립트 엔진이 변수 초기화에 사용하는 이 값을 만약 개발자가 마음대로 할당한다면 undefined의 본래의 취지와 어긋날 뿐더러 혼란을 줄수 있으므로 권장하지 않는다. 그럼 변수의 값이 없다는 것을 명시하고 싶은 경우 어떻게 하면 좋을까? 그런 경우는 undefined를 할당하는 것이 아니라 null을 할당한다. 1.1.5 nullnull 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 NULL, Null등과 다르다. 프로그래밍 언어에서 null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 이는 변수가 기억하는 메모리 어드레스의 참조 정보를 제거하는 것을 의미하며 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 가비지 콜렉션을 수행할 것이다. 12var foo = 'Lee';foo = null; // 참조 정보가 제거됨 또는 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우, 명시적으로 null을 반환하기도 한다. 예를 들어, 조건에 부합하는 HTML 요소를 검색해 반환하는 Documnet.querySelector()는 조건에 부합하는 HTML 요소를 검색할 수 없는 겨우, null을 반환한다. 123var element = document.querySelector('.myElem');// HTML 문서에 myElem 클래스를 갖는 요소가 없다면 null을 반환한다.console.log(element); // null 타입을 나타내는 문자열을 반환하는 typeof 연산자로 null 값을 연산해 보면 null이 아닌 object가 나온다. 이는 자바스크립트의 설계상의 오류이다. 12var foo = null;console.log(typeof foo); // object 따라서 null 타입을 확인할 때 typeof 연산자를 사용하면 안되고 일치 연산자(===)를 사용하여야 한다. 123var foo = null;console.log(typeof foo === null); // falseconsole.log(foo === null); // true 1.1.6 symbol심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다. 심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다. 1234567// 심볼 key는 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키var key = Symbol('key');console.log(typeof key); // symbolvar obj = {};obj[key] = 'value';console.log(obj[key]); // value 1.2 객체 타입(Object type, Reference type)객체는 데이터와 그 데이터에 관련한 동작(절차, 방법, 기능)을 모두 포함할 수 있는 개념적 존재이다. 달리말해, 이름과 값을 가지는 데이터를 의미하는 프로퍼티(property)와 동작을 의미하는 메소드(method)를 포함할 수 있는 독립적 주체이다. 자바스크립트는 개체(object) 기반의 스크립트 언어로서 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입(Primitives)을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체이다. 또한 객체는 pass-by-regerence(참조에 의한 전달)방식으로 전달 된다. 2. 변수변수(Variable)는 프로그램에서 사용되는 데이터를 일정 기간 동안 기억하여 필요한 때에 다시 사용하기 위해 데이터에 고유의 이름인 식별자(identifier)를 명시한 것이다. 변수에 명시한 고유한 식별자를 변수명이라 하고 변수로 참조할 수 있는 데이터를 변수값이라 한다. 식별자는 어떤 대상을 유일하게 식별할 수 있는 이름을 말한다. 식별자에는 변수명, 함수명, 프로퍼티명, 클래스명 등이 있다. 변수 var, let, const 키워드를 사용하여 선언하고 할당 연산자를 사용해 값을 할당한다. 그리고 식별자인 변수명을 사용해 변수에 저장된 값을 참조한다. 1234567var score; // 변수의 선언score = 80; // 값의 할당score = 90; // 값의 재할당score; // 변수의 참조// 변수의 선언과 할당var average = (50 + 100) / 2; 2.1 변수의 선언예를 들어 반지름의 길이가 2인 원의 넓이를 구해보자. 이때 원주율은 3.141592653589793라고 하자. 13.141592653589793 * 2 * 2; // 12.566370614359172 원의 넓이를 구하였으나 그 결과를 기억할 수 없다. 만약에 원의 넓이를 다시 사용해야 한다면 다시 구해야 한다. 변수를 사용하여 원의 넓이를 기억(캐싱)하고 기억된 원의 넓이를 재사용하여 높이가 5인 원기둥의 부피를 구해보자. 12var circleArea = 3.141592653589793 * 2 * 2;var cylinderVolume = circleArea * 5; 원주율 3.141592653589793은 재사용할 가능성이 크므로 변수에 저장하도록 하자. 원주율은 변하지 않는 상수이지만 자바스크립트는 상수를 별도 지원하지 않으므로 변수 이름을 대문자로 하여 상수임을 암시하도록 하자. 그리고 반지름과 원기둥의 높이도 값의 의미를 명확히하고 변화에 대처하기 쉽도록 변수에 저장하도록 하자. 원주율은 자바스크립트 빌트인 상수인 Math.PI을 통해 참조할 수 있다. 상수는 ES6의 const 키워드를 사용해 표현할 수 있다.이것에 대해서는 나중에 자세히 살펴볼 것이다. 12345var PI = 3.141592653589793; // 상수var radius = 2; // 변수var circleArea = PI * radius * radius;var cylinderHeight = 5;var cylinderVolume = circleArea * cylinderHeight; 이처럼 변수는 애플리케이션에서 한번 쓰고 버리는 값이 아닌 일정기간 유지할 필요가 있는 값에 사용한다. 또한 변수를 사용하면 값의 믜미가 명확해져서 코드의 가독성이 좋아진다. 변수의 존재 목적을 쉽게 이해할 수 있도록 의미있는 변수명을 지정하여야 한다. 12var x = 3; // NGvar score = 100; // OK 변수명은 식별자(identifier)로 불리기도 하며 명명 규칙이 존재한다. 반드시 영문자(특수문자 제외), underscore(_), 또는 달러 기호($)로 시작하여야 한다. 이어지는 문자에는 숫자(0~9)도 사용할 수 있다. 자바스크립트는 대/소문자를 구별하므로 사용할 수 있는 문자는 AZ (대문자)와 az (소문자)이다. 변수를 선언할 때는 var 키워드를 사용한다. 등호(=, equal sign)는 변수에 값을 할당하는 할당 연산자이다. 123456789101112var name; // 선언name = 'Lee'; // 할당var age = 30; // 선언과 할당var person = 'Lee', address = 'Seoul', price = 200;var price = 10;var tax = 1;var total = price + tax; 값을 할당하지 않은 변수 즉 선언만 되어 있는 변수는 undefined로 초기값을 갖는다. 선언하지 않은 변수에 접근하면 ReferenceError가 발생한다. 123var x;console.log(x); // undefinedconsole.log(y); // ReferenceError 2.1 변수의 중복 선언var 키워드로 선언한 변수는 중복 선언이 가능하다. 다시 말해 변수명이 같은 변수를 중복해 선언해도 에러가 발생하지 않는다. 123456var x = 1;console.log(x); // 1// 변수의 중복 선언var x = 100;console.log(x); // 100 위 예제의 변수 x는 중복 선언되었다. 이처럼 변수를 중복 선언하면 에러없이 이전 변수의 값을 덮어쓴다. 만약 동일한 변수명이 선언되어 있는 것을 모르고 변수를 중복 선언했다면 의도치 않게 변수의 값을 변경하는 부작용을 발생시킨다. 따라서 변수의 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다. 2.2 동적 타이핑 (Dynamic Typing)자바스크립트는 동적 타입(dynamin/ weak type)언어이다. 이것은 변수의 지정(Type annotation)없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결정(Type Inference)될 것이라는 뜻이다. 따라서 같은 변수에 여러 타입의 값을 할당할 수 있다. 이를 동적 타이핑(Dynamic Typing)이라 한다. 123456789101112131415161718192021var foo;console.log(typeof foo); // undefinedfoo = null;console.log(typeof foo); // objectfoo = {};console.log(typeof foo); // objectfoo = 3;console.log(typeof foo); // numberfoo = 3.14;console.log(typeof foo); // numberfoo = 'Hi';console.log(typeof foo); // stringfoo = true;console.log(typeof foo); // boolean 2.3 변수 호이스팅(Variable Hoisting)1234567console.log(foo); // ① undefinedvar foo = 123;console.log(foo); // ② 123{ var foo = 456;}console.log(foo); // ③ 456 var 키워드를 사용하여 선언한 변수는 중복 선언이 가능하기 때문에 위의 코드는 문법적으로 문제가 없다. 1 에서 변수 foo는 아직 선언되지 않았으므로 RegerenceError: foo is not defined가 발생하는 것을 기대했겠지만 콘솔에는 undefiend가 출력된다. 이것은 다른 C-family 언어와는 차별되는 자바스크립트의 특징으로 모든 선언문은 호이스팅(Hoisting)되기 때문이다. 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문 (var, let, const, function, function*, class)이 선언되기 이전에 참조 가능하다. 변수가 어떻게 생성되며 호이스팅은 어떻게 이루어지는지 좀더 자세히 살펴보자. 변수는 3단계에 걸쳐 생성된다. 자세한 내용은 Execution Context을 참조하기 바란다. 선언 단계(Declaration phase)변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 초기화 단계(Initialization phase)변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화 된다. 할당 단계(Assignment phaseundefined로 초기화된 변수에 실제값을 할당한다. var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 즉, 스코프에 변수가 등로고디고 변수는 메모리에 공간을 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라고 한다. 이후 변수 할당문에 도달하면 비로소 값의 할당이 이루어진다. 참고 키워드 변수 생명주기 변수 호이스팅 앞에서 살펴본 예제를 호이스팅 관점에서 다시 확인해 보자. (1) 이 실행되기 이전에 var foo = 123; 이 호이스팅되어 (1) 구문 앞에 var foo; 가 옮겨진다.(실제로 변수 선언이 코드 레벨로 옮겨진 것은 아니고 변수 객체(Variable object)에 등록되고 undefined로 초기화된 것이다.) 하지만 변수 선언 단계와 초기화 단계가 할당 단계와 분리되어 진행되기 때문에 이 단계에서는 foo에는 undefined가 할당되어 있다. 변수 foo에 값이 할당되는 것은 2행에서 실시된다. (2)에서는 변수에 값이 할당되었기 때문에 123이 출력된다. 자바스크립트의 변수는 다른 C-family와는 달리 블록 레벨 스코프(block-level scope) 를 가지지 않고 함수 레벨 스코프(function-level scope) 를 갖는다. 단, ECMAScript 6에서 도입된 let, const 키워드를 사용하면 블록 레벨 스코프를 사용할 수 있다. 자세한 내용은 Scope를 참조하기 바란다. 함수 레벨 스코프(Function-level scope)함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다. 블록 레벨 스코프(Block-level scope)코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 따라서 코드 블록 내의 변수 foo는 적역변수이므로 적연에 선언된 변수 foo에 할당된 값을 재할당하기 때문에 (3)의 결과는 456이 된다. 2.4 var 키워드로 선언된 변수의 문제점ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이다. var 키워드로 선언된 변수는 아래와 같은 특징을 갖는다. 이는 다른 C-family언어와는 차별되는 특징(설계상 오류)으로 주의를 기울이지 않으면 심각한 문제를 발생시킨다. 함수 레벨 스코프(Function-level scope) 전역 변수의 남발 for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다. var 키워드 생략 허용 의도하지 않은 변수의 전역화 중복 선언 허용 의도하지 않은 변수값 변경 변수 호이스팅 변수를 선언하기 전에 참조가 가능하다. 대부분의 문제는 전역변수로 인해 발생한다. 전역 변수는 간단한 애플리케이션의 경우, 사용이 편리한 면이 있지만 불가피한 상황을 제외하고 사용을 억제해야 한다. 전역 변수는 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될지 파악하기 힘들다. 이는 의도치 않은 변수의 변경이 발생할 수 있는 가능성이 증가한다. 또한 여러 함수와 상호 의존하는 등 부수 효과(side effect)가 있을 수 있어서 복잡성이 증가한다. 변수의 유효 범위(scope)가 좁을수록 좋다. ES6는 이러한 var의 단점을 보안하기 위해 let과 const 키워드를 도입하였다. Referencepoiemaweb.com/js-data-type-variable 자바스크립트의 메모리관리 자바스크립트는 어떻게 동작하는가","link":"/2021/06/07/js-day3-datatype-variable/"},{"title":"js-day4-operator","text":"Operator연산자1.표현식과 연산자값은 다양한 방법으로 생성할 수 있다. 여기서 말하는 다양한 방법이란 표현식을 말한다. 프로그래밍 언어에서 표현식은 중요한 역할을 한다. 다시 한번 표현식에 대해 살펴보자. 표현식(expression)은 리터럴, 식별자, 연산자, 함수 호출 등의 조합을 말한다. 표현식은 평가(evaluation. 표현식을 실행하여 하나의 값을 만드는 과정)되어 하나의 값을 만든다. 즉, 표현식은 하나의 값으로 평가될 수 있는 문(statement, 문과 표현식 참고)이다. 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등으로 나누어 볼 수 있지만 결국 평가되어 하나의 값을 만든다는 점에서 모두 동일하다. 1234567891011// 리터럴 표현식10// 식별자 표현식sum// 연산자 표현식10 + 20// 함수/메소드 호출 표현식square() 표현식은 평가되어 결국 하나의 값이 되므로 표현식과 같은 동등한 관계, 즉 동치(Equivalent)다. 다시 말해, 표현식은 값처럼 사용할 수 있다. 이것은 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 의미다. 예를 들어 산술 연산자 +의 좌항과 우항에는 숫자 값이 위치해야 한다. 숫자 값으로 평가될 수 있는 표현식이라면 숫자 값 대신 사용할 수 있다. 1234var x = 10;// 연산자 표현식x + 30; // 식별자 표현식과 숫자 리터럴과 연산자의 조합 이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다. 연산자 표현식은 표현식을 결합해 새로운 값을 만들어 내는 가장 일반적인 표현식이다. 2.문과 표현식문(statement)은 자바스크립트 엔진에서 내리는 명령이다. 문이 실행되면 무슨 일인가가 일어나게 된다. 변수 선언문을 실행하면 변수가 신언이 되고, 할당문을 실행하면 할당이 된다. 조건문을 실행하면 주어진 조건에 따라 코드 블록({…})의 실행이 결정되고, 반복문을 실행하면 코드 블록이 반복 실행된다. 1234567891011121314// 변수 선언문var x;// 할당문x = 5;// 함수 선언문function foo () {}// 조건문if (x &gt; 5) { … }// 반복문for (var i = 0; i &lt; 10; i++) { … } 문은 리터럴, 연산자, 표현식, 키워드 등으로 구성되며 세미콜론(;)으로 끝나야 한다. (코드 블록{…}은 제외) 문의 끝에 붙이는 세미콜론은 옵션으로 쓰지 않아도 상관없다. 자바스크립트 엔진이 스크립트를 해석할 때, 자바스크립트 엔진에는 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 있기 때문이다. 하지만 세미콜론 자동 삽입 기능의 예측과 개발자의 예측과 다른 경우가 간혹 있다. 12345function foo () { return {}}console.log(foo()); // undefined 세미콜론을 반드시 붙여야 한다는 주장이 대다수를 차지하지만 붙이지 말아야한다는 주장도 설득력이 있다. 하지만 ESLint와 같은 정적 분석 도구에서도 세미콜론 사용을 기본으로 설정하고 있고 TC39(ECMAScript 기술 위원회)도 세미콜론 사용을 권장하는 분위기이므로 세미콜론을 붙이도록 하겠다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 자연어에서 문이 마침표로 끝나는 하나의 완전한 문장(Sentence)이라고 한다면 표현식은 문을 구성하는 요소이다. 표현식은 그 자체로 하나의 문이 될 수도 있다. 표현식과 문은 유사하여 구별이 어려울 수 있다. 표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. 문은 var, let, const, function, class와 같은 선언 키워드를 사용하여 변수나 함수를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다. 표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 컴퓨터에게 명령을 내리는 것이다. 문에는 표현식인 문과 표현식이 아닌 문이 있다. 예를 들어 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 그 자체가 표현식인 문이다. 아래의 예제를 살펴보자 12345// 선언문(Declaration statement)var x = 5 * 10; // 표현식 x = 5 * 10를 포함하는 문이다.// 할당문(Assignment statement)x = 100; // 이 자체가 표현식이지만 완전한 문이기도 하다. 이에 반해 할당문은 그 자체가 표현식이다. 다시 말해 할당문은 표현식인 문이다. 크롬 DevTools에서 표현식이 아닌 문은 언제나 Undefined를 반환하고, 표현식인 문은 언제나 값을 반환한다. 할당문은 표현식인 문이기 때문에 값처럼 사용할 수 있다. 1var foo = x = 100; 할당문을 값처럼 변수에 할당했다. 할당문은 할당한 값으로 평가된다. 즉, x=100은 변수 x에 할당한 값 100으로 평가 될 수 있다. 따라서 변수 foo에는 100이 할당된다. 3.연산자란?연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다. 피연산자도 평가되어 하나의 값이 되므로 표현식이고 피연산자를 연산자와 결합한 연산자 표현식도 물론 표현식이다. 1234567891011121314151617// 산술 연산자5 * 4 // 20// 문자열 연결 연산자'My name is ' + 'Lee' // &quot;My name is Lee&quot;// 할당 연산자var color = 'red'; // &quot;red&quot;// 비교 연산자3 &gt; 5 // false// 논리 연산자(5 &gt; 3) &amp;&amp; (2 &lt; 4) // true// 타입 연산자typeof 'Hi' // &quot;string&quot; 피연산자가 “값”이라는 명사의 역할을 한다면 연산자는 “값을 만든다”라는 동사의 역할을 한다고 볼 수 있다. 다시 말해, 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 값으로 평가된 피연산자를 연산해 새로운 값을 만든다. 자바스크립트가 제공하는 다양한 연산자에 대해 살펴보도록 하자. 4.산술 연산자산술 연산자(Arithmetic Operator)는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산을 할 수 없는 경우에는 NaN을 반환한다. 산술연산자는 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다. 4.1 이항 산술 연산자이항 산술 연산자는 2개의 피연산자를 대상으로 연산하여 숫자 타입의 값을 만든다. 모든 이항 산술 연산자의 값을 변경하는 부수 효과(Side effect)가 없다. 다시 말해, 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 단기 새로운 값을 만들 뿐이다. 이항 산술 연산자 의미 + 덧셈 - 뺄셈 * 곱셈 / 나눗셈 % 나머지 123455 + 2 // 75 - 2 // 35 * 2 // 105 / 2 // 2.55 % 2 // 1 4.2.단항 산술 연산자단항 산술 연산자는 1개의 피연산자를 대상으로 연산한다. 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수효과가 있다. 다시 말해, 증가/감소 연산을 하면 피연산자의 값이 바뀐다. 단항 산술 연산자 의미 ++ 증가 – 감소 + 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. - 양수를 음수로 음수를 양수로 반전한 값을 반환한다. 증가/감소(++/–) 연산자는 위치에 의미가 있다. 피연산자 앞에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다. 피연산자 뒤에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소 시킨다. 1234567891011121314151617var x = 5, result;// 선대입 후증가 (Postfix increment operator)result = x++;console.log(result, x); // 5 6// 선증가 후대입 (Prefix increment operator)result = ++x;console.log(result, x); // 7 7// 선대입 후감소 (Postfix decrement operator)result = x--;console.log(result, x); // 7 6// 선감소 후대입 (Prefix decrement operator)result = --x;console.log(result, x); // 5 5 단항 연산자는 피연산자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. 그런데 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. 1234+10 // 10+'10' // 10+true // 1+false // 0 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다. _ 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. 1234-10 // -10-'10' // -10-true // -1-false // -0 4.3.문자열 연결 연산자 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다. 아래 예제를 살펴보자. 1234567891011// 문자열 연결 연산자'1' + '2' // '12''1' + 2 // '12'// 산술 연산자1 + 2 // 31 + true // 2 (true → 1)1 + false // 1 (false → 0)true + false // 1 (true → 1 / false → 0)1 + null // 1 (null → 0)1 + undefined // NaN (undefined → NaN) 이 예제에서 주목할 것은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 다입이 자동 변환되기도 한다는 것이다. 위 예제에서 1+true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 앞서 살펴본 +/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다. 이에 대해서는 타입 변환에서 자세히 살펴볼 것이다. 5.할당 연산자할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 부수효과가 있다. 할당 연산자 사례 동일 표현 = x = y x = y += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= x %= y x = x % y 1234567891011var x;x = 10; // 10x += 5; // 15x -= 5; // 10x *= 5; // 50x /= 5; // 10x %= 5; // 0var str = 'My name is ';str += 'Lee'; // My name is Lee 표현식은 “하나의 값으로 평가된다”고 하였다. 그렇다면 할당 연산은 표현식일까? 아래의 예제를 살펴보자. 12var x;console.log(x = 10); // 10 할당 연산은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만 할당 연산은 하나의 값으로 평가되는 표현식이다. 할당 표현식은 할당된 값으로 평가된다. 위 예제의 경우 x에 할당된 숫자 값 10으로 평가된다. 따라서 아래와 같이 할당 연산 표현식을 다른 변수에 할당할 수도 있다. 123var x, y;y = x = 10; // 연쇄 할당(Chained assignment)console.log(x, y); // 10 10 6.비교 연산자비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교하여 불리언 값을 반환한다. if문이나 for문과 같은 제어문의 조건식에서 주로 사용한다. 6.1 동등 / 일치 비교 연산자 비교 연산자 의미 사례 설명 == 동등 비교 x==y x와 y의 값이 같음 === 일치 비교 x===y x와 y의 값과 타입이 같음 != 부등 비교 x!=y x와 y의 값이 다름 !== 불일치 비교 x!==y x와 y의 값과 타입이 다름 문자열 연결 연산자에서 언급했듯이 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되지도 한다. 이를 암묵적 타입 변환이라 부른다. 동등 비교(==) 연산자는 좌항과 우항의 피연사자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값을 갖는지 비교한다. 따라서 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값을 수 있으면 true를 반환한다. 12345// 동등 비교5 == 5 // true// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 같은 값을 같는다.5 == '5' //true5 == 8 // false 결론부터 말하자면 동등 비교 연산자는 편리한 경우도 있지만 수많은 부작용을 일으키므로 사용하지 않는 편이 좋다. 아래 예제를 살펴보자. 12345678910'' == '0' // false0 == '' // true0 == '0' // truefalse == 'false' // falsefalse == '0' // truefalse == undefined // falsefalse == null // falsenull == undefined // true 위 예제와 같은 코드를 작성할 개발자는 드물겠지만 이처럼 동등 비교(==)연산자는 예측하기 어려운 겨로가를 만들어낸다. 위 예제는 이해하려 하지 않아도 된다. 다만 동등 비교 연산자를 사용하지 말고 일치 비교 연산자를 사용하면 된다. 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 123// 일치 비교5 === 5 // true5 === '5' // false 일치 비교 연산자는 예측하기 쉽다. 위에 살펴본 동등 비교 연산자의 해괴망측한 예제는 모두 false를 반환한다. 일치 비교 연산자에서 주의할 것은 NaN이다. 1NaN === NaN // false NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다. 1isNaN(NaN) // true 숫자 0도 주의하도록 하자. 10===0 // true 부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다. 123456789// 부동등 비교5 != 8 // true5 != 5 // false5 != '5' // false// 불일치 비교5 !== 8 // true5 !== 5 // false5 !== '5' // true 6.2 대소 관계 비교 연산자대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.|대소 관계 비교 연산자|예제|설명||———————|—-|—-||&gt;|x &gt; y|x가 y보다 크다 X||&lt;|x &lt; y|x가 y보다 작다 X||&gt;=|x &gt;= y|x가 y보다 같거나 크다 X||&lt;=|x &lt;= y|x가 y보다 같거나 작다 X| 12345678910111213141516// 대소 관계 비교5 &gt; 0 // true5 &gt; 5 // false5 &gt; 8 // false5 &lt; 0 // false5 &lt; 5 // false5 &lt; 8 // true5 &gt;= 0 // true5 &gt;= 5 // true5 &gt;= 8 // false5 &lt;= 0 // false5 &lt;= 5 // true5 &lt;= 8 // true 7.삼항 조건 연산자삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 연산자이며 부수 효과는 없다. 삼항 조건 연산자 표현식은 아래와 같이 사용한다. 1조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값 물음표(?) 앞의 첫번째 피연산자가 조건식, 즉 불리언 타입의 값으로 평가될 표현식이다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. 이때 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다. 1234567var x = 2;// x가 짝수이면 '짝수'를 홀수이면 '홀수'를 반환한다.// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 삼항 조건 연산자는 다음 장에서 살펴볼 if…else 문을 사용해도 동일한 처리를 할 수 있다. 12345678var x = 2, result;// x가 짝수이면 '짝수'를 홀수이면 '홀수'를 반환한다.// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.if (x % 2) result = '홀수';else result = '짝수';console.log(result); // 짝수 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else문은 값으로 평가할 수 없다. 하지만 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식이다. 따라서 삼항 조건 연산자식은 다른 표현식의 일부가 될 수 있어 매우 유용하다. 8.논리 연산자논리 연산자(Logical Operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다. 논리 부정(!) 연산자는 언제나 분리언 값을 반환한다. 하지만 논리합(||) 연산자와 논리곱 (&amp;&amp;) 연산자는 일반적으로 불리언 값을 반환하지만 반드시 불리언 값을 반환해야 하는 것은 아니다. 논리 연산자 의미 || 논리합(OR) && 논리곱(AND) ! 부정(NOT) 123456789101112131415// 논리합(||) 연산자true || true // truetrue || false // truefalse || true // truefalse || false // false// 논리곱(&amp;&amp;) 연산자true &amp;&amp; true // truetrue &amp;&amp; false // falsefalse &amp;&amp; true // falsefalse &amp;&amp; false // false// 논리 부정(!) 연산자!true // false!false // true 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자는 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환 된다. 12// 암묵적 타입 변환!0 // true 하지만 논리합 (||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 언제나 피연산자 중 어느 한쪽 값을 반환한다. 이에 대해서는 단축 평가에서 자세히 살펴보기로 하자 12// 단축 평가'Cat' &amp;&amp; 'Dog' // “Dog” 9.쉼표 연산자쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. 12var x, y, z;x = 1, y = 2, z = 3; // 3 10. 그룹 연산자그룹((…)) 연산자는 그룹 내의 표현식을 최우선으로 평가한다. 그룹 연산자를 사용하면 연산자의 우선 순위를 1순위로 높일 수 있다. 1210 * 2 + 3 // 2310 * (2 + 3) // 50 11. typeof 연산자typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 일치하지는 않는다. typeof 연산자는 7가지 문자열 ‘string’, ‘number’, ‘boolean’, ‘undefined’, ‘symbol’, ‘object’, ‘function’중 하나를 반환한다. ‘null’을 반환하는 경우는 없으며 함수의 경우 ‘function’을 반환한다. 123456789101112typeof '' // &quot;string&quot;typeof 1 // &quot;number&quot;typeof NaN // &quot;number&quot;typeof true // &quot;boolean&quot;typeof undefined // &quot;undefined&quot;typeof Symbol() // &quot;symbol&quot;typeof null // &quot;object&quot;typeof [] // &quot;object&quot;typeof {} // &quot;object&quot;typeof new Date() // &quot;object&quot;typeof /test/gi // &quot;object&quot;typeof function () {} // &quot;function&quot; 주의해야 할 것은 typeof 연산자로 null 값을 연산해 보면 null이 아닌 ‘object’를 반환한다는 것이다. 이것은 자바스크립트의 첫번째 버전에서 이렇게 설계된 것을 현재의 버전에 반영하지 못하고 있지 때문이다. (참고) 1typeof null // &quot;object&quot; 따라서 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하도록한다. 123var foo = null;console.log(typeof foo === null); // falseconsole.log(foo === null); // true 또 하나 주의해야 할 것이 있다. 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 ‘undefined’를 반환한다. 1typeof undeclared // &quot;undefined&quot; typeof 연산자가 선언하지 않은 식별자를 연산했을 때 ‘undefined’를 반환하는 것을 카일 심슨의 ‘You don’t know JS’에서는 특별한 안전 가드(safety guard)로 설명한다. 하지만 모던 자바스크립트 개발에서는 대부분 모듈을 사용하고 전역변수인 플래그를 사용하지 않으므로 의도적으로 사용할 필요는 없다. Referencepoiemaweb.com/js-operator","link":"/2021/06/14/js-day4-operator/"},{"title":"js-day5-control-flow","text":"Control Flow제어문제어문(Control flow statement)은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반벅으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문은 코드의 실행 순서를 인위적으로 제어할 수 있다. 1. 블록문블록문(Block statement/Compound statement)는 0개 이상의 문들을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 단위로 취급한다. 블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수 선언문 등에서 사용한다. 문의 끝에는 세미 콜론(;)을 붙이는 것이 일반적이지만 블록문은 세미 콜론을 붙이지 않는다. 123456789101112131415161718// 블록문{ var foo = 10; console.log(foo);}// 제어문var x = 0;while (x &lt; 10) { x++;}console.log(x); // 10// 함수 선언문function sum(x, y) { return x + y;}console.log(sum(1, 2)); // 3 2. 조건문조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다. 자바스크립트는 2가지의 조건문 if…else 문과 switch 문을 제공한다. 2.1 if…else 문if…else 문은 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과, 즉 논리적 참, 거짓에 따라 실행할 코드 블록을 결정한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제변환되어 논리적 참, 거짓을 구별한다. 12345if (조건식) { // 조건식이 참이면 이 코드 블록이 실행된다.} else { // 조건식이 거짓이면 이 코드 블록이 실행된다.} 조건식의 평가 결과가 참(true)일 경우, if문 다음의 코드 블록이 실행된다. 거짓(false)일 경우, else 문 다음의 코드 블록이 실행된다. 조건식을 추가하고 싶으면 else if 문을 사용한다. 1234567if (조건식1) { // 조건식1이 참이면 이 코드 블록이 실행된다.} else if (조건식2) { // 조건식2이 참이면 이 코드 블록이 실행된다.} else { // 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.} else if 문과 else 문은 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. if문과 else 문은 2번 이상 사용할 수 없지만 else if문은 여러번 사용할 수도 있다. 1234567891011121314151617181920212223242526var num = 2;var kind;// if 문if (num &gt; 0) { kind = '양수'; // 음수를 구별할 수 없다}console.log(kind); // 양수// if…else 문if (num &gt; 0) { kind = '양수';} else { kind = '음수'; // 0은 음수가 아니다}console.log(kind); // 양수// if…else if 문if (num &gt; 0) { kind = '양수';} else if (num &lt; 0) { kind = '음수';} else { kind = '영';}console.log(kind); // 양수 만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다. 12345678var num = 2;var kind;if (num &gt; 0) kind = '양수';else if (num &lt; 0) kind = '음수';else kind = '영';console.log(kind); // 양수 대부분의 if…else 문은 연산자에서 살펴본 삼항 조건 연산자로 바꿔쓸 수 있다. 아래 예제를 살펴보자. 1234567891011// x가 짝수이면 ‘짝수'를 홀수이면 ‘홀수'를 반환한다.var x = 2;var result;if (x % 2) { // 2 % 2는 0이고 0은 false로 취급된다. result = '홀수';} else { result = '짝수';}console.log(result); // 짝수 위 예제는 아래와 같이 삼항 조건 연산자로 바꿔쓸 수 있다. 123456// x가 짝수이면 '짝수'를 홀수이면 '홀수'를 반환한다.var x = 2;// 0은 false로 취급된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 위 예제는 두가지 경우의 수 (‘홀수’ 또는 ‘짝수’)를 갖는 경우이다. 만약 세가지 경우의 수는 아래와 같이 바꿔쓸 수 있다. 12345var num = 2;// 0은 false로 취급된다.var kind = num ? (num &gt; 0 ? '양수' : '음수') : '영';console.log(kind); // 양수 num &gt; 0? ‘양수’ : ‘음수’ 는 표현식이므로 다른 표현식의 일부가 될 수 있다. 2.2 switch 문switch 문은 switch 문의 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동시킨다. case 문은 상황(case)을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다. switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. 12345678910switch (표현식) { case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;} if…else 문의 조건식은 반드시 불리언 값으로 평가되지만 switch 문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다. if…else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. 아래 예제를 살펴보자. switch 문의 표현식, 즉 변수 month의 평가 결과인 숫자 값 11과 일치하는 case 문으로 실행 순서가 이동한다. 12345678910111213141516171819202122232425262728293031323334// 월을 영어로 변환한다. (11 → 'November')var month = 11;var monthName;switch (month) { case 1: monthName = 'January'; case 2: monthName = 'February'; case 3: monthName = 'March'; case 4: monthName = 'April'; case 5: monthName = 'May'; case 6: monthName = 'June'; case 7: monthName = 'July'; case 8: monthName = 'August'; case 9: monthName = 'September'; case 10: monthName = 'October'; case 11: monthName = 'November'; case 12: monthName = 'December'; default: monthName = 'Invalid month';}console.log(monthName); // Invalid month 그런데 위 예제를 실행해 보면 ‘November’가 출력되지 않고 ‘Invalid month’가 출력된다. 이는 switch 문의 표현식의 평가 결과와 일치하는 case 문으로 실행 순서가 이동하여 문을 실행한 것은 맞지만, 문을 실행한 후 switch 문을 탈출하지 않고 switch 문이 끝날 때까지 모든 case 문과 default 문을 실행했기 때문이다. 이를 폴스루(fall through)라 한다. 다시 말해 변수 monthName에 ‘November’가 할당된 후 switch 문을 탈출하지 않고 연이어 ‘December’가 재할당되고 마지막으로 ‘Invalid month’가 재할당되었다. 결과가 이러한 이유는 case 문에 해당하는 문의 마지막에 break 문을 사용하지 않았기 때문이다. break 키워드로 구성된 break 문은 코드 블록에서 탈출하는 역할을 수행한다. break 문이 없다면 case 문의 표현식과 일치하지 않더라도 실행 순서는 다음 case 문으로 연이어 이동한다. 올바른 switch 문은 아래와 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 월을 영어로 변환한다. (11 → 'November')var month = 11;var monthName;switch (month) { case 1: monthName = 'January'; break; case 2: monthName = 'February'; break; case 3: monthName = 'March'; break; case 4: monthName = 'April'; break; case 5: monthName = 'May'; break; case 6: monthName = 'June'; break; case 7: monthName = 'July'; break; case 8: monthName = 'August'; break; case 9: monthName = 'September'; break; case 10: monthName = 'October'; break; case 11: monthName = 'November'; break; case 12: monthName = 'December'; break; default: monthName = 'Invalid month';}console.log(monthName); // November default 문에는 break 문을 생략하는 것이 일반적이다. default 문은 switch 문의 가장 마지막에 위치하므로 default 문의 실행이 종료하면 switch 문을 빠져나간다. 따라서 별도로 break 문이 필요없다. case 문은 반드시 단독으로 사용되어야 하는 것은 아니다. 아래 예제와 같이 여러 개의 case 문을 중복해 사용할 수도 있다. 아래는 윤년인지 판별해서 2월의 일수를 계산하는 예제다. 1234567891011121314151617181920212223var year = 2000; // 2000년은 윤년으로 2월이 29일이다.var month = 2;var days = 0;switch (month) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: days = 31; break; case 4: case 6: case 9: case 11: days = 30; break; case 2: // 윤년 계산 알고리즘 // 1. 년도가 4로 나누어 떨어지는 해는 윤년(2000, 2004, 2008, 2012, 2016, 2020…) // 2. 그 중에서 년도가 100으로 나누어 떨어지는 해는 평년(2000, 2100, 2200...) // 3. 그 중에서 년도가 400으로 나누어 떨어지는 해는 윤년(2000, 2400, 2800...) days = ((year % 4 === 0 &amp;&amp; year % 100 !== 0) || (year % 400 === 0)) ? 29 : 28; break; default: console.log('Invalid month');}console.log(days); // 29 switch 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생하는 등 문법도 복잡하다. if…else 문으로 해결할 수 있다면 if…else 문을 사용하는 편이 좋다. 하지만 if…else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch 문을 사용하는 편이 좋다. 3. 반복문반복문(Loop statement)은 주어진 조건식(conditional expression)의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. 자바스크립트는 3가지 반복문 for문, while문, do…while문을 제공한다. 그 외에도 for…in문, ES6에서 새롭게 도입된 for…of문이 있다. for…in 문과 for…of문에 대해서는 나중에 살펴보기로 하자. 3.1 for 문for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 반복문이다. 123for (초기화식; 조건식; 증감식) { 조건식이 참인 경우 반복 실행될 문;} for 문은 매우 중요하다. 아직 for문에 익숙하지 않다면 많은 연습을 통해 확실히 이해하기를 권장한다. 아래의 예제를 통해 for문이 어떻게 동작하는지 살펴보자. 123for (var i = 0; i &lt; 2; i++) { console.log(i);} 위 예제의 for 문은 변수 i가 0으로 초기화된 상태에서 시작하여 i가 2보다 작을 때까지 코드 블록을 2번 반복 실행한다. for 문의 실행 순서를 따라가며 어떻게 동작하는지 살펴보자. for 문을 실행하면 가장 먼저 초기화식 var i = 0이 실행된다. 초기화식은 단 한번만 실행된다. 초기화식의 실행이 종료되면 조건식으로 실행 순서가 이동한다. 현재 변수 i는 0이므로 조건식의 평가 결과는 true다. 조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 증감문으로 실행 순서가 이동하는 것이 아니라 코드 블록으로 실행 순서가 이동하는 것에 주의하자. 코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 1이 된다. 증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 초기화식으로 실행 순서가 이동하는 것이 아니라 조건식으로 실행 순서가 이동하는 것에 주의하자. 초기화식은 단 한번만 실행된다. 현재 변수 i는 1이므로 조건식의 평가 결과는 true다. 조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 2가 된다. 증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 현재 변수 i는 2이므로 조건식의 평가 결과는 false다. 조건식의 평가 결과가 false이므로 for 문의 실행이 종료된다. 아래 예제는 위 예제를 역으로 반복하는 for 문이다. 변수 i가 1으로 초기화된 상태에서 시작하여 i가 0보다 같거나 커질 때까지 코드 블록을 2번 반복 실행한다. 123for (var i = 1; i &gt;= 0; i--) { console.log(i);} for 문의 초기화식, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 어떤 식도 선언하지 않으면 무한 루프가 된다. 1for (;;) { } // 무한루프 for 문 내에 for 문을 중첩해 사용할 수 있다. 아래는 두 개의 주사위를 던졌을 때, 두 눈의 합이 6이 되는 모든 경우의 수를 출력하는 예제다. 12345for (var i = 1; i &lt;= 6; i++) { for (var j = 1; j &lt;= 6; j++) { if (i + j === 6) console.log(`[${i}, ${j}]`); }} 출력 결과는 아래와 같다. 12345[1, 5][2, 4][3, 3][4, 2][5, 1] 3.2 while 문while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다. 1234567var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.while (count &lt; 3) { console.log(count); count++;} // 0 1 2 조건식의 평가 결과가 언제나 참이면 무한루프가 된다. 12// 무한루프while (true) { } 무한루프를 탈출하기 위해서는 코드 블럭 탈출 조건을 if 문에 부여하고 break 문으로 코드 블럭을 탈출한다. 123456789var count = 0;// 무한루프while (true) { console.log(count); count++; // count가 3이면 코드 블록을 탈출한다. if (count === 3) break;} // 0 1 2 3.3 do…while 문do…while 문은 코드 블록을 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다. 1234567var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.do { console.log(count); count++;} while (count &lt; 3); // 0 1 2 4. break 문switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다. 좀 더 정확히 표현하자면 코드 블록을 탈출하는 것이 아니라 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용하면 SyntaxError(문법 에러)가 발생한다. 123if (true) { break; // Uncaught SyntaxError: Illegal break statement} 레이블 문(Label statement)이란 식별자가 붙은 문을 말한다. 12// foo라는 레이블 식별자가 붙은 레이블 문foo: console.log('foo'); 레이블 문은 프로그램의 실행 순서를 제어하기 위해 사용한다. 사실 switch 문의 case 문과 default 문도 레이블 문이다. 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다. 12345678// foo라는 식별자가 붙은 레이블 블록문foo: { console.log(1); break foo; // foo 레이블 블록문을 탈출한다. console.log(2);}console.log('Done!'); 중첩된 for 문의 내부 for 문에서 break 문을 실행하면 내부 for 문을 탈출하여 외부 for 문으로 진입한다. 이때 내부 for 문이 아닌 외부 for 문을 탈출하려면 레이블 문을 사용한다. 123456789// outer라는 식별자가 붙은 레이블 for 문outer: for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { // i + j === 3이면 외부 for 문을 탈출한다. if (i + j === 3) break outer; }}console.log('Done!'); 중첩된 for 문을 외부로 탈출할 때 레이블 문은 유용하지만 그 외의 경우 레이블 문은 일반적으로 권장하지 않는다. 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다. break 문은 레이블 문 뿐만이 아니라 반복문, switch 문에서도 사용할 수 있다. 이 경우에는 break 문에 레이블 식별자를 지정하지 않는다. break 문은 반복문을 더 이상 진행하지 않아도 될 때 불필요한 반복을 회피할 수 있어 유용하다. 아래는 문자열에서 특정 문자의 인덱스(위치)를 검색하는 예제이다. 12345678910111213141516var string = 'Hello World.';var index;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 문자열의 개별 문자가 'l'이면 if (string[i] === 'l') { index = i; break; // 반복문을 탈출한다. }}console.log(index); // 2// 참고로 String.prototype.indexOf 메소드를 사용해도 같은 동작을 한다.console.log(string.indexOf('l')); // 2 5. continue 문continue 문은 반복문(for, for…in, for…of, while, do…while)의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다. 아래는 문자열에서 특정 문자의 개수를 카운트하는 예제이다. 1234567891011121314var string = 'Hello World.';var count = 0;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다. if (string[i] !== 'l') continue; count++; // continue 문이 실행되면 이 문은 실행되지 않는다.}console.log(count); // 3// 참고로 String.prototype.match 메소드를 사용해도 같은 동작을 한다.console.log(string.match(/l/g).length); // 3 위 예제의 for 문은 아래와 동일하게 동작한다. 1234for (var i = 0; i &lt; string.length; i++) { // 'l'이면 카운트를 증가시킨다. if (string[i] === 'l') count++;} 위와 같이 if 문 내에서 실행해야 할 코드가 한 줄이라면 continue 문을 사용했을 때보다 간편하며 가독성도 좋다. 하지만 if 문 내에서 실행해야 할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다. 123456789101112131415161718192021// continue 문을 사용하지 않으면 if 문 내에 코드를 작성해야 한다.for (var i = 0; i &lt; string.length; i++) { // 'l'이면 카운트를 증가시킨다. if (string[i] === 'l') { count++; // code // code // code }}// continue 문을 사용면 if 문 밖에 코드를 작성할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 'l'이 아니면 카운트를 증가시키지 않는다. if (string[i] !== 'l') continue; count++; // code // code // code} Referencepoiemaweb.com/js-control-flow","link":"/2021/06/21/js-day5-control-flow/"},{"title":"js-day6-type-coercion","text":"1. 타입 변환이란?자바스크립트의 모든 값은 타입이 있다. 값의 타입은 다른 타입으로 개발자에 의해 의도적으로 변환할 수 있다. 자바스크립트 엔진에 의해 암묵적으로 자동 변환될 수 있다. 개발자에 의해 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type castion)이라 한다. 12345var x = 10;// 명시적 타입 변환var str = x.toString(); // 숫자를 문자열로 타입 캐스팅한다.console.log(typeof str); // string 동적 타입 언어인 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion) 이라고 한다. 12345678910var x = 10;// 암묵적 타입 변환// 숫자 타입 x의 값을 바탕으로 새로운 문자열 타입의 값을 생성해 표현식을 평가한다.var str = x + '';console.log(typeof str, str); // string 10// 변수 x의 값이 변경된 것은 아니다.console.log(x); // 10 명시적 타입 변환도 마찬가지지만, 암묵적 타입 변환이 기존 값(위 예제의 경우, 변수 x의 값)을 직접 변경하는 것은 아니다. “변수”에서 살펴보았듯이 변수 값이 원시 타입의 값인 경우, 변수 값을 변경하려면 재할당을 통해 새로운 메모리 공간을 확보하고 그 곳에 원시 값을 저장한 후 변수명이 재할당된 원시 값이 저장된 메모리 공간의 주소를 기억하도록 해야 한다. 암묵적 타입 변환은 변수 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 기존 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다. 위 예제의 경우, 자바스크립트 엔진은 표현식 x + ‘‘을 평가하기 위해 변수 x의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’ + ‘‘를 평가한다. 이때 자동 생성된 문자열 ‘10’은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 제거된다. 명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다. 따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지, 그리고 타입 변환된 값으로 표현식은 어떻게 평가될 것인지 예측 가능해야 한다. 만약 예측하지 못하거나 예측한 내용이 결과와 일치하지 않는다면 버그를 생산할 가능성이 높아진다. 그렇다면 명시적 타입 변환 만을 사용하고 암묵적 타입 변환은 발생하지 않도록 코드를 작성하면 어떨까? 좋은 생각이긴 하지만 이러한 논리는 옳지 않다. 때로는 명시적 타입 변환보다 암묵적 타입 변환이 가독성 면에서 더 좋을 수도 있다. 예를 들어 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 (10).toString()보다 10 + ‘’이 더욱 간결하고 이해하기 쉬울 수 있다. 중요한 것은 코드를 예측할 수 있어야 한다는 것이다. 동료가 작성한 코드를 정확히 이해할 수 있어야 하고 자신의 코드는 타인에 의해 쉽게 이해될 수 있어야 한다. 이를 위해 타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하도록 하자. 2. 암묵적 타입 변환자바스크립트 엔진은 표현식을 평가할 때 문맥, 즉 컨텍스트(Context)에 고려하여 암묵적 타입 변환을 실행한다. 아래 예제를 살펴보자. 12345678910// 표현식이 모두 문자열 타입이여야 하는 컨텍스트'10' + 2 // '102'`1 * 10 = ${ 1 * 10 }` // &quot;1 * 10 = 10&quot;// 표현식이 모두 숫자 타입이여야 하는 컨텍스트5 * '10' // 50// 표현식이 불리언 타입이여야 하는 컨텍스트!0 // trueif (1) { } 이처럼 표현식을 평가할 때 문맥, 즉 컨텍스트에 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다. 암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다. 타입별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자. 2.1 문자열 타입으로 변환아래의 예제를 살펴보자. 11 + '2' // &quot;12&quot; 위 예제의 + 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연셜 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 피연산자는 문맥, 즉 컨텍스트 상 문자열 타입이여야 한다. 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다. 연산자 식의 피연산자(피연산자도 표현식이다)만이 암묵적 타입 변환의 대상이 되는 것은 아니다. 앞서 언급했듯이 자바스크립트 엔진은 표현식을 평가할 때 문맥, 즉 컨텍스트에 부합하도록 암묵적 타입 변환을 실행한다. 예를 들어 ES6에서 도입된 템플릿 리터럴의 문자열 인터폴레이션(String Interpolation)은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다. 1console.log(`1 + 1 = ${1 + 1}`); // &quot;1 + 1 = 2&quot; 자바스크립트 엔진은 문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다. 123456789101112131415161718192021222324// 숫자 타입0 + '' // &quot;0&quot;-0 + '' // &quot;0&quot;1 + '' // &quot;1&quot;-1 + '' // &quot;-1&quot;NaN + '' // &quot;NaN&quot;Infinity + '' // &quot;Infinity&quot;-Infinity + '' // &quot;-Infinity&quot;// 불리언 타입true + '' // &quot;true&quot;false + '' // &quot;false&quot;// null 타입null + '' // &quot;null&quot;// undefined 타입undefined + '' // &quot;undefined&quot;// 심볼 타입(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string// 객체 타입({}) + '' // &quot;[object Object]&quot;Math + '' // &quot;[object Math]&quot;[] + '' // &quot;&quot;[10, 20] + '' // &quot;10,20&quot;(function(){}) + '' // &quot;function(){}&quot;Array + '' // &quot;function Array() { [native code] }&quot; 2.2 숫자 타입으로 변환아래의 예제를 살펴보자. 1231 - '1' // 01 * '10' // 101 / 'one' // NaN 위 예제의 연산자는 모두 산술 연산자이다. 산술 연산자의 역할은 숫자 값을 만드는 것이다. 따라서 산술 연산자의 피연산자는 문맥, 즉 컨텍스트 상 숫자 타입이여야 한다. 자바스크립트 엔지은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 NaN을 반환한다. 피연산자를 숫자 타입으로 변환해야 할 컨텍스트는 산술 연산자 뿐만이 아니다. 아래 예제를 살펴보자. 1'1' &gt; 0 // true 비교 연산자의 역할은 불리언 값을 만드는 것이다. &gt; 비교 연산자는 피연산자의 크기를 비교하므로 피연산자는 컨텍스트 상 숫자 타입이여야 한다. 자바스크립트 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 자바스크립트 엔진은 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다. + 단항 연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다. 12345678910111213141516171819// 문자열 타입+'' // 0+'0' // 0+'1' // 1+'string' // NaN// 불리언 타입+true // 1+false // 0// null 타입+null // 0// undefined 타입+undefined // NaN// 심볼 타입+Symbol() // TypeError: Cannot convert a Symbol value to a number// 객체 타입+{} // NaN+[] // 0+[10, 20] // NaN+(function(){}) // NaN 빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다는 것에 주의하자. 2.3 불리언 타입으로 변환아래의 예제를 살펴보자. 1if ('') console.log(x); if 문이나 for문과 같은 제어문의 조건식(conditional expression)은 불리언 값, 즉 논리적 참, 거짓을 반환해야 하는 표현식이다. 자바스크립트 엔진은 제어문의 조건식을 평가 결과를 불리언 타입으로 암묵적 타입 변환한다. 1234567if ('') console.log('1');if (true) console.log('2');if (0) console.log('3');if ('str') console.log('4');if (null) console.log('5');// 2 4 Falsy 값 이외의 값은 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 컨텍스트에서 모두 true로 평가되는 Truthy 값이다. 아래 예제는 Truthy/Falsy 값을 판별하는 함수다. 함수란 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. 함수에 대해서는 나중에 자세히 살펴볼 것이다. 1234567891011121314151617181920212223// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.function isFalsy(v) { return !v;}// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.function isTruthy(v) { return !!v;}// 모두 true를 반환한다.console.log(isFalsy(false));console.log(isFalsy(undefined));console.log(isFalsy(null));console.log(isFalsy(0));console.log(isFalsy(NaN));console.log(isFalsy(''));console.log(isTruthy(true));// 빈 문자열이 아닌 문자열은 Truthy 값이다.console.log(isTruthy('0'));console.log(isTruthy({}));console.log(isTruthy([])); 3. 명시적 타입 변환개발자의 의도에 의해 명시적으로 타입을 변경하는 방법은 다양하다. 원래는 래퍼 객체를 생성하기 위해 사용하는 래퍼 객체 생성자 함수를 new 연산자 없이 호출하는 방법과 자바스크립트에서 제공하는 빌트인 메소드를 사용하는 방법, 그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다. 3.1 문자열 타입으로 변환문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 아래와 같다. string 생성자 함수를 new 연산자 없이 호출하는 방법 Object.prototype.toString 메소드를 사용하는 방법 문자열 연결 연산자를 이용하는 방법 1234567891011121314151617181920212223242526// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(String(1)); // &quot;1&quot;console.log(String(NaN)); // &quot;NaN&quot;console.log(String(Infinity)); // &quot;Infinity&quot;// 불리언 타입 =&gt; 문자열 타입console.log(String(true)); // &quot;true&quot;console.log(String(false)); // &quot;false&quot;// 2. Object.prototype.toString 메소드를 사용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log((1).toString()); // &quot;1&quot;console.log((NaN).toString()); // &quot;NaN&quot;console.log((Infinity).toString()); // &quot;Infinity&quot;// 불리언 타입 =&gt; 문자열 타입console.log((true).toString()); // &quot;true&quot;console.log((false).toString()); // &quot;false&quot;// 3. 문자열 연결 연산자를 이용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(1 + ''); // &quot;1&quot;console.log(NaN + ''); // &quot;NaN&quot;console.log(Infinity + ''); // &quot;Infinity&quot;// 불리언 타입 =&gt; 문자열 타입console.log(true + ''); // &quot;true&quot;console.log(false + ''); // &quot;false&quot; 3.2 숫자 타입으로 변환숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 아래와 같다. Number 생성자 함수를 new 연산자 없이 호출하는 방법 parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능) 단항 연결 연산자를 이용하는 방법 산술 연산자를 이용하는 방법 1234567891011121314151617181920212223242526272829303132// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(Number('0')); // 0console.log(Number('-1')); // -1console.log(Number('10.53')); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(Number(true)); // 1console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)// 문자열 타입 =&gt; 숫자 타입console.log(parseInt('0')); // 0console.log(parseInt('-1')); // -1console.log(parseFloat('10.53')); // 10.53// 3. + 단항 연결 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(+'0'); // 0console.log(+'-1'); // -1console.log(+'10.53'); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(+true); // 1console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log('0' * 1); // 0console.log('-1' * 1); // -1console.log('10.53' * 1); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(true * 1); // 1console.log(false * 1); // 0 3.3 불리언 타입으로 변환불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 아래와 같다. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법 !부정 논리 연산자를 두번 사용하는 방법 1234567891011121314151617181920212223242526272829303132333435// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(Boolean('x')); // trueconsole.log(Boolean('')); // falseconsole.log(Boolean('false')); // true// 숫자 타입 =&gt; 불리언 타입console.log(Boolean(0)); // falseconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // true// null 타입 =&gt; 불리언 타입console.log(Boolean(null)); // false// undefined 타입 =&gt; 불리언 타 입console.log(Boolean(undefined)); // false// 객체 타입 =&gt; 불리언 타입console.log(Boolean({})); // trueconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(!!'x'); // trueconsole.log(!!''); // falseconsole.log(!!'false'); // true// 숫자 타입 =&gt; 불리언 타입console.log(!!0); // falseconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // true// null 타입 =&gt; 불리언 타입console.log(!!null); // false// undefined 타입 =&gt; 불리언 타입console.log(!!undefined); // false// 객체 타입 =&gt; 불리언 타입console.log(!!{}); // trueconsole.log(!![]); // true 5. 단축 평가아래 예제를 살펴보자. 1'Cat' &amp;&amp; 'Dog' // “Dog” 논리곱 연산자 &amp;&amp; 는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 대부분의 연산자가 그렇듯이 논리곱 연산자도 오른쪽에서 왼쪽으로 평가가 진행된다. 첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다. 두번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. 두번째 피연산자 ‘Dog’은 Truthy 값이므로 true로 평가된다. 이때 두개의 피연산자가 모두 true로 평가되었다. 이때 논리곱 연산의 결과를 결정한 것은 두번째 피연산자 ‘Dog’다. 논리곱 연산자 &amp;&amp; 는 논리 연산의 결과를 결정한 두번째 피연산자의 평가 결과 즉, 문자열 ‘Dog’를 그대로 반환한다. 논리합 연산자 || 도 논리곱 연산자 &amp;&amp;와 동일하게 동작한다. 1'Cat' || 'Dog' // 'Cat' 논리합 연산자 || 는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다. 대부분의 연산자가 그렇듯이 논리합 연산자도 오른쪽에서 왼쪽으로 평가가 진행된다. 첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 이 시점에 두번째 피연산자까지 평가해 보지 않아도 위 표현식을 평가할 수 있다. 논리합 연산자 || 는 논리 연산의 결과를 결정한 첫번째 피연산자의 평가 결과 즉, 문자열 ‘Cat’를 그대로 반환한다. 논리곱 연산자 &amp;&amp; 와 논리합 || 는 이와 같이 논리 평가를 결정한 피연산자의 평가 결과를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다. 단축 평가는 아래의 규칙을 따른다. 단축 평가 표현식 평가 결과 true | | anything true false | | anything anything true && anything anything false && anything false 123456789// 논리합(||) 연산자'Cat' || 'Dog' // 'Cat'false || 'Dog' // 'Dog''Cat' || false // 'Cat'// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog' // Dogfalse &amp;&amp; 'Dog' // false'Cat' &amp;&amp; false // false 단축 평가는 아래와 같은 상황에서 유용하게 사용된다. 아직 살펴보지 않은 객체와 함수에 대한 내용이 나와서 혼한스러울 수 있겠다. 지금은 아래와 같은 단축 평가의 유용한 패턴이 있다는 정도로 이해하고 넘어가도 좋다. 객체와 함수에 대해서는 해당 장에서 자세히 살펴볼 것이다. 객체가 null인지 확인하고 프로퍼티를 참조할 때 1234var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // null 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(Type Error)가 발생한다. 이때 단축 평가를 사용하면 에러를 발생시키지 않는다. 함수의 인수(argument)를 초기화할 때 12345678910111213141516// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) { str = str || ''; return str.length;}getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') { return str.length;}getStringLength(); // 0getStringLength('hi'); // 2 함수를 호출할 때 인수를 전달하지 않으면 매개변수를 undefined를 갖는다. 이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다. Referencepoiemaweb.com/js-type-coercion","link":"/2021/06/24/js-day6-type-coercion/"},{"title":"css3-day-4","text":"2.4 CSS3 Box Model박스 모델모든 HTML 요소는 Box 형태의 영역을 가지고 있다. Box 형태란 물론 사각형을 의미한다. 브라우저는 박스 모델의 크기(dimension)와 프로퍼티(색, 배경, 모양 등), 위치를 근거로 하여 렌더링을 실행한다. 웹디자인은 콘텐츠를 담을 박스 모델을 정의하고 CSS 프로퍼티를 통해 스타일(배경, 폰트와 텍스트 등)과 위치 및 정령을 지정하는 것이라고 할 수 있다. Box 모델을 구성하는 콘텐트(Content), 패딩(Padding), 테두리(Border), 마진(Margin)에 대한 설명은 아래와 같다. 명칭 설명 Content 요소의 텍스트나 이미지 등의 실제 내용이 위치하는 영역이다. width, height 프로퍼티를 갖는다. Padding 테두리(Border) 안쪽에 위치하는 요소의 내부 여백 영역이다. padding 프로퍼티 값은 패딩 영역의 두께를 의미하며 기본색은 투명(transparent)이다. 요소에 적용된 배경의 컬러, 이미지는 패딩 영역까지 적용된다. Border 테두리 영역으로 border 프로퍼티 값은 테두리의 두께를 의미한다. Margin 테두리(Border) 바깥에 위치하는 요소의 외부의 여백 영역이다. margin 프로퍼티 값은 마진 영역의 두께를 의미한다. 기본적으로 투명(transparent)하며 배경색을 지정할 수 없다. 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { /* 배경색의 지정: 콘텐츠 영역과 패딩 영역에 적용된다. */ background-color: lightgrey; /* 콘텐츠 영역의 너비 */ width: 300px; /* 패딩 영역의 두께 */ padding: 25px; /* 테두리: 두께 형태 색상 */ border: 25px solid navy; /* 마진 영역의 두께 */ margin: 25px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Box Model&lt;/h2&gt; &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 1. width / height 프로퍼티width와 height 프로퍼티는 요소의 너비와 높이를 지정하기 위해 사용된다. 이때 지정되는 요소의 너비와 높이는 콘텐츠 영역을 대상으로 한다. 이는 box-sizing 프로퍼티에 기본값인 context-box가 적용되었기 때문이다. box-sizing 프로퍼티에 border-box를 적용하면 콘텐츠 영역, padding, border가 포함된 영역을 width / height 프로퍼티의 대상으로 지정 할 수 있다. 만일 width와 height로 지정한 콘텐츠 영역보다 실제 콘텐츠가 크면 콘텐츠 영역을 넘치게 된다는 것에 유의하여야 한다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; div { width: 300px; height: 100px; background-color: cornsilk; border: 5px solid navy; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result overflow: hidden; 을 지정하면 넘친 콘텐츠를 감출 수 있다. 기본적으로 width와 height 프로퍼티는 콘텐츠 영역을 대상으로 요소의 너비와 높이를 지정하므로 박스 전체 크기는 다음과 같이 계산할 수 있다. 전체 너비width + left padding + right padding + left border + right border + left margin + right margin 전체 높이height + top padding + bottom padding + top border + bottom border + top margin + bottom margin width와 height 프로퍼티의 초기값은 auto로써 이것은 브라우저가 상황에 따라 적당한 width와 height 값을 계산할 것을 의미한다. 예를 들어 block 요소의 경우, width는 부모 요소의 100%, height는 콘텐츠의 높이(+ 약간의 여분)가 지정된다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; div { background-color: beige; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;This is a div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 명시적으로 width와 height를 지정하기 위해서는 px, % 등의 크기 단위를 사용한다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; div { background-color: beige; height: 100px; width: 50%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;This is a div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result width와 height 프로퍼티를 비롯한 모든 박스모델 관련 프로퍼티(margin, padding, border, box-sizing 등)는 상속되지 않는다. 2. margin / padding 프로퍼티margin / padding 프로퍼티는 content의 4개 방향(top, right, left, bottom)에 대하여 지정이 가능하다. 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div { border: 5px solid red; margin-top: 40px; margin-right: 30px; margin-bottom: 20px; margin-left: 10px; padding-top: 10px; padding-right: 20px; padding-bottom: 30px; padding-left: 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result -top, -right, -bottom, -left 4방향의 프로퍼티를 각각 지정하지 않고 margin, padding 1개의 프로퍼티만으로 4방향의 프로퍼티를 한번에 지정할 수 있다. 4개의 값을 지정할 때 margin: 25px 50px 75px 100px; margin-top: 25px; margin-right: 50px; margin-bottom: 75px; margin-left: 100px; 3개의 값을 지정할 때 margin: 25px 50px 75px; margin-top: 25px; margin-right: 50px; margin-left: 50px; margin-bottom: 75px 2개의 값을 지정할 때 margin: 25px 50px; margin-top: 25px; margin-bottom: 25px; margin-right: 50px; margin-left: 50px; 1개의 값을 지정할 때 margin: 25px; margin-top: 25px; margin-right: 25px; &gt; - margin-bottom: 25px; margin-left: 25px; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div { border: 5px solid red; margin: 40px 30px 20px 10px; padding: 10px 20px 30px 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result margin 프로퍼티에 auto 키워드를 설정하면 해당 요소를 브라우저 중앙에 위치 시킬 수 있다. 보다 자세한 중앙 정렬 방법에 대해서는 Horizontal &amp; Vertical Centering을 참조 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div { border: 5px solid red; width: 600px; margin: 0 auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result 요소 너비가 브라우저 너비보다 크면 가로 스크롤바가 만들어진다. 이 문제를 해결하기 위해서 max-width 프로퍼티를 사용할 수 있다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div { border: 5px solid red; max-width: 600px; margin: auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result max-width 프로퍼티를 사용하면 브라우저 너비가 요소의 너비보다 좁아질 때 자동으로 요소의 너비가 줄어든다. max-width 프로퍼티는 요소 너비의 최대값을, min-width 프로퍼티는 요소 너비의 최소값을 지정한다. 예를 들어 max-width: 300px; 의 경우, 브라우저의 너비가 300px보다 작아지면 요소 너비는 브라우저의 너비에 따라서 작아진다. min-width: 300px; 의 경우 브라우저의 너비가 300px보다 작아져도 요소 너비는 지정 너비(300px)을 유지한다. 3. border 프로퍼티3.1 border-styleborder-style 프로퍼티는 테두리 선의 스타일을 지정한다. MDN: border-style 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p { background: palegreen; padding: 10px; } p.dotted { border-style: dotted; } p.dashed { border-style: dashed; } p.solid { border-style: solid; } p.double { border-style: double; } p.groove { border-style: groove; } p.ridge { border-style: ridge; } p.inset { border-style: inset; } p.outset { border-style: outset; } p.none { border-style: none; } p.hidden { border-style: hidden; } p.mix { border-style: dotted dashed solid double; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;border-style Property&lt;/h2&gt; &lt;p class=&quot;dotted&quot;&gt;dotted&lt;/p&gt; &lt;p class=&quot;dashed&quot;&gt;dashed&lt;/p&gt; &lt;p class=&quot;solid&quot;&gt;solid&lt;/p&gt; &lt;p class=&quot;double&quot;&gt;double&lt;/p&gt; &lt;p class=&quot;groove&quot;&gt;groove&lt;/p&gt; &lt;p class=&quot;ridge&quot;&gt;ridge&lt;/p&gt; &lt;p class=&quot;inset&quot;&gt;inset&lt;/p&gt; &lt;p class=&quot;outset&quot;&gt;outset&lt;/p&gt; &lt;p class=&quot;none&quot;&gt;none&lt;/p&gt; &lt;p class=&quot;hidden&quot;&gt;hidden&lt;/p&gt; &lt;p class=&quot;mix&quot;&gt;dotted dashed solid double&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; result 프로퍼티 값의 갯수에 따라 4개 방향 (top, right, left, bottom)에 대하여 지정이 가능하다. 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p { background: palegreen; padding: 10px; } p.d1 { /* four sides */ border-style: dashed; } p.d2 { /* horizontal | vertical */ border-style: dotted solid; } p.d3 { /* top | horizontal | bottom */ border-style: hidden double dashed; } p.d4 { /* top | right | bottom | left */ border-style: none solid dotted dashed; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;d1&quot;&gt;border-style: dashed;&lt;/p&gt; &lt;p class=&quot;d2&quot;&gt;border-style: dotted solid;&lt;/p&gt; &lt;p class=&quot;d3&quot;&gt;border-style: hidden double dashed;&lt;/p&gt; &lt;p class=&quot;d4&quot;&gt;border-style: none solid dotted dashed;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; result 3.2 border-widthborder-width 프로퍼티는 테두리의 두께를 지정한다. 프로퍼티 값의 갯수에 따라 4개 방향(top, right, left, bottom)에 대하여 지정이 가능하다. border-width 프로퍼티는 border-style과 함께 사용하지 않으면 적용되지 않는다. MDN: border-width 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p { background: palegreen; padding: 10px; border-style: solid } p.one { border-width: thin; /* 1px */ } p.two { border-width: medium; /* 3px */ } p.three { border-width: thick; /* 5px */ } p.four { border-width: 15px; } p.five { border-width: 2px 10px 4px 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;border-width Property&lt;/h2&gt; &lt;p&gt;initial: 3px&lt;/p&gt; &lt;p class=&quot;one&quot;&gt;thin: 1px&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;medium: 3px&lt;/p&gt; &lt;p class=&quot;three&quot;&gt;thick: 5px&lt;/p&gt; &lt;p class=&quot;four&quot;&gt;15px&lt;/p&gt; &lt;p class=&quot;five&quot;&gt;2px 10px 4px 20px&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; result 3.3 border-colorborder-color 프로퍼티는 테두리의 색상을 지정한다. 프로퍼티 값의 갯수에 따라 4개 방향(top, right, left, bottom)에 대하여 지정이 가능하다. border-color 프로퍼티는 border-style 과 함께 사용하지 않으면 적용되지 않는다. MDN: border-color 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p { background: palegreen; padding: 10px; border-style: solid; } p.one { border-color: red; } p.two { border-color: green; } p.three { border-color: red green blue yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;border-color Property&lt;/h2&gt; &lt;p class=&quot;one&quot;&gt;border-color: red&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;border-color: green&lt;/p&gt; &lt;p class=&quot;three&quot;&gt;border-color: red green blue yellow&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; result 3.4 border-radiusborder-radius 프로퍼티는 테두리 모서리를 둥글게 표현하도록 지정한다. 프로퍼티 값은 길이를 나타내는 단위(px, em 등)와 %를 사용한다. 각각의 모서리에 border-radius 프로퍼티를 개별적으로 지정할 수도 있고 4개의 모서리를 short-hand로 한번에 지정할 수도 있다. 하나 혹은 2개의 반지름을 설정하여 각각의 모서리 굴곡을 설정할 수 있기 때문에 원 혹은 타원의 모양으로 정의가 가능하다. MDN: border-radius 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div { background: #eaeaed; color: #666; display: inline-block; width: 90px; height: 90px; line-height: 90px; margin: 0 14px; text-align: center; } .border-rounded { /* 4 꼭지점에 대해 Radius 지정 */ border-radius: 5px; } .border-circle { border-radius: 50%; } .border-football { /* top-left &amp; bottom-right | top-right &amp; bottom-left */ border-radius: 15px 75px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;border-rounded&quot;&gt;5px&lt;/div&gt; &lt;div class=&quot;border-circle&quot;&gt;50%&lt;/div&gt; &lt;div class=&quot;border-football&quot;&gt;15px 75px&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; result 모든 모서리에 동일한 둥근 모서리 설정 12345678910.border-rounded { border-radius: 20px; /* 위 코드는 아래의 shorthand이다. border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-right-radius: 20px; border-bottom-left-radius: 20px; */} 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { background: #eaeaed; color: #666; width: 150px; height: 150px; line-height: 150px; text-align: center; } .border-rounded { /* 모든 모서리를 동일하게 설정 */ border-radius: 20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;border-rounded&quot;&gt;border-radius: 20px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 각각의 모서리를 개별적으로 설정 12345678910.border-rounded { border-radius: 10px 40px 40px 10px; /* 위 코드는 아래의 shorthand이다. border-top-left-radius: 10px; border-top-right-radius: 40px; border-bottom-right-radius: 40px; border-bottom-left-radius: 10px; */} 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { background: #eaeaed; color: #666; width: 200px; height: 150px; line-height: 150px; text-align: center; } .border-rounded { /* 각각의 모서리를 개별적으로 설정 */ border-radius: 10px 40px 40px 10px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;border-rounded&quot;&gt;10px 40px 40px 10px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 두개의 반지름을 지정하여 타원형 둥근 모서리 설정 123.border-rounded { border-top-left-radius: 50px 25px;} 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { background: #eaeaed; color: #666; width: 300px; height: 150px; line-height: 150px; text-align: center; } .border-rounded { border-top-left-radius: 50px 25px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;border-rounded&quot;&gt;border-top-left-radius: 50px 25px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 각각의 모서리에 타원형 둥근 모서리 축약 설정 123.border-rounded { border-radius: 50px 50px 0 0 / 25px 25px 0 0;} 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div { background: #eaeaed; color: #666; width: 450px; height: 150px; padding: 10px; } .border-rounded { border-radius: 10px 20px 30px 40px / 5px 10px 15px 20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;border-rounded&quot;&gt; border-radius: 10px 20px 30px 40px / 5px 10px 15px 20px; &lt;ul&gt; &lt;li&gt;border-top-left-radius: 10px 5px;&lt;/li&gt; &lt;li&gt;border-top-right-radius: 20px 10px;&lt;/li&gt; &lt;li&gt;border-bottom-right-radius: 30px 15px;&lt;/li&gt; &lt;li&gt;border-bottom-left-radius: 40px 20px;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 3.5 borderborder 프로퍼티는 border-width, border-style, border-color를 한번에 설정하기 위한 shorthand 프로퍼티이다. MDN: Border Shorthand 12/* Syntax */border: border-width border-style border-color; 1234p { /* border-width border-style border-color */ border: 5px solid red;} 4. box-sizing 프로퍼티box-sizing 프로퍼티는 width, height 프로퍼티의 대상 영역을 변경할 수 있다. box-sizing 프로퍼티의 기본값은 content-box이다. 이는 width, height 프로퍼티의 대상 영역이 content 영역을 의미한다. box-sizing 프로퍼티의 값을 border-box로 지정하면 마진을 제외한 박스 모델 전체를 width, height 프로퍼티의 대상 영역으로 지정할 수 있어서 CSS Layout을 직관적으로 사용할 수 있게 한다. 키워드 설명 content-box width, height 프로퍼티 값은 content 영역을 의미한다. (기본값) border-box width, height 프로퍼티 값은 content 영역, padding, border가 포함된 값을 의미한다. 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .content-box { width: 600px; border: 10px solid; padding: 50px; margin: 50px; background-color: red; } .border-box { box-sizing: border-box; width: 600px; border: 10px solid; padding: 50px; margin: 50px; background-color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;content-box&quot;&gt;content-box&lt;/div&gt; &lt;div class=&quot;border-box&quot;&gt;border-box&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result box-sizing 프로퍼티는 상속되지 않는다. 따라서 box-sizing 프로퍼티를 사용하도록 초기화하려면 아래와 같이 정의한다. 123456html { box-sizing: border-box;}*, *:before, *:after { box-sizing: inherit;} Referencepoiemaweb.com/css3-box-model www.w3schools.com/css/css_boxmodel.asp wikipedia.org","link":"/2021/04/27/css3-day-4/"},{"title":"css3-day-2","text":"CSS3 SelectorSelectorCSS(Cascading Style Sheets)는 HTML 요소(Element)의 style(design, layout etc)을 정의한다. 그리하려면 HTML이 존재하여야 하고 또한 style을 적용하고자하는 HTML 요소를 특정할 필요가 있다. 이러한 목적으로 사용되는 것이 셀렉터(Selector)이다. 즉, style을 적용하고자 하는 HTML 요소를 셀렉터로 특정하고 선택된 요소에 스타일을 정의하는 것이다. 출처: https://www.w3schools.com/css/css_syntax.asp 12345678910111213 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; h1 { color: red; } p { color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;This paragraph is styled with CSS.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Hello World! This paragraph is styled with CSS. 복수개의 셀렉터를 연속하여 지정할 수 있으며 쉼표(,)로 구분한다. 1h1, p { color: red; } 1. 전체 셀렉터 (Universal Selector) 패턴 Description * HTML 문서 내의 모든 요소를 선택한다. html 요소를 포함한 모든 요소가 선택된다. (head 요소도 포함된다) 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* 모든 요소를 선택 */ * { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;div&gt; &lt;p&gt;paragraph 1&lt;/p&gt; &lt;p&gt;paragraph 2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;paragraph 3&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 2. 태그 셀렉터 (Type Selector) 패턴 Description 태그명 지정된 태그명을 가지는 요소를 선택한다. 지정된 태그명을 가지는 요소를 선택한다. 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* 모든 p 태그 요소를 선택 */ p { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;div&gt; &lt;p&gt;paragraph 1&lt;/p&gt; &lt;p&gt;paragraph 2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;paragraph 3&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 3. ID 셀렉터 (ID Selector) 패턴 Description #id 어트리뷰트 값 id 어프리뷰트 값을 지정하여 일치하는 요소를 선택한다. id 어트리뷰트 값은 중복될 수 없는 유일한 값이다. 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* id 어트리뷰트 값이 p1인 요소를 선택 */ #p1 { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;div class=&quot;container&quot;&gt; &lt;p id=&quot;p1&quot;&gt;paragraph 1&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;paragraph 2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;paragraph 3&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 4. 클래스 셀렉터 (Class Selector) 패턴 Description .class 어트리뷰트 값 class 어트리뷰트 값을 지정하여 일치하는 요소를 선택한다. class 어트리뷰트 값은 중복될 수 있다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* class 어트리뷰트 값이 container인 모든 요소를 선택 */ /* color 어트리뷰트는 자식 요소에 상속된다. */ .container { color: red; } /* not supported in IE */ #p2 { color: initial; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;div class=&quot;container&quot;&gt; &lt;p id=&quot;p1&quot;&gt;paragraph 1&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;paragraph 2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;paragraph 3&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result HTML 요소에 class 어트리뷰트 값은 공백으로 구분하여 여러 개 지정할 수 있다. 아래와 같이 클래스 셀렉터를 사용하여 미리 스타일을 정의해 두고, HTML 요소는 이미 정의되어 있는 클래스를 지정하는 것으로 필요한 스타일을 지정할 수 있다. 이것은 재사용의 측면에서 유용하다. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* class 어트리뷰트 값이 text-center인 모든 요소를 선택 */ .text-center { text-align: center; } /* class 어트리뷰트 값이 text-large인 모든 요소를 선택 */ .text-large { font-size: 200%; } /* class 어트리뷰트 값이 text-red인 모든 요소를 선택 */ .text-red { color: red; } /* class 어트리뷰트 값이 text-blue인 모든 요소를 선택 */ .text-blue { color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;text-center&quot;&gt;Center&lt;/p&gt; &lt;p class=&quot;text-large text-red&quot;&gt;Large Red&lt;/p&gt; &lt;p class=&quot;text-center text-large text-blue&quot;&gt;Center Large Blue&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 5. 어트리뷰트 셀렉터 (Attribute Selector) 패턴 Description 셀렉터[어트리뷰트] 지정된 어트리뷰트를 갖는 모든 요소를 선택한다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* a 요소 중에 href 어트리뷰트를 갖는 모든 요소 */ a[href] { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;http://www.poiemaweb.com&quot;&gt;poiemaweb.com&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.google.com&quot; target=&quot;_blank&quot;&gt;google.com&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.naver.com&quot; target=&quot;_top&quot;&gt;naver.com&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; result 패턴 Description 셀렉터[어트리뷰트=”값”] 지정된 어트리뷰트를 가지며 지정된 값과 어트리뷰트의 값이 일치하는 모든 요소를 선택한다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* a 요소 중에 target 어트리뷰트의 값이 &quot;_blank&quot;인 모든 요소 */ a[target=&quot;_blank&quot;] { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;https://wontaejang.github.io&quot;&gt;wontaejang.github.io&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.google.com&quot; target=&quot;_blank&quot;&gt;google.com&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.naver.com&quot; target=&quot;_top&quot;&gt;naver.com&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; result 패턴 Description 셀렉터[어트리뷰트~=”값”] 지정된 어트리뷰트의 값이 지정된 값을 (공백으로 분리된) 단어로 포함하는 요소를 선택한다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* h1 요소 중에 title 어트리뷰트 값에 &quot;first&quot;를 단어로 포함하는 요소 */ h1[title~=&quot;first&quot;] { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 title=&quot;heading first&quot;&gt;Heading first&lt;/h1&gt; &lt;h1 title=&quot;heading-first&quot;&gt;Heading-first&lt;/h1&gt; &lt;h1 title=&quot;heading second&quot;&gt;Heading second&lt;/h1&gt; &lt;h1 title=&quot;heading third&quot;&gt;Heading third&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; result 패턴 Description 셀렉터[어트리뷰트|=”값”] 지정된 어트리뷰트의 값과 일치하거나 지정 어트리뷰트 값 뒤 연이은 하이픈(“값-“)으로 시작하는 요소를 선택한다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* p 요소 중에 lang 어트리뷰트 값이 &quot;en&quot;과 일치하거나 &quot;en-&quot;로 시작하는 요소 */ p[lang|=&quot;en&quot;] { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p lang=&quot;en&quot;&gt;Hello!&lt;/p&gt; &lt;p lang=&quot;en-us&quot;&gt;Hi!&lt;/p&gt; &lt;p lang=&quot;en-gb&quot;&gt;Ello!&lt;/p&gt; &lt;p lang=&quot;us&quot;&gt;Hi!&lt;/p&gt; &lt;p lang=&quot;no&quot;&gt;Hei!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 패턴 Description 셀렉터[어트리뷰트^=”값”] 지정된 어트리뷰트 값으로 시작하는 요소를 선택한다. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* a 요소 중에 href 어트리뷰트 값이 &quot;https://&quot;로 시작하는 요소 */ a[href^=&quot;https://&quot;] { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;https://www.test.com&quot;&gt;https://www.test.com&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.test.com&quot;&gt;http://www.test.com&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; result 패턴 Description 셀렉터[어트리뷰트$=”값”] 지정된 어트리뷰트 값으로 끝나는 요소를 선택한다. result 패턴 Description 셀렉터[어트리뷰트*=”값”] 지정된 어트리뷰트 값을 포함하는 요소를 선택한다. 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* div 요소 중에서 class 어트리뷰트 값에 &quot;test&quot;를 포함하는 요소 */ div[class*=&quot;test&quot;] { color: red; } /* div 요소 중에서 class 어트리뷰트 값에 &quot;test&quot;를 단어로 포함하는 요소 */ div[class~=&quot;test&quot;] { background-color: yellow; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first_test&quot;&gt;The first div element.&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;The second div element.&lt;/div&gt; &lt;div class=&quot;test&quot;&gt;The third div element.&lt;/div&gt; &lt;p class=&quot;test&quot;&gt;This is some text in a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 6. 복합 셀렉터 (Combinator)6.1 후손 셀렉터 (Descendant Combinator)자신의 1level 상위에 속하는 요소를 부모 요소, 1level 하위에 속하는 요소를 자손 요소(자식 요소) 라 한다. 자신보다 n level 하위에 속하는 요소는 후손 요소(하위 요소) 라 한다. 후손 셀렉터는 셀렉터A의 모든 후손(하위) 요소 중 셀렉터B와 일치하는 요소를 선택한다. 1셀렉터A 셀렉터B 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* div 요소의 후손요소 중 p 요소 */ div p { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;div&gt; &lt;p&gt;paragraph 1&lt;/p&gt; &lt;p&gt;paragraph 2&lt;/p&gt; &lt;span&gt;&lt;p&gt;paragraph 3&lt;/p&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;paragraph 4&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 6.2 자식 셀렉터 (Child Combinator)자손 셀렉터는 셀렉터A의 모든 자식 요소중 셀렉터B와 일치하는 요소를 선택한다. 1셀렉터A &gt; 셀렉터B 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* div 요소의 자식요소 중 p 요소 */ div &gt; p { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;div&gt; &lt;p&gt;paragraph 1&lt;/p&gt; &lt;p&gt;paragraph 2&lt;/p&gt; &lt;span&gt;&lt;p&gt;paragraph 3&lt;/p&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;paragraph 4&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result 6.3 형제(동위) 셀렉터 (Sibling Combinator)형제(동위) 셀렉터는 형제 관계(동위 관계)에서 뒤에 위치하는 요소를 선택할 때 사용한다. 6.3.1 인접 형제 셀렉터 (Adjacent Sibling Combinator)셀렉터A의 형제 요소 중 셀렉터A 바로 뒤에 위치하는 셀렉터B 요소를 선택한다. A와 B 사이에 다른요소가 존재하면 선택되지 않는다. 1셀렉터A + 셀렉터B 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택한다. */ p + ul { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;A div element.&lt;/div&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The first paragraph.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Another list&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; result 6.3.2 일반 형제 셀렉터 (General Sibling Combinator)셀렉터A의 형제 요소 중 셀렉터A 뒤에 위치하는 셀렉터B 요소를 모두 선택한다. 1셀렉터A ~ 셀렉터B 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택한다.*/ p ~ ul { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;A div element.&lt;/div&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The first paragraph.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Another list&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; result 7. 가상 클래스 셀렉터 (Pseudo-Class Selector)가상 클래스는 요소의 특정 상태에 따라 스타일을 정의할 때 사용된다. 특정 상태란 예를 들어 다음과 같다. 마우스가 올라와 있을때 링크를 방문했을 때와 아직 방문하지 않았을 때 포커스가 들어와 있을 때 이러한 특정 상태에는 원래 클래스가 존재하지 않지만 가상 클래스를 임의로 지정하여 선택하는 방법이다. 가상 클래스는 마침표(.) 대신 콜론(:)을 사용한다. CSS 표준에 의해 미리 정의된 이름이 있기 때문에 임의의 이름을 사용할 수 없다. 123selector:pseudo-class { property: value;} 다음은 div 요소가 hover 상태일 때 (마우스가 올라와 있을 때) background-color를 yellow로 지정하는 예이다. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* a 요소가 hover 상태일 때 */ a:hover { color: red; } /* input 요소가 focus 상태일 때 */ input:focus { background-color: yellow; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#&quot;&gt;Hover me&lt;/a&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;text&quot; placeholder=&quot;focus me&quot;&gt;&lt;/body&gt;&lt;/html&gt; result 7.1 링크 셀렉터(Link pseudo-classes), 동적 셀렉터(User action pseudo-classes) pseudo-class Description :link 셀렉터가 방문하지 않은 링크일 때 :visited 셀렉터가 방문한 링크일 때 :hover 셀렉터에 마우스가 올라와 있을 때 :active 셀렉터가 클릭된 상태일 때 :focus 셀렉터에 포커스가 들어와 있을 때 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* a 요소가 방문하지 않은 링크일 때 */ a:link { color: orange; } /* a 요소가 방문한 링크일 때 */ a:visited { color: green; } /* a 요소에 마우스가 올라와 있을 때 */ a:hover { font-weight: bold; } /* a 요소가 클릭된 상태일 때 */ a:active { color: blue; } /* text input 요소와 password input 요소에 포커스가 들어와 있을 때 */ input[type=text]:focus, input[type=password]:focus { color: red; } &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;This is a link&lt;/a&gt;&lt;br&gt; &lt;input type=&quot;text&quot; value=&quot;I'll be red when focused&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; value=&quot;I'll be red when focused&quot;&gt;&lt;/body&gt;&lt;/html&gt; result 7.2 UI 요소 상태 셀렉터(UI element state pseudo-classes) pseudo-class Description :checked 셀렉터가 체크 상태일 때 :enabled 셀렉터가 사용 가능한 상태일 때 :disabled 셀렉터가 사용 불가능한 상태일 때 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* input 요소가 사용 가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 */ input:enabled + span { color: blue; } /* input 요소가 사용 불가능한 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 */ input:disabled + span { color: gray; text-decoration: line-through; } /* input 요소가 체크 상태일 때, input 요소 바로 뒤에 위치하는 인접 형제 span 요소를 선택 */ input:checked + span { color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;radio&quot; checked=&quot;checked&quot; value=&quot;male&quot; name=&quot;gender&quot;&gt; &lt;span&gt;Male&lt;/span&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; value=&quot;female&quot; name=&quot;gender&quot;&gt; &lt;span&gt;Female&lt;/span&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; value=&quot;neuter&quot; name=&quot;gender&quot; disabled&gt; &lt;span&gt;Neuter&lt;/span&gt;&lt;hr&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;bicycle&quot;&gt; &lt;span&gt;I have a bicycle&lt;/span&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;car&quot;&gt; &lt;span&gt;I have a car&lt;/span&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; value=&quot;motorcycle&quot; disabled&gt; &lt;span&gt;I have a motorcycle&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; result 7.3 구조 가상 클래스 (Structural pseudo-classes) pseudo-class Description :first-child 셀렉터에 해당하는 모든 요소 중 첫번째 자식인 요소를 선택한다. :last-child 셀렉터에 해당하는 모든 요소 중 마지막 자식인 요소를 선택한다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* p 요소 중에서 첫번째 자식을 선택 */ p:first-child { color: red; } /* p 요소 중에서 마지막 자식을 선택 */ /* body 요소의 두번째 p 요소는 마지막 자식 요소가 아니다. body 요소의 마지막 자식 요소는 div 요소이다. */ p:last-child { color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This paragraph is the first child of its parent (body).&lt;/p&gt; &lt;h1&gt;Welcome to My Homepage&lt;/h1&gt; &lt;p&gt;This paragraph is not the first child of its parent.&lt;/p&gt; &lt;div&gt; &lt;p&gt;This paragraph is the first child of its parent (div).&lt;/p&gt; &lt;p&gt;This paragraph is not the first child of its parent.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result pseudo-class Description :nth-child(n) 셀렉터에 해당하는 모든 요소 중 앞에서 n 번째 자식인 요소를 선택한다. :nth-last-child(n) 셀렉터에 해당하는 모든 요소중 뒤에서 n번째 자식인 요소를 선택한다. n은 0부터 시작하는 정수이다.|n|2n+1|2n-1|3n-2|3n+1|-n+5||-|—-|—-|—-|—-|—-||0|1|-1|-2|1|5||1|3|1|1|4|4||2|5|3|4|7|3||3|7|5|7|10|2||4|9|7|10|13|1||5|11|9|13|16|0| 0과 음수는 생략되기 때문에 2n+1과 2n-1, 3n-2와 3n+1은 결과적으로 같은 수열을 생성한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* ol 요소의 자식 요소인 li 요소 중에서 짝수번째 요소만을 선택 */ ol &gt; li:nth-child(2n) { color: orange; } /* ol 요소의 자식 요소인 li 요소 중에서 홀수번째 요소만을 선택 */ ol &gt; li:nth-child(2n+1) { color: green; } /* ol 요소의 자식 요소인 li 요소 중에서 첫번쨰 요소만을 선택 */ ol &gt; li:first-child { color: red; } /* ol 요소의 자식 요소인 li 요소 중에서 마지막 요소만을 선택 */ ol &gt; li:last-child { color: blue; } /* ol 요소의 자식 요소인 li 요소 중에서 4번째 요소 요소만을 선택 */ ol &gt; li:nth-child(4) { background: brown; } /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 홀수번째 요소만을 선택 */ ul &gt; :nth-last-child(2n+1) { color: red; } /* ul 요소의 모든 자식 요소 중에서 뒤에서부터 시작하여 짝수번째 요소만을 선택 */ ul &gt; :nth-last-child(2n) { color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ol&gt; &lt;li&gt;Espresso&lt;/li&gt; &lt;li&gt;Americano&lt;/li&gt; &lt;li&gt;Caffe Latte&lt;/li&gt; &lt;li&gt;Caffe Mocha&lt;/li&gt; &lt;li&gt;Caramel Latte&lt;/li&gt; &lt;li&gt;Cappuccino&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;Espresso&lt;/li&gt; &lt;li&gt;Americano&lt;/li&gt; &lt;li&gt;Caffe Latte&lt;/li&gt; &lt;li&gt;Caffe Mocha&lt;/li&gt; &lt;li&gt;Caramel Latte&lt;/li&gt; &lt;li&gt;Cappuccino&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; result pseudo-class Description :first-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 요소를 선택한다. :last-of-type 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 마지막에 등장하는 요소를 선택한다. :nth-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식요소 중 앞에서 n번째에 등장하는 요소를 선택한다. :nth-last-of-type(n) 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중 뒤에서 n번째에 등장하는 요소를 선택한다. 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* p 요소의 부모 요소의 자식 요소 중 첫번째 등장하는 p 요소 */ p:first-of-type { color: red; } /* p 요소의 부모 요소의 자식 요소 중 마지막 등장하는 p 요소 */ p:last-of-type { color: blue; } /* p 요소의 부모 요소의 자식 요소 중 앞에서 2번째에 등장하는 p 요소 */ p:nth-of-type(2) { color: green; } /* p 요소의 부모 요소의 자식 요소 중 뒤에서 2번째에 등장하는 p 요소 */ p:nth-last-of-type(2) { color: orange;} /* p 요소 중에서 첫번째 자식을 선택 */ p:first-child { background: brown;} &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;p&gt;The first paragraph.&lt;/p&gt; &lt;p&gt;The second paragraph.&lt;/p&gt; &lt;p&gt;The third paragraph.&lt;/p&gt; &lt;p&gt;The fourth paragraph.&lt;/p&gt; &lt;div&gt; &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;p&gt;The first paragraph.&lt;/p&gt; &lt;p&gt;The second paragraph.&lt;/p&gt; &lt;p&gt;The third paragraph.&lt;/p&gt; &lt;p&gt;The fourth paragraph.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 7.4 부정 셀렉터(Negation pseudo-class) pseudo-class Description :not(셀렉터) 셀렉터에 해당하지 않는 모든 요소를 선택한다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* input 요소 중에서 type 어트리뷰트의 값이 password가 아닌 요소를 선택 */ input:not([type=password]) { background: yellow; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;Text input&quot;&gt; &lt;input type=&quot;email&quot; value=&quot;email input&quot;&gt; &lt;input type=&quot;password&quot; value=&quot;Password input&quot;&gt;&lt;/body&gt;&lt;/html&gt; result 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; body { margin: 0; } div { float: left; width: 32%; height: 200px; background-color: red; /* margin-bottom: 2%; */ color: #fff; font-size: 3em; line-height: 200px; text-align: center; } /* div 요소 중에서 1, 4, 7...번째 등장하는 요소가 아닌 요소만을 선택 */ /* 1, 4, 7... : 공차가 3인 등차수열 */ div:not(:nth-of-type(3n+1)) { margin-left: 2%; } /* div 요소 중에서 4번째 이후 등장하는 요소가 아닌 요소만을 선택 */ div:not(:nth-of-type(n+4)) { margin-bottom: 2%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; result 7.5 정합성 체크 셀렉터(validity pseudo-class) pseudo-class Description :valid(셀렉터) 정합성 검즘이 성공한 input 요소 또는 form 요소를 선택한다. :invaild(셀렉터) 정합성 검증이 실패한 input 요소 또는 form 요소를 선택한다. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; input[type=&quot;text&quot;]:valid { background-color: greenyellow; } input[type=&quot;text&quot;]:invalid { background-color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;label&gt;입력값이 반드시 필요 &lt;input type=&quot;text&quot; required&gt; &lt;/label&gt; &lt;br&gt; &lt;label&gt;특수문자를 포함하지 않는 4자리 문자 또는 숫자 &lt;input type=&quot;text&quot; value=&quot;ab1!&quot; pattern=&quot;[a-zA-Z0-9]{4}&quot; required&gt; &lt;/label&gt; &lt;br&gt; &lt;label&gt;핸드폰 번호 형식 &lt;input type=&quot;text&quot; value=&quot;010-1111-2222&quot; pattern=&quot;^\\d{3}-\\d{3,4}-\\d{4}$&quot; required&gt; &lt;/label&gt;&lt;/body&gt;&lt;/html&gt; result Browser Support 8. 가상 요소 셀렉터(Pseudo-Element Selector)가상 요소는 요소의 특정 부분에 스타일을 적용하기 위하여 사용된다. 특정 부분이란 예를 들어 다음과 같다. 요소 콘텐츠의 첫글자 또는 첫줄 요소 콘텐츠의 앞 또는 뒤 가상 요소에는 두개의 콜론(::)을 사용한다. CSS 표준에 의해 미리 정의된 이름이 있기 때문에 임의의 이름을 사용할 수 없다. 123selector::pseudo-element { property:value;} pseudo-element Description ::first-letter 콘텐츠의 첫클자를 선택한다. ::first-line 콘텐츠의 첫줄을 선택한다. 블록 요소에만 적용할 수 있다. ::after 콘텐츠의 뒤에 위치하는 공간을 선택한다. 일반적으로 content 프로퍼티와 함께 사용된다. ::before 콘텐츠의 앞에 위치하는 공간을 선택한다. 일반적으로 content 프로퍼티와 함께 사용된다. ::selection 드래그한 콘첸츠를 선택한다. iOS Safari 등 일부 브라우저에서 동작 않는다. 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; /* p 요소 콘텐츠의 첫글자를 선택 */ p::first-letter { font-size: 3em; } /* p 요소 콘텐츠의 첫줄을 선택 */ p::first-line { color: red; } /* h1 요소 콘텐츠의 앞 공간에 content 어트리뷰트 값을 삽입한다 */ h1::before { content: &quot; HTML!!! &quot;; color: blue; } /* h1 요소 콘텐츠의 뒷 공간에 content 어트리뷰트 값을 삽입한다 */ h1::after { content: &quot; CSS3!!!&quot;; color: red; } /* 드래그한 콘텐츠를 선택한다 */ ::selection { color: red; background: yellow; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Explicabo illum sunt distinctio sed, tempore, repellat rerum et ea laborum voluptatum! Quisquam error fugiat debitis maiores officiis, tenetur ullam amet in!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; result Referencepoiemaweb.com/css3-selector W3C CSS Document CSS selectors","link":"/2021/04/22/css3-day-2/"},{"title":"py-day4-comments","text":"Python Comments 주석은 Python 코드를 설명하는 데 사용할 수 있습니다. 코드를 더 읽기 쉽게 만들기 위해 주석을 사용합니다. 코드를 테스트 할 때 실행을 방지하기 위해 주석을 사용할 수 있습니다. 주석 생성(Creating a Comment)주석은 #으로 시작하고 Python은 해당 줄을 무시합니다. example12#This is a comment.print(&quot;Hello, World!&quot;) 주석은 줄 끝에 배치할 수 있으며 Python은 나머지 줄을 무시합니다. example1print(&quot;Hello, World!&quot;) #This is a comment. 주석은 코드를 설명하는 텍스트 일 필요는 없으면 Python이 해당 코드를 실행하지 못하도록 방지하는 데 사용할 수 있습니다. example12#print(&quot;Hello, World!&quot;)print(&quot;Cheers, Mate!&quot;) Referencew3schools python","link":"/2021/07/01/py-day4-comments/"},{"title":"py-day3-syntax-2","text":"Python Syntax 2변수(Variables)python에서는 값을 할당하면 변수가 생성됩니다. example12x = 5y = &quot;Hello, World!&quot; 파이썬에서는 변수를 선언하는 명령이 없습니다. Python Variable 에서 변수에 대해 자세히 알아보겠습니다. 주석(Comments)주석은 #으로 시작하고 해당 줄은 코드에 영향을 주지 않습니다. example12#This is a comment.print(&quot;Hello, World!&quot;) Referencew3schools python","link":"/2021/07/01/py-day3-syntax-2/"},{"title":"py-day5-variables-1","text":"Python Variables 1 변수는 데이터 값을 저장하기위한 컨테이너. Variables are containers for storing data values. 변수 생성Python에서는 변수를 선언하는 명령이 없습니다.변수는 값을 처음 할당하는 순간 생성됩니다. example1234x = 5y = &quot;John&quot;print(x)print(y) 변수는 특정 data type으로 선언 할 필요가 없으며 설정된 후에는 data type을 변경할 수도 있습니다. example123x = 4 # x is of type intx = &quot;Sally&quot; # x is now of type strprint(x) Casting변수에 data type을 특정하고 싶다면 아래와 같은 Casting 방법이 있습니다. example123x = str(3) # x will be '3'y = int(3) # y will be 3z = float(3) # z will be 3.0 Get the Type변수의 data type을 알고싶다면 type() 함수를 사용하면 됩니다. example1234x = 5y = &quot;John&quot;print(type(x)) # class &lt;'int'&gt;print(type(y)) # class &lt;'str'&gt; data type, casting이 궁금하시면 다음 수업을 기대하세요 (찡긋) 작은 따옴표 큰따옴표문자열 변수는 작은 따옴표 또는 큰 따옴표를 사용하여 선언할 수 있습니다. example123x = &quot;John&quot;# is the same asx = 'John' 대소문자 구분변수 이름은 대소 문자를 구분합니다. example123456789a = 4A = &quot;Sally&quot;#A will not overwrite aB = &quot;sally&quot;if A == B: print(&quot;A and B are equal&quot;)else: print(&quot;A and B are not equal&quot;) Referencew3schools python","link":"/2021/07/01/py-day5-variables-1/"},{"title":"py-day6-variables-2","text":"Python Variables 2변수(Varialble) 값이 저장된 메모리 공간의 주소를 가르키는 식별자(identifier) 1. 변수 명변수 명은 짧게 지을수도 있고 상세하게 지을수도 있습니다. Python 변수 명에 대한 규칙: 변수 명은 문자 또는 ‘_’ 로 시작해야 합니다. (ex sort, _sort) 변수 명은 숫자로 시작할 수 없습니다. 변수 명에는 영숫자 문자와 밑줄 (Az, 0-9 및 _) 만 포함 할 수 있습니다. (한글도 가능) 변수 이름은 대소 문자를 구분합니다. example123456myvar = &quot;John&quot;my_var = &quot;John&quot;_my_var = &quot;John&quot;myVar = &quot;John&quot;MYVAR = &quot;John&quot;myvar2 = &quot;John&quot; example잘못된 변수 이름: 1232myvar = &quot;John&quot;my-var = &quot;John&quot;my var = &quot;John&quot; 2. 여러 단어로 변수명 짓기둘 이상의 단어가 포함된 변수 명은 읽기 어려울수 있습니다.여러 단어가 들어간 변수 명을 읽기 쉽게 만드는 기술을 소개합니다. Camel Case첫 번째 단어를 제외한 각 단어는 대문자로 시작합니다. 1myVariableName = &quot;John&quot; Pascal Case각 단어는 대문자로 시작합니다. 1MyVariableName = &quot;John&quot; Snake Case각 단어는 밑줄 문자로 구분됩니다. 1my_variable_name = &quot;John&quot; 3. 여러 값 활당 (Assign Multiple Values)Python을 사용하면 한 줄로 여러 변수에 값을 할당 할 수 있습니다. example1234x, y, z = &quot;Orange&quot;, &quot;Banana&quot;, &quot;Cherry&quot;print(x)print(y)print(z) 참고: 변수 수가 값의 수와 일치하지 않으면 오류 발생 4. 여러 변수에 대한 하나의 값 (One Value to Multiple Variables)한 줄에 여러 변수에 동일한 값을 할당 할 수 있습니다 . example1234x = y = z = &quot;Orange&quot;print(x)print(y)print(z) 5. Unpack a Collectionlist, tuple등의 collection이 있을 경우 Python을 사용하면 변수로 추출 할 수 있습니다. 이것을 Unpack이라고 합니다. example12345fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]x, y, z = fruitsprint(x)print(y)print(z) Unpack Tuples 챕터에서 Unpack에 대해서 더 자세히 알아보겠습니다. 6. 변수 출력Python print문은 종종 변수를 출력하는 데 사용됩니다.텍스트와 변수를 결합하기 위해 Python은 다음 + 문자를 사용합니다. example12x = &quot;awesome&quot;print(&quot;Python is &quot; + x) +문자를 사용하여 다른 변수에 변수를 추가 할 수도 있습니다. example123x = 5y = 10print(x + y) 문자열과 숫자를 결합하려고하면 Python에서 오류가 발생합니다. example123x = 5y = &quot;John&quot;print(x + y) Referencew3schools python","link":"/2021/07/02/py-day6-variables-2/"},{"title":"py-day7-variables-3","text":"Python Variables 3변수(Varialble) 값이 저장된 메모리 공간의 주소를 가르키는 식별자(identifier) 1. 전역 변수(Global Variables)이때까지 보았던 예제들과 같이 함수 외부에서 생성 된 변수를 전역 변수라고 합니다. 전역 변수는 함수 내부와 외부 모두에서 사용할 수 있습니다. example함수 외부에서 변수를 만들고 함수 내부에서 사용 123456x = &quot;awesome&quot;def myfunc(): print(&quot;Python is &quot; + x)myfunc() 함수 내에서 동일한 이름으로 변수를 생성하면 변수는 지역 변수가되며 함수 내에서만 사용할 수 있습니다. 동일한 이름의 전역 변수는 원래 값으로 전역 및 원래 상태로 유지됩니다. example전역 변수와 이름이 같은 함수 내부에 변수를 만듭니다. 123456789x = &quot;awesome&quot;def myfunc(): x = &quot;fantastic&quot; print(&quot;Python is &quot; + x)myfunc()print(&quot;Python is &quot; + x) 2. global 키워드일반적으로 함수 내부에 변수를 만들면 해당 변수는 로컬(지역)이며 해당 함수 내에서만 사용할 수 있습니다. 함수 내에 전역 변수를 만들려면 global키워드를 사용할 수 있습니다 . exampleglobal키워드 를 사용하는 경우 변수는 전역 범위에 속합니다. 1234567def myfunc(): global x x = &quot;fantastic&quot;myfunc()print(&quot;Python is &quot; + x) 함수 내에서 전역 변수를 변경 하려면 global키워드를 사용하면 됩니다. example함수 내 전역 변수의 값을 변경하려면 global키워드 를 사용하여 변수를 참조하십시오. 123456789x = &quot;awesome&quot;def myfunc(): global x x = &quot;fantastic&quot;myfunc()print(&quot;Python is &quot; + x) Referencew3schools python","link":"/2021/07/02/py-day7-variables-3/"},{"title":"py-day8-datatypes","text":"Python DataTypes1. 내장 되어 있는 데이터 타입(Built-in Data Types)프로그래밍에서 데이터 유형은 중요한 개념입니다. 변수는 다른 유형의 데이터를 저장할 수 있으며 다른 유형은 다른 일을 할 수 있습니다. Python에는 기본적으로 다음과 같은 카테고리에 다음 데이터 유형이 내장되어 있습니다. data type Text Type str Numeric Types int, float, complex Sequence Types list, tuple, range Mapping Type dict Set Types set, frozenset Boolean Type bool Binary Types bytes, bytearray, memoryview 2. 데이터 타입을 확인해 봅시다.type()함수 를 사용하여 모든 개체의 데이터 유형을 가져올 수 있습니다. example12x = 5print(type(x)) 3. 데이터 타입 설정Python에서는 변수에 값을 할당 할 때 데이터 유형이 설정됩니다. Example Data Type x = “Hello World” str x = 20 int x = 20.5 float x = 1j complex x = [“apple”, “banana”, “cherry”] list x = (“apple”, “banana”, “cherry”) tuple x = range(6) range x = {“name” : “John”, “age” : 36} dict x = {“apple”, “banana”, “cherry”} set x = frozenset({“apple”, “banana”, “cherry”}) frozenset x = True bool x = b”Hello” bytes x = bytearray(5) bytearray x = memoryview(bytes(5)) memoryview 4. 특정 데이터 타입 설정데이터 유형을 지정하려는 경우 다음 생성자 함수를 사용할 수 있습니다. Example Data Type x = str(“Hello World”) str x = int(20) int x = float(20.5) float x = complex(1j) complex x = list((“apple”, “banana”, “cherry”)) list x = tuple((“apple”, “banana”, “cherry”)) tuple x = range(6) range x = dict(name=”John”, age=36) dict x = set((“apple”, “banana”, “cherry”)) set x = frozenset({“apple”, “banana”, “cherry”}) frozenset x = bool(5) bool x = bytes(5) bytes x = bytearray(5) bytearray x = memoryview(bytes(5)) memoryview Referencew3schools python","link":"/2021/07/02/py-day8-datatypes/"},{"title":"py-exercises-1","text":"Exercise 1변수 명을 x로 만들고 값 50을 할당하시오. Exercise 2변수 x, y를 사용하여 “5 + 10”을 출력하시오. Exercise 3변수 z를 생성하여 x + y를 z변수에 할당 후 출력하시오. 12x = 5y = 10 Exercise 4변수 명에서 잘못된 문자를 제거하십시오. 12my-first_name = &quot;John&quot; Exercise 5하나의 코드 줄에서 세 변수 모두에 동일한 값을 할당하려면 올바른 구문을 삽입하십시오. 1x ? y ? z &quot;Orange&quot; Exercise 6변수 x가 전역 범위에 속하도록 올바른 키워드를 삽입하십시오. 123def myfunc(): ??? x x = &quot;fantastic&quot;","link":"/2021/07/02/py-exercises-1/"},{"title":"py-exercises-2","text":"Exercise 1아래 코드의 변수 x의 data type을 확인합니다. 12x = 5print(type(x)) Exercise 2아래 코드의 변수 x의 data type을 확인합니다. 12x = &quot;Hello World&quot;print(type(x)) Exercise 3아래 코드의 변수 x의 data type을 확인합니다. 12x = 20.5print(type(x)) Exercise 4아래 코드의 변수 x의 data type을 확인합니다. 12x = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(type(x)) Exercise 5아래 코드의 변수 x의 data type을 확인합니다. 12x = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)print(type(x)) Exercise 6아래 코드의 변수 x의 data type을 확인합니다. 12x = {&quot;name&quot; : &quot;John&quot;, &quot;age&quot; : 36}print(type(x)) Exercise 7아래 코드의 변수 x의 data type을 확인합니다. 12x = Trueprint(type(x))","link":"/2021/07/02/py-exercises-2/"},{"title":"py-day10-string-1","text":"Python String1. 문자열(strings) 파이썬의 문자열은 작은 따옴표 또는 큰 따옴표로 묶여 있습니다. ‘hello’ 는 “hello” 와 동일 합니다. print()함수를 사용하여 문자열 리터럴을 표시 할 수 있습니다 . example12print(&quot;Hello&quot;)print('Hello') 2. 변수에 문자열 할당 Assigning a string to a variable is done with the variable name followed by an equal sign and the string: example12a = &quot;Hello&quot;print(a) 3. 여러줄 문자열 (Multiline Strings)“”” 를 이용하여 여러줄 문자열을 변수에 할당할 수 있습니다. example12345a = &quot;&quot;&quot;Lorem ipsum dolor sit amet,consectetur adipiscing elit,sed do eiusmod tempor incididuntut labore et dolore magna aliqua.&quot;&quot;&quot;print(a) or 3개의 작은 따옴표로도 표현 가능 12345a = '''Lorem ipsum dolor sit amet,consectetur adipiscing elit,sed do eiusmod tempor incididuntut labore et dolore magna aliqua.'''print(a) 4. 문자열의 배열 (Strings are Arrays) Python의 문자열은 유니코드 문자를 나타내는 바이트 배열입니다. Python에는 character data type이 없으며 single character는 단순히 길이가 1 인 문자열입니다. 대괄호를 사용하여 문자열의 요소에 접근할 수 있습니다. example문자열의 첫번째 배열은 0부터입니다. Get the character at position 1 (remember that the first character has the position 0) 12a = &quot;Hello, World!&quot;print(a[1]) 5. 문자열을 통한 Loop문자열은 배열이기 때문에 for Loop를 사용하여 문자열의 문자를 반복할 수 있습니다. example12for x in &quot;banana&quot;: print(x) For Loop는 다음 챕터에서 다루겠습니다. 6. 문자열 길이(String Length)문자열 길이를 얻기위해서는 len() 함수를 사용하면 됩니다. examplelen() 함수는 문자열의 길이를 반환해 줍니다. The len() function returns the length of a string: 12a = &quot;Hello, World!&quot;print(len(a)) 7. 문자열 확인(Check String)in 키워드를 이용하여 해당 문자열이 존재하는지 확인할 수 있다. To check if a certain phrase or character is present in a string, we can use the keyword in. exampletxt 변수에 “free”가 있는지 확인하십시오. 12txt = &quot;The best things in life are free!&quot;print(&quot;free&quot; in txt) if 문을 사용한 in 키워드 example123txt = &quot;The best things in life are free!&quot;if &quot;free&quot; in txt: print(&quot;Yes, 'free' is present.&quot;) if…else 문은 다음 챕터에서 다루겠습니다. 8. 문자열 있지 않은지 확인(Check if NOT)해당 문자가 존재하지 않은지 확인할때는 not in 키워드를 이용하면 된다. To check if a certain phrase or character is NOT present in a string, we can use the keyword not in. example12txt = &quot;The best things in life are free!&quot;print(&quot;expensive&quot; not in txt) if 문을 사용한 not in 키워드 example123txt = &quot;The best things in life are free!&quot;if &quot;expensive&quot; not in txt: print(&quot;Yes, 'expensive' is NOT present.&quot;) Referencew3schools python","link":"/2021/07/05/py-day10-string-1/"},{"title":"py-day10-string-2","text":"Python String 21. Slicingslice syntax를 이용하여 문자열을 자를수 있습니다. example문자열에서 2 ~ 5번째 (마지막은 미포함)를 얻습니다. 12b = &quot;Hello, World!&quot;print(b[2:5]) example문자열 배열에서 0 ~ 5번째 (마지막은 미포함)를 얻습니다. 12b = &quot;Hello, World!&quot;print(b[:5]) example문자열 배열에서 0 ~ 마지막을 얻습니다. 12b = &quot;Hello, World!&quot;print(b[2:]) example문자열 배열에서 -5 ~ -2번째 (마지막은 미포함)를 얻습니다. 12b = &quot;Hello, World!&quot;print(b[-5:-2]) Referencew3schools python","link":"/2021/07/05/py-day10-string-2/"},{"title":"py-day10-string-4","text":"문자열 연결 (String Concatenation)두 문자열을 연결하거나 결합하려면 + 연산자를 사용할 수 있습니다. example1234a = &quot;Hello&quot;b = &quot;World&quot;c = a + bprint(c) example1234a = &quot;Hello&quot;b = &quot;World&quot;c = a + &quot; &quot; + bprint(c) Referencew3schools python","link":"/2021/07/05/py-day10-string-4/"},{"title":"py-day10-string-3","text":"문자열 수정 (Modify Strings)Python에는 문자열에 사용할 수 있는 내장 함수들이 있습니다. 1. 대문자(Upper Case)example12a = &quot;Hello, World!&quot;print(a.upper()) # &quot;HELLO, WORLD!&quot; 2. 소문자(Lower Case)example12a = &quot;Hello, World!&quot;print(a.lower()) # &quot;hello, world!&quot; 3. 공백 제거(Remove Whitespace)공백제거는 문자열의 앞뒤의 공백을 제거해줍니다. example12a = &quot; Hello, World! &quot;print(a.strip()) # returns &quot;Hello, World!&quot; 4. 문자열 대체(Replace String)example12a = &quot;Hello, World!&quot;print(a.replace(&quot;H&quot;, &quot;J&quot;)) # &quot;Jello, World!&quot; 5. 문자열 분리(Split String)example12a = &quot;Hello, World!&quot;print(a.split(&quot;,&quot;)) # returns ['Hello', ' World!'] Referencew3schools python","link":"/2021/07/05/py-day10-string-3/"},{"title":"py-day10-string-5","text":"문자열 형식 (String Format)변수 챕터에서 배웠 듯이 문자열과 숫자를 결합할 수 없습니다. example123age = 36txt = &quot;My name is John, I am &quot; + ageprint(txt) # TypeError format() method를 사용하여 숫자와 문자를 결합할 수 있습니다. example123ge = 36txt = &quot;My name is John, and I am {}&quot;print(txt.format(age)) format() method는 숫자인수를 무제한 입력 할 수 있습니다. The format() method takes unlimited number of arguments, and are placed into the respective placeholders example12345quantity = 3itemno = 567price = 49.95myorder = &quot;I want {} pieces of item {} for {} dollars.&quot;print(myorder.format(quantity, itemno, price)) index number {0}를 사용하여 인수의 자리 위치를 표시할 수 있습니다. You can use index numbers {0} to be sure the arguments are placed in the correct placeholders example12345quantity = 3itemno = 567price = 49.95myorder = &quot;I want to pay {2} dollars for {0} pieces of item {1}.&quot;print(myorder.format(quantity, itemno, price)) Exercisespy-exercises-4 Referencew3schools python","link":"/2021/07/05/py-day10-string-5/"},{"title":"py-day11-booleans","text":"Python BooleansBooleans는 True, False 둘중 하나의 값을 나타냅니다. 1. Boolean Values두 값을 비교할때 값이 평가 되고 Boolean을 반환 한다. example123print(10 &gt; 9) # Trueprint(10 == 9) # Falseprint(10 &lt; 9) # False if 문에서 조건을 실행하면 Python은 True또는 False다음을 반환합니다. example조건 이 True 또는 False 인지에 따라 메시지가 다르게 출력됩니다. 1234567a = 200b = 33if b &gt; a: print(&quot;b is greater than a&quot;)else: print(&quot;b is not greater than a&quot;) 2. 값, 변수 평가example문자열과 숫자를 평가합니다. 12print(bool(&quot;Hello&quot;))print(bool(15)) example변수를 평가합니다. 12345x = &quot;Hello&quot;y = 15print(bool(x))print(bool(y)) 3. 대부분의 값은 True 빈 문자열을 제외하고 string은 True 숫자 0을 제외하고 True 비어있는 것을 제외한 list, tuple, set, dictionary는 True example123bool(&quot;abc&quot;)bool(123)bool([&quot;apple&quot;, &quot;cherry&quot;, &quot;banana&quot;]) 4. False인 값example1234567bool(False)bool(None)bool(0)bool(&quot;&quot;)bool(())bool([])bool({}) 5. 함수는 Boolean을 반환할수 있다. (Functions can Return a Boolean)example1234def myFunction() : return Trueprint(myFunction()) 함수의 부울 응답을 기반으로 코드를 실행할 수 있습니다. example1234567def myFunction() : return Trueif myFunction(): print(&quot;YES!&quot;)else: print(&quot;NO!&quot;) Python also has many built-in functions that return a boolean value, like the isinstance() function, which can be used to determine if an object is of a certain data type: example12x = 200print(isinstance(x, int)) Exercisespy-exercises-5 Referencew3schools python","link":"/2021/07/05/py-day11-booleans/"},{"title":"py-day11-list-2","text":"List Items 접근 (Access List Items)1. Items 접근example12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(thislist[1]) Note: 첫번째 item은 index 0이다. 2. Negative Indexing-1 은 마지막 item을 나타내며 오른쪽 부터 -1, -2, -3… 순이다. example12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(thislist[-1]) 3. Range of Indexeslist에 index 범위를 설정하여 해당 구역의 item만 list로 반환된다. example12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;]print(thislist[2:5]) Note: index 2는 포함, index 5는 미포함 example12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;]print(thislist[:4]) example12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;]print(thislist[2:]) example12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;]print(thislist[-4:-1]) 4. Item이 있는지 확인in 키워드를 사용하여 list에 해당 item이 있는지 확인 가능하다. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]if &quot;apple&quot; in thislist: print(&quot;Yes, 'apple' is in the fruits list&quot;) Referencew3schools python","link":"/2021/07/05/py-day11-list-2/"},{"title":"py-day11-list-1","text":"Python Listsmylist = [“apple”, “banana”, “cherry”] 1. ListLists는 단일 변수에 복수개의 itmes를 넣을때 사용합니다. Lists 말고도 Tuple, Set, Dictionary 가 있고 모두 쓰임새가 다릅니다. Lists are used to store multiple items in a single variable. Lists are one of 4 built-in data types in Python used to store collections of data, the other 3 are Tuple, Set, and Dictionary, all with different qualities and usage. Lists are created using square brackets: exampleCreate a List: 12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(thislist) 1.1 List ItemsList Items은 순서가 지정되고 변경 가능하며 중복 값을 허용합니다. List Items의 첫번째 index 는 [0] 다음 index는 [1] 순이다. List items are indexed, the first item has index [0], the second item has index [1] etc. 1.2 Changeablelist가 생성 후 items에 변경, 추가, 제거이 가능합니다. The list is changeable, meaning that we can change, add, and remove items in a list after it has been created. 1.3 중복 허용 (Allow Duplicates)example12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;, &quot;cherry&quot;]print(thislist) 1.4 List Lengthexample12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(len(thislist)) 1.5 List Items - Data TypesList items는 어떤 data-type도 가능합니다. example123list1 = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]list2 = [1, 5, 7, 9, 3]list3 = [True, False, False] list에는 다른 data-type이 들어가 있어도 됩니다. example1list1 = [&quot;abc&quot;, 34, True, 40, &quot;male&quot;] 1.6 type()list의 data-type은 ‘list’입니다. 1&lt;class 'list'&gt; example12mylist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(type(mylist)) 1.7 list() 생성자list() 를 사용하여 list 생성자를 생성할 수 있습니다. 12thislist = list((&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)) # note the double round-bracketsprint(thislist) Python Collections (Arrays)Python 프로그래밍 언어에 사용되는 4개의 Collection data types List: 순서가 변경될 수 있으며 중복될 수 있음 Tuple: 순서가 지정되고 변경할 수 없음, 중복 허용 Set: 순서가 없고 중복이 없음 Dictionary: 순서가 지정되고 변경 가능, 중복 없음","link":"/2021/07/05/py-day11-list-1/"},{"title":"py-day11-list-3","text":"python - Change List Items1. item value 변경example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist[1] = &quot;blackcurrant&quot;print(thislist) 2. item value를 range를 통한 변경 (Change a Range of Item Values)example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;mango&quot;]thislist[1:3] = [&quot;blackcurrant&quot;, &quot;watermelon&quot;]print(thislist) range 범위보다 더 많이 넣거나 적게 넣을 경우 어떻게 되는지 확인해보자. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist[1:2] = [&quot;blackcurrant&quot;, &quot;watermelon&quot;]print(thislist) example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist[1:3] = [&quot;watermelon&quot;]print(thislist) 3. insert Itemsinsert() method를 사용하여 해당 index 위치에 value를 넣을수 있다. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist.insert(2, &quot;watermelon&quot;)print(thislist) 4. add List Itemsappend() method를 사용하여 list 맨 뒤에 추가할 수 있다. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist.append(&quot;orange&quot;)print(thislist) 5. Extend Listextend() method를 사용하여 list를 붙일 수 있다. example1234thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]tropical = [&quot;mango&quot;, &quot;pineapple&quot;, &quot;papaya&quot;]thislist.extend(tropical)print(thislist) 6. Add Any Iterableextend() method를 사용하여 collection data type 의 다른 type도 확장이 가능하다. The extend() method does not have to append lists, you can add any iterable object (tuples, sets, dictionaries etc.). example1234thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thistuple = (&quot;kiwi&quot;, &quot;orange&quot;)thislist.extend(thistuple)print(thislist) Referencew3schools python","link":"/2021/07/05/py-day11-list-3/"},{"title":"py-day11-operators","text":"Python 연산자 (Python Operators)연산자는 변수와 값에 대한 작업을 수행하는 데 사용됩니다. 아래 예제를 보면 +연산자를 사용하여 두 값을 더합니다. example1print(10 + 5) Python은 연산자를 다음 그룹으로 나눕니다. 산술 연산자(Arithmetic operators) 할당 연산자(Assignment operators) 비교 연산자(Comparison operators) 논리 연산자(Logical operators) Identity operators Membership operators Bitwise operators 1. 산술 연산자(Arithmetic Operators)산술 연산자는 일반적인 수학 연산을 수행하기 위해 숫자 값과 함께 사용됩니다. Operator Name Example + Addition x + y - Subtraction x - y * Multiplication x * y / Division x / y % Modulus x % y ** Exponentiation x ** y // Floor division x // y 2. 할당 연산자 (Assignment operators)할당 연산자는 변수에 값을 할당하는 데 사용됩니다. Operator Example Same As = x = 5 x = 5 += x += 3 x = x + 3 -= x -= 3 x = x - 3 *= x *= 3 x = x * 3 /= x /= 3 x = x / 3 %= x %= 3 x = x % 3 //= x //= 3 x = x // 3 **= x **= 3 x = x ** 3 &amp;= x &amp;= 3 x = x &amp; 3 |= x |= 3 x = x | 3 ^= x ^= 3 x = x ^ 3 &gt;&gt;= x &gt;&gt;= 3 x = x &gt;&gt; 3 &lt;&lt;= x &lt;&lt;= 3 x = x &lt;&lt; 3 3. 비교 연산자(Comparison operators)비교 연산자는 두 값을 비교하는 데 사용됩니다. Operator Name Example == Equal x == y != Not equal x != y &gt; Greater than x &gt; y &lt; Less than x &lt; y &gt;= Greater than or equal to x &gt;= y &lt;= Less than or equal to x &lt;= y 4. 논리 연산자(Logical operators)논리 연산자는 조건문을 결합하는 데 사용됩니다. Operator Description Example and 둘 다 True이면 True x &lt; 5 and x &lt; 10 or 둘중 하나가 True이면 True x &lt; 5 or x &lt; 4 not 반대의 결과, 결과가 True이면 False not(x &lt; 5 and x &lt; 10) 5. Membership operators Operator Description Example in Returns True if a sequence with the specified value is present in the object x in y not in Returns True if a sequence with the specified value is not present in the object x not in y Exercisespy-exercises-6 Referencew3schools python","link":"/2021/07/05/py-day11-operators/"},{"title":"py-day11-list-4","text":"Python - Remove List Itemsremove() method를 사용하여 구체적인 item을 삭제할 수 있다. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist.remove(&quot;banana&quot;)print(thislist) 1. Remove Specified Indexpop() method를 사용하여 구체적인 index의 item을 삭제할 수 있다. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist.pop(1)print(thislist) example구체적인 index를 주지 않으면 마지막 index를 제거한다. 123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist.pop()print(thislist) exampledel 키워드를 사용하여 해당 인덱스를 삭제할 수도 있다. 123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]del thislist[0]print(thislist) exampledel 키워드를 사용하여 리스트 모두를 삭제할 수 있다. 12thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]del thislist 2. Clear the Listclear() method 를 사용하여 list 내부에 item을 모두 제거한다(list는 남아있음). example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]thislist.clear()print(thislist) Referencew3schools python","link":"/2021/07/05/py-day11-list-4/"},{"title":"py-day12-list-6","text":"Python - Sort ListsList는 sort() method를 이용하여 정렬을 할 수 있다.정렬 순으로 영숫자, 오름차순 List objects have a sort() method that will sort the list alphanumerically, ascending, by default: example123thislist = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;pineapple&quot;, &quot;banana&quot;]thislist.sort()print(thislist) example123thislist = [100, 50, 65, 82, 23]thislist.sort()print(thislist) Sort Descending내림차순을 사용할려면 reverse = True를 사용하면 된다. To sort descending, use the keyword argument reverse = True example123thislist = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;pineapple&quot;, &quot;banana&quot;]thislist.sort(reverse = True)print(thislist) example123thislist = [100, 50, 65, 82, 23]thislist.sort(reverse = True)print(thislist) 대소문자 구별(Case Insensitive Sort)sort() method는 대소문자를 구별하여 대문자 먼저 정렬이 되고 소문자가 정렬됩니다. By default the sort() method is case sensitive, resulting in all capital letters being sorted before lower case letters example123thislist = [&quot;banana&quot;, &quot;Orange&quot;, &quot;Kiwi&quot;, &quot;cherry&quot;]thislist.sort()print(thislist) Reverse Orderreverse() method를 사용하면 현재 List의 items 순서를 역전 시킨다. What if you want to reverse the order of a list, regardless of the alphabet? The reverse() method reverses the current sorting order of the elements. example123thislist = [&quot;banana&quot;, &quot;Orange&quot;, &quot;Kiwi&quot;, &quot;cherry&quot;]thislist.reverse()print(thislist) Referencew3schools python","link":"/2021/07/05/py-day12-list-6/"},{"title":"py-day11-list-5","text":"Python - Loop Listslist items를 사용하여 for loop를 쓸 수 있습니다. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]for x in thislist: print(x) 1. index number를 사용한 looprange(), len() 함수를 사용하여 for loop 를 응용할 수 있습니다. example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]for i in range(len(thislist)): print(thislist[i]) 2. while looplist를 사용하여 while loop도 사용 할 수 있습니다. example12345thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]i = 0while i &lt; len(thislist): print(thislist[i]) i = i + 1 Referencew3schools python","link":"/2021/07/05/py-day11-list-5/"},{"title":"py-day12-list-7","text":"Python - Copy Listspython list는 copy() method를 사용하여 list를 복사할 수 있다. 이때 얕은 복사와 깊은 복사를 확실하게 이해하고 넘어가야한다. 얕은 복사(shallow copy)와 깊은 복사(deep copy)example얕은 복사: 1234thislist = [&quot;orange&quot;, &quot;mango&quot;, &quot;kiwi&quot;, &quot;pineapple&quot;, &quot;banana&quot;]thislist2 = thislistthislist.insert(2,&quot;apple&quot;)print(thislist2) example깊은 복사: 123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]mylist = thislist.copy()print(mylist) 다른방법으로는 list() 내장 method를 사용 example123thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]mylist = list(thislist)print(mylist) Referencew3schools python","link":"/2021/07/05/py-day12-list-7/"},{"title":"py-day12-list-9","text":"List Methods Method Description append() Adds an element at the end of the list clear() Removes all the elements from the list copy() Returns a copy of the list count() Returns the number of elements with the specified value extend() Add the elements of a list (or any iterable), to the end of the current list index() Returns the index of the first element with the specified value insert() Adds an element at the specified position pop() Removes the element at the specified position remove() Removes the item with the specified value reverse() Reverses the order of the list sort() Sorts the list List를 제외한 나머지 Arraypython/python_tuples python/python_sets python_dictionaries Exercisespy-exercises-7 Referencew3schools python","link":"/2021/07/05/py-day12-list-9/"},{"title":"py-day12-list-8","text":"Python -Join ListsJoin Two Lists몇개의 List를 합치는 방법을 알아보겠습니다. example 연산자를 이용한 방법:12345list1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]list2 = [1, 2, 3]list3 = list1 + list2print(list3) exampleappend() method: 1234567list1 = [&quot;a&quot;, &quot;b&quot; , &quot;c&quot;]list2 = [1, 2, 3]for x in list2: list1.append(x)print(list1) exampleextend() method: 12345list1 = [&quot;a&quot;, &quot;b&quot; , &quot;c&quot;]list2 = [1, 2, 3]list1.extend(list2)print(list1) Referencew3schools python","link":"/2021/07/05/py-day12-list-8/"},{"title":"py-day9-numbers","text":"Python Numbers파이썬은 숫자형 타입이 3개 있습니다. int float complex 숫자형 타입으로 변수를 생성하고 싶다면 아래의 예제와 같이 값을 할당하면 됩니다. example123x = 1 # inty = 2.8 # floatz = 1j # complex 숫자형 타입을 할당한 변수의 데이터 타입을 확인하고 싶다면 type() 함수를 이용하시면 됩니다. example123print(type(x))print(type(y))print(type(z)) 1. intint, or integer는 숫자, 정수(음수, 양수) Int, or integer, is a whole number, positive or negative, without decimals, of unlimited length. exampleIntegers: 1234567x = 1y = 35656222554887711z = -3255522print(type(x))print(type(y))print(type(z)) 2. floatfloat, or “floating point number”, 실수 Float, or “floating point number” is a number, positive or negative, containing one or more decimals. exampleFloats: 1234567x = 1.10y = 1.0z = -35.59print(type(x))print(type(y))print(type(z)) Float는 10의 거듭 제곱을 나타내는 “e”가있는 과학적 숫자 일 수도 있습니다. exampleFloats: 1234567x = 35e3y = 12E4z = -87.7e100print(type(x))print(type(y))print(type(z)) 3. complexcomplex는 허수 Complex numbers are written with a “j” as the imaginary part exampleComplex: 1234567x = 3+5jy = 5jz = -5jprint(type(x))print(type(y))print(type(z)) 4. 타입 변환(Type Conversion)int(), float(), complex() 함수를 이용하여 숫자타입을 바꿀 수 있습니다. You can convert from one type to another with the int(), float(), and complex() methods example타입 변환: 1234567891011121314151617181920x = 1 # inty = 2.8 # floatz = 1j # complex#convert from int to float:a = float(x)#convert from float to int:b = int(y)#convert from int to complex:c = complex(x)print(a)print(b)print(c)print(type(a))print(type(b))print(type(c)) complex 타입은 다른 숫자타입으로 변환할 수 없습니다. Note: You cannot convert complex numbers into another number type. 5. Random NumberPython은 random() 함수가 없어서 랜덤숫자를 만들 수 없습니다. 그래서 Python은 random 이라는 내장 모듈을 불러와 사용할 수 있습니다. Python does not have a random() function to make a random number, but Python has a built-in module called random that can be used to make random numbers: example랜덤 모듈을 import 하여 1~9 사이의 숫자를 랜덤하게 출력: Import the random module, and display a random number between 1 and 9: 123import randomprint(random.randrange(1, 10)) Random Module이 궁금하다면 다음 챕터에서 배울 수 있습니다. Exercisespy-exercises-3 Referencew3schools python","link":"/2021/07/05/py-day9-number/"},{"title":"py-exercises-3","text":"Exercise 1x를 float data type으로 변경하기 위한 빈칸을 채우시오. 12x = 5x = ???(x) Exercise 2x를 integer data type으로 변경하기 위한 빈칸을 채우시오. 12x = 5.5x = ???(x) Exercise 3x를 complex data type으로 변경하기 위한 빈칸을 채우시오. 12x = 5x = ???(x)","link":"/2021/07/05/py-exercises-3/"},{"title":"py-exercises-4","text":"Exercise 1x 변수의 문자열 길이를 구하시오. 12x = &quot;Hello World&quot;print(???) Exercise 2txt 변수의 첫번째 문자를 구하시오. 12txt = &quot;Hello World&quot;print(???) Exercise 3txt 변수의 index 2 ~ 4 를 구하시오(llo) 12txt = &quot;Hello World&quot;print(???) Exercise 4문자열의 시작과 끝의 공백을 없앤 뒤 출력하시오. 12txt = &quot; Hello World &quot;print(???) Exercise 5txt 의 값을 대문자로 변환하시오. 12txt = &quot;Hello World&quot;txt = ??? Exercise 6txt 의 값을 소문자로 변환하시오. 12txt = &quot;Hello World&quot;txt = ??? Exercise 7H 를 J로 문자를 대체하시오. 12txt = &quot;Hello World&quot;txt = ??? Exercise 8format method를 이용하여 문자와 숫자를 결합하시오. 123age = 36txt = &quot;My name is John, and I am ???&quot;print(???)","link":"/2021/07/05/py-exercises-4/"},{"title":"py-exercises-5","text":"Exercise 1다음 문장을 실행해보자 1print(10 &gt; 9) Exercise 2다음 문장을 실행해보자 1print(10 == 9) Exercise 3다음 문장을 실행해보자 1print(10 &lt; 9) Exercise 3다음 문장을 실행해보자 12print(bool(&quot;abc&quot;))print(bool(&quot;&quot;)) Exercise 4다음 문장을 실행해보자 1print(bool(0))","link":"/2021/07/05/py-exercises-5/"},{"title":"py-exercises-6","text":"Exercise 110와 5를 곱하시오. 1print(10 ?? 9) Exercise 2membership 연산자를 사용하여 fruit object에 “apple”이 있는지 확인하시오. 123fruits = [&quot;apple&quot;, &quot;banana&quot;]if &quot;apple&quot; ??? fruits: print(&quot;Yes, apple is a fruit!&quot;) Exercise 3비교 연산자를 사용하여 5 와 10이 같지 않음을 확인하시오. 12if 5 ??? 10: print(&quot;5 and 10 is not equal&quot;) Exercise 4논리 연산자를 사용하여 Print가 출력되게 하시오. 12if 5 == 10 ??? 4 == 4: print(&quot;At least one of the statements is true&quot;)","link":"/2021/07/05/py-exercises-6/"},{"title":"py-exercises-7","text":"Exercise 1list의 2번째 인덱스 값을 출력하시오. 12fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]print(???) Exercise 2apple 을 kiwi로 변경하시오. 123fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]??? = ???print(fruits) Exercise 3append() method를 사용하여 “orange”를 추가하시오. 123fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]???print(fruits) Exercise 4insert() method를 사용하여 3번째 index에 “lemon”을 넣으시오. 123fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]??? &quot;lemon&quot;)print(fruits) Exercise 5remove() method를 사용하여 “banana”를 지우시오. 123fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]???print(fruits) Exercise 6range of indexes를 이용하여 2~4번째 인덱스만 출력하시오. 12fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;]print(fruits[???]) Exercise 7내장함수 ??? 를 사용하여 list의 개수를 출력하시오. 12fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;]print(???)","link":"/2021/07/05/py-exercises-7/"},{"title":"py-day13-if","text":"Python IF…Else조건문과 If문Python에서는 수학적인 논리 조건을 지원한다. Equals: a == b Not Equals: a != b Less than: a &lt; b Less than or equal to: a &lt;= b Greater than: a &gt; b Greater than or equal to: a &gt;= b 이러한 조건문은 보통 if문이나 Loop에 사용된다. example1234a = 33b = 200if b &gt; a: print(&quot;b is greater than a&quot;) example들여쓰기를 하지않으면 오류가 발생: 1234a = 33b = 200if b &gt; a:print(&quot;b is greater than a&quot;) Elif앞선 조건이 충족하지 않으면 이 elif로 시도한다. The elif keyword is pythons way of saying “if the previous conditions were not true, then try this condition”. example123456a = 33b = 33if b &gt; a: print(&quot;b is greater than a&quot;)elif a == b: print(&quot;a and b are equal&quot;) else앞의 모든 조건이 충족하지 않으면 해당 키워드에서 실행된다. example12345678a = 200b = 33if b &gt; a: print(&quot;b is greater than a&quot;)elif a == b: print(&quot;a and b are equal&quot;)else: print(&quot;a is greater than b&quot;) elif 없이도 사용이 가능하다. example123456a = 200b = 33if b &gt; a: print(&quot;b is greater than a&quot;)else: print(&quot;b is not greater than a&quot;) Short Hand IfexampleOne line if statement: 1if a &gt; b: print(&quot;a is greater than b&quot;) Short Hand If … ElseexampleOne line if else statement: 123a = 2b = 330print(&quot;A&quot;) if a &gt; b else print(&quot;B&quot;) Andand 키워드는 논리 연산자로 조건문을 조합할때 사용된다. example12345a = 200b = 33c = 500if a &gt; b and c &gt; a: print(&quot;Both conditions are True&quot;) ORor 키워드는 논리 연산자로 조건문을 조합할때 사용된다. example12345a = 200b = 33c = 500if a &gt; b or a &gt; c: print(&quot;At least one of the conditions is True&quot;) if문 중첩example12345678x = 41if x &gt; 10: print(&quot;Above ten,&quot;) if x &gt; 20: print(&quot;and also above 20!&quot;) else: print(&quot;but not above 20.&quot;) pass문if문을 선언하고 사용하지 않을경우 pass를 사용하면 된다. if statements cannot be empty, but if you for some reason have an if statement with no content, put in the pass statement to avoid getting an error. example12345a = 33b = 200if b &gt; a: pass Exercisespy-exercises-8 Referencew3schools python","link":"/2021/07/06/py-day13-if/"},{"title":"py-day13-while","text":"Python While LoopsPython에는 두가지 기본 Loop 명령이 있다. while loop for loop while loopwhile문은 조건이 충족할때까지 해당 코드 블록이 무한번 반복한다. With the while loop we can execute a set of statements as long as a condition is true. example1234i = 1while i &lt; 6: print(i) i += 1 break 문break 문은 loop를 빠져 나올수 있다. With the break statement we can stop the loop even if the while condition is true: example123456i = 1while i &lt; 6: print(i) if i == 3: break i += 1 continue문continue문은 현재의 반복을 중지하고 다음 반복으로 넘어간다. With the continue statement we can stop the current iteration, and continue with the next example123456i = 0while i &lt; 6: i += 1 if i == 3: continue print(i) else 문while문이 끝나고 else를 실행할 수 있다. With the else statement we can run a block of code once when the condition no longer is true example123456i = 1while i &lt; 6: print(i) i += 1else: print(&quot;i is no longer less than 6&quot;) Exercisespy-exercises-9 Referencew3schools python","link":"/2021/07/06/py-day13-while/"},{"title":"py-exercises-8","text":"Exercise 1변수 a가 b보다 크면 “Hello World”가 출력되게 하라. 12a = 50b = 10 Exercise 2변수 a와 b가 같지 않으면 “Hello World”가 출력되게 하라. 12a = 50b = 10 Exercise 3변수 a와 b가 같으면 “Yes” 같지 않으면 “No”가 출력되게 하라. Exercise 4변수 a와 b가 같으면, “1” a가 b보다 크면 “2” 그것도 아니면 “3”을 출력되게 하라. (if…elif…else) Exercise 5변수 a와 b가 같고 c보다 d가 크면 “Hello”를 출력되게 하라. (and) Exercise 6변수 a와 b가 같지 않거나 c와 d가 같으면 “Hello”를 출력되게 하라. (or) Exercise 7코드에 오류가 나는 부분을 찾아 수정하시오. 12if 5 &gt; 2:print(&quot;Five is greater than two!&quot;)","link":"/2021/07/06/py-exercises-8/"},{"title":"py-exercises-9","text":"Exercise 1변수 i가 1부터 6까지 출력되게 하시오. 1i = 1 Exercise 2변수 i가 while문에서 1씩 증가하며 i가 3일때 loop를 빠져나오게 하시오. 1i = 1 Exercise 3변수 i가 while문에서 1씩 증가하며 6까지 출력하되, i가 3일때 continue를 사용하여 1,2,4,5,6이 출력되게 하시오. 1i = 1 Exercise 4while문이 끝난 뒤 아래의 문장이 출력되게 하시오. 1print(&quot;the while loop END&quot;)","link":"/2021/07/06/py-exercises-9/"},{"title":"py-day14-for","text":"Python For Loopsfor loop는 list, tuple, dictionary, set, string등에 순차 반복에 사용된다. A for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string). This is less like the for keyword in other programming languages, and works more like an iterator method as found in other object-orientated programming languages. With the for loop we can execute a set of statements, once for each item in a list, tuple, set etc. example123fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]for x in fruits: print(x) 문자열 반복문example12for x in &quot;banana&quot;: print(x) break 문break 문은 loop를 빠져 나올수 있다. example12345fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]for x in fruits: print(x) if x == &quot;banana&quot;: break example12345fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]for x in fruits: if x == &quot;banana&quot;: break print(x) continue 문continue문은 현재의 반복을 중지하고 다음 반복으로 넘어간다. example12345fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]for x in fruits: if x == &quot;banana&quot;: continue print(x) range() functionexample12for x in range(6): print(x) 12for x in range(2, 6): print(x) Increment the sequence with 3 (default is 1): 12for x in range(2, 30, 3): print(x) else in for loopfor문이 끝난뒤 else문을 실행시킬수 있다. example1234for x in range(6): print(x)else: print(&quot;Finally finished!&quot;) note: loop문에 break로 빠져나오게 된다면 else문이 실행되지 않는다. example12345for x in range(6): if x == 3: break print(x)else: print(&quot;Finally finished!&quot;) loop 중첩example123456adj = [&quot;red&quot;, &quot;big&quot;, &quot;tasty&quot;]fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]for x in adj: for y in fruits: print(x, y) pass 문for문을 선언하고 사용하지 않을때 pass문을 넣으면 오류가 발생하지 않는다. example12for x in [0, 1, 2]: pass Exercisespy-exercises-10 Referencew3schools python","link":"/2021/07/07/py-day14-for/"},{"title":"py-exercises-10","text":"Exercise 1for 문을 사용하여 list의 items를 출력하시오. 1fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] Exercise 2for 문을 사용하여 list의 items를 출력하시오. 단, “banana”는 출력을 넘기시오.(continue) 1fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] Exercise 3range()를 사용하여 0~5까지 출력하시오 Exercise 4for 문을 사용하여 list의 items를 출력하시오. 단, “banana”일때는 for문을 끝내시오.(break) 1fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]","link":"/2021/07/07/py-exercises-10/"},{"title":"py-test-1","text":"Python middle testTEST 1while문을 이용하여 구구단을 출력하시오. 출력 예시:구구단 1단: 1 X 1 = 1구구단 1단: 1 X 2 = 2…구구단 9단: 9 X 9 = 81 TEST 2for문을 이용하여 구구단 짝수만 출력하시오. 출력 예시:구구단 2단: 2 X 1 = 2구구단 2단: 2 X 2 = 4…구구단 8단: 8 X 9 = 72 TEST 312345fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;pear&quot;, &quot;chestnut&quot;, &quot;grape&quot;, &quot;melon&quot;, &quot;lemon&quot;,&quot; citron&quot;, &quot;apricot&quot;]fruits_1 = [&quot;apple&quot;, &quot;chestnut&quot;, &quot;grape&quot;, &quot;melon&quot;, &quot;lemon&quot;, &quot;apricot&quot;]fruits_2 = [&quot;banana&quot;, &quot;grape&quot;, &quot;cherry&quot;, &quot;pear&quot;, &quot;chestnut&quot;, &quot;lemon&quot;, &quot;citron&quot;] TEST 3.0fruits에 “watermelon”을 추가하여 알파벳 순으로 출력하시오. TEST 3.1fruits_1 list와 fruits_2 list의 item을 비교하여 똑같은 item가 있을 경우 해당 item을 출력하시오. TEST 3.2fruits list의 과일을 하나씩 출력하는데 알파벳 “c”인 과일은 빼고 출력하시오. TEST 3.3fruits_1 과 fruits_2를 합쳐서 fruits_3를 만들어 출력하시오. 중복이 있을경우 한번만 들어가되 대문자로 넣으시오.","link":"/2021/07/07/py-test-1/"},{"title":"py-day15-function","text":"함수는 호출 되었을때 해당 코드 블록이 실행이 된다.함수에 매개변수(parameters) 값을 보낼 수 있다.함수는 결과값을 return 해준다. A function is a block of code which only runs when it is called.You can pass data, known as parameters, into a function.A function can return data as a result. 1. 함수 생성(Creating a Function)def 키워드로 함수를 정의한다. example12def my_function(): print(&quot;Hello from a function&quot;) 2. 함수 호출(Calling a Function)함수를 호출하려면 함수 이름 뒤에 괄호를 사용합니다. example1234def my_function(): print(&quot;Hello from a function&quot;)my_function() 3. 인수 (Arguments)정보는 인수로 함수에 전달 될수 있습니다. 인수는 함수 명 뒤에 괄호안에 지정됩니다. 인수는 원하는 만큼 넣을수 있고, ‘,’ 콤마로 분리 됩니다. Information can be passed into functions as arguments. Arguments are specified after the function name, inside the parentheses. You can add as many arguments as you want, just separate them with a comma. The following example has a function with one argument (fname). When the function is called, we pass along a first name, which is used inside the function to print the full name: example123456def my_function(fname): print(fname + &quot; Refsnes&quot;)my_function(&quot;Emil&quot;)my_function(&quot;Tobias&quot;)my_function(&quot;Linus&quot;) Arguments are often shortened to args in Python documentations. 4. 매개변수(Parameters) or 인수(Arguments)?함수에 정보를 전달하는데 있어서 매개변수와 인수는 같은 의미입니다. The terms parameter and argument can be used for the same thing: information that are passed into a function 5. Number of Arguments기본적으로 함수는 인수값을 일치시켜 사용해야합니다. By default, a function must be called with the correct number of arguments. Meaning that if your function expects 2 arguments, you have to call the function with 2 arguments, not more, and not less. example1234def my_function(fname, lname): print(fname + &quot; &quot; + lname)my_function(&quot;Emil&quot;, &quot;Refsnes&quot;) If you try to call the function with 1 or 3 arguments, you will get an error: exampleThis function expects 2 arguments, but gets only 1: 1234def my_function(fname, lname): print(fname + &quot; &quot; + lname)my_function(&quot;Emil&quot;) 6. 임의의 인수, * args함수에 전달 될 인수의 수를 모르는 *경우 함수 정의에서 매개 변수 이름 앞에를 추가하십시오. 이렇게하면 함수가 인수 튜플 을 수신하고 그에 따라 항목에 액세스 할 수 있습니다. example1234def my_function(*kids): print(&quot;The youngest child is &quot; + kids[2])my_function(&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;) 임의 인수 는 종종 Python 문서에서 * args 로 축약됩니다. Arbitrary Arguments are often shortened to *args in Python documentations. 7. 키워드 인수(Keyword Arguments)key = value 방식으로 사용할 수 있으면 이경우 인수의 순서가 중요하지 않습니다. You can also send arguments with the key = value syntax.This way the order of the arguments does not matter. example1234def my_function(child3, child2, child1): print(&quot;The youngest child is &quot; + child3)my_function(child1 = &quot;Emil&quot;, child2 = &quot;Tobias&quot;, child3 = &quot;Linus&quot;) The phrase Keyword Arguments are often shortened to kwargs in Python documentations. 8. 임의의 키워드 인수, **kwargs얼마나 많은수의 키워드 인수가 함수에 들어올 지 알수 없을때 사용되는 방식입니다. 이방식은 함수가 dictionary 인수를 받고 items에 접근합니다. If you do not know how many keyword arguments that will be passed into your function, add two asterisk: ** before the parameter name in the function definition. This way the function will receive a dictionary of arguments, and can access the items accordingly example1234def my_function(**kid): print(&quot;His last name is &quot; + kid[&quot;lname&quot;])my_function(fname = &quot;Tobias&quot;, lname = &quot;Refsnes&quot;) 9. Default Parameter Value함수를 정의할 때 매개변수에 기본값을 설정하면 함수를 호출할때 인수없이도 호출이 가능하다. example1234567def my_function(country = &quot;Norway&quot;): print(&quot;I am from &quot; + country)my_function(&quot;Sweden&quot;)my_function(&quot;India&quot;)my_function()my_function(&quot;Brazil&quot;) 10. 리스트 목록을 전달(Passing a List as an Argument)string, number, list, dictionart 등등의 data type을 함수의 인수로 전달 할 수 있습니다. You can send any data types of argument to a function (string, number, list, dictionary etc.), and it will be treated as the same data type inside the function example1234567def my_function(food): for x in food: print(x)fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]my_function(fruits) 11. Return Values함수에서 값이 반환되게 할려면 Return문을 작성하여야 합니다. To let a function return a value, use the return statement example123456def my_function(x): return 5 * xprint(my_function(3))print(my_function(5))print(my_function(9)) 12. The pass Statement function definitions cannot be empty, but if you for some reason have a function definition with no content, put in the pass statement to avoid getting an error example12def myfunction(): pass 13. 재귀 함수(Recursion)재귀함수는 함수가 자기자신을 호출하는것을 의미한다. Python also accepts function recursion, which means a defined function can call itself. Recursion is a common mathematical and programming concept. It means that a function calls itself. This has the benefit of meaning that you can loop through data to reach a result. The developer should be very careful with recursion as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly recursion can be a very efficient and mathematically-elegant approach to programming. In this example, tri_recursion() is a function that we have defined to call itself (“recurse”). We use the k variable as the data, which decrements (-1) every time we recurse. The recursion ends when the condition is not greater than 0 (i.e. when it is 0). To a new developer it can take some time to work out how exactly this works, best way to find out is by testing and modifying it. example12345678910def tri_recursion(k): if(k &gt; 0): result = k + tri_recursion(k - 1) print(result) else: result = 0 return resultprint(&quot;\\n\\nRecursion Example Results&quot;)tri_recursion(6) Exercisespy-exercises-11 Referencew3schools python","link":"/2021/07/08/py-day15-function/"},{"title":"py-exercises-11","text":"Exercise 1‘my_funciton’이라는 함수를 만들어 “Hello from a function”를 출력하시오 1print(&quot;Hello from a function&quot;) Exercise 2함수에 인수 2개를 만들어(first_name, second_name) 함수를 호출하면 name이 출력되게 하시오. 1print(first_name, second_name) Exercise 3함수에서 반환하는 값이 x parameter + 5 가 되게 하시오. 12def my_funciton(x): ??? Exercise 4kids 가 여러 인수를 전달 받을 수 있게 하시오. 1234def my_function(???kids): print(kids)my_function(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) Exercise 5kids 가 여러 키워드 인수를 전달 받을 수 있게 하시오. 1234def my_function(???kids): print(kids)my_function(fname = &quot;Tobias&quot;, lname = &quot;Refsnes&quot;)","link":"/2021/07/08/py-exercises-11/"},{"title":"py-day16-class-object","text":"Python Classes/Objects Python은 객체지향 언어이다. Python의 대부분이 properties와 method가 있는 object이다. 클래스는 객체 생성자 또는 객체 생성을 위한 “청사진”과 같습니다. Python is an object oriented programming language. Almost everything in Python is an object, with its properties and methods. A Class is like an object constructor, or a “blueprint” for creating objects. 정의 class : 실세계의 것을 모델링하여 속성과 동작을 갖는 데이터 타입 다루고자 하는 데이터와 데이터를 다루는 연산을 하나로 캡슐화하여 클래스로 표현 init(self): 생성자를 정의, 클래스 인스턴스가 생성될 때 호출됨 self인자는 항상 첫 번째로 오며 자기 자신을 가리킴 method: 멤버함수라고 하며, 해당 클래스의 object에서만 호출 가능 object: 객체는 어떠한 속성값과 행동을 가지고 있는 데이터 파이썬의 모든것들(숫자, 문자, 함수 등)은 여러 속성과 행동을 가지고 있는 데이터 Create a Classclass 키워드를 사용하여 클래스를 만들어봅시다. example12class MyClass: x = 5 Create Object선언한 클래스를 사용하여 object를 생성하여 봅시다. example12p1 = MyClass()print(p1.x) __init__() Function __init__()는 클래스가 시작할때 항상 실행되는 함수이다. __init__() 함수를 사용하여 객체 속성에 값을 할당하거나 객체를 생성할 때 수행해야 하는 기타 작업을 수행합니다. exampleCreate a class named Person, use the __init__() function to assign values for name and age: 123456789class Person: def __init__(self, name, age): self.name = name self.age = agep1 = Person(&quot;John&quot;, 36)print(p1.name)print(p1.age) Object Methods Object는 methods를 가질 수 있습니다. object methods는 object에 속하는 함수입니다. example12345678910class Person: def __init__(self, name, age): self.name = name self.age = age def myfunc(self): print(&quot;Hello my name is &quot; + self.name)p1 = Person(&quot;John&quot;, 36)p1.myfunc() self Parameterself 파라메터는 현재의 클래스 인스턴스를 참조하고, 클래스에 속한 변수를 접근하여 사용한다. self라고 이름지어질 필요가 없으며 원하는 명으로 지을 수 있다. 그러나 첫번째 파라메터로 지정하여야 한다 The self parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class. It does not have to be named self , you can call it whatever you like, but it has to be the first parameter of any function in the class: Modify Object Propertiesexample12p1 = testClass()p1.age = 40 Delete Object Propertiesexample12p1 = testClass()del p1.age Delete Objectsexample12p1 = testClass()del p1 The pass Statementexample12class Person: pass Exercisespy-exercises-12 Referencew3schools python","link":"/2021/07/09/py-day16-class-object/"},{"title":"py-test-1-answer","text":"TEST 1while문을 이용하여 구구단을 출력하시오. 출력 예시:구구단 1단: 1 X 1 = 1구구단 1단: 1 X 2 = 2…구구단 9단: 9 X 9 = 81 TEST 1 Answer 12345678910i = 1j = 1while(i &lt;= 9): j = 1 while(j &lt;= 9): print(str.format(&quot;구구단 {0}단: {1} X {2} = {3}&quot;, i, i, j, i*j)) j += 1 i+= 1 TEST 2for문을 이용하여 구구단 짝수만 출력하시오. 출력 예시:구구단 2단: 2 X 1 = 2구구단 2단: 2 X 2 = 4…구구단 8단: 8 X 9 = 72 TEST 2 Answer 1234567i = 1j = 1for x in range(1, 10): for y in range(1, 10): if (x % 2 == 0): print(str.format(&quot;구구단 {0}단: {1} X {2} = {3}&quot;, x, x, y, x*y)) TEST 312345fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;pear&quot;, &quot;chestnut&quot;, &quot;grape&quot;, &quot;melon&quot;, &quot;lemon&quot;,&quot; citron&quot;, &quot;apricot&quot;]fruits_1 = [&quot;apple&quot;, &quot;chestnut&quot;, &quot;grape&quot;, &quot;melon&quot;, &quot;lemon&quot;, &quot;apricot&quot;]fruits_2 = [&quot;banana&quot;, &quot;grape&quot;, &quot;cherry&quot;, &quot;pear&quot;, &quot;chestnut&quot;, &quot;lemon&quot;, &quot;citron&quot;] TEST 3.0fruits에 “watermelon”을 추가하여 알파벳 순으로 출력하시오. TEST 3.0 Answer 123fruits.append(&quot;watermelon&quot;)fruits.sort()print(fruits) TEST 3.1fruits_1 list와 fruits_2 list의 item을 비교하여 똑같은 item가 있을 경우 해당 item을 출력하시오. TEST 3.1 Answer 1234for x in range(len(fruits_1)): for y in range(len(fruits_2)): if(fruits_1[x] == fruits_2[y]): print(fruits_2[y]) TEST 3.2fruits list의 과일을 하나씩 출력하는데 알파벳 “c”인 과일은 빼고 출력하시오. TEST 3.2 Answer 12345for x in range(len(fruits)): y = fruits[x] if(y[0] != 'c'): print(fruits[x]) TEST 3.3fruits_1 과 fruits_2를 합쳐서 fruits_3를 만들어 출력하시오. 중복이 있을경우 한번만 들어가되 대문자로 넣으시오. TEST 3.3 Answer 123456789101112131415161718192021222324252627282930313233# list 합치기fruits_3 = fruits_1.copy()fruits_3.extend(fruits_2)# 겹치는 과일 deleteList에 넣기deleteList = []for x in range(len(fruits_3)): count = 0 for y in range(len(fruits_3)): if(fruits_3[x] == fruits_3[y]): count += 1 if(count == 2): if fruits_3[y] in deleteList: pass else: deleteList.append(fruits_3[y]) break# 겹치는 과일 1개 삭제for x in range(len(deleteList)): fruits_3.remove(deleteList[x])# 겹치는 과일 대문자로 변경for x in range(len(deleteList)): for y in range(len(fruits_3)): if(fruits_3[y] == deleteList[x]): z = deleteList[x] fruits_3[y] = z.upper()print(fruits_3)","link":"/2021/07/12/py-test-1-answer/"},{"title":"py-exercises-12","text":"Exercise 1MyClass 라는 Class를 만들어서 내부에 변수 x를 만들기. 1x = 5 Exercise 2MyClass 라는 Class를 만들어서 내부에 변수 x를 만들어 출력하시오. 12345# 클래스 만들기# 클래스 인스턴스를 만들어 x를 출력하기 Exercise 3student class를 만들어 생성자로 이름, 나이, 학년을 넣으시오. 그리고 이름 나이 학년을 “홍길동 19세 3학년입니다.” 라고 출력하시오. 12345# 클래스 만들기# 클래스 생성자 만들기# 클래스 인스턴스를 만들어 이름, 나이, 학년을 대입# 출력","link":"/2021/07/13/py-exercises-12/"},{"title":"py-day17-inheritance","text":"Python Inheritance상속을 통해 다른 클래스의 모든 메서드와 속성을 상속하는 클래스를 정의할 수 있습니다. Parent class 는 상속되는 클래스 이며 base class 라고도 합니다. Child class 는 파생 클래스라고도 하는 다른 클래스에서 상속되는 클래스입니다. Inheritance allows us to define a class that inherits all the methods and properties from another class. Parent class is the class being inherited from, also called base class. Child class is the class that inherits from another class, also called derived class. 1. Create a Parent Class부모 클래스는 일반 클래스와 동일합니다. 기본 클래스 생성과 똑같습니다. Any class can be a parent class, so the syntax is the same as creating any other class example123456789101112class Person: def __init__(self, fname, lname): self.firstname = fname self.lastname = lname def printname(self): print(self.firstname, self.lastname)#Use the Person class to create an object, and then execute the printname method:x = Person(&quot;John&quot;, &quot;Doe&quot;)x.printname() 2. Create a Child Class다른 클래스의 기능을 상속하는 클래스를 만들려면 자식 클래스를 만들 때 부모 클래스를 매개 변수로 보냅니다. To create a class that inherits the functionality from another class, send the parent class as a parameter when creating the child class exampleStudent 클래스를 생성하여 Person 클래스 속성과 메서드를 상속하게 만듭니다. 12class Student(Person): pass Note: Use the pass keyword when you do not want to add any other properties or methods to the class. Student 클래스는 Person 클래스의 속성과 메소드를 가진 클래스가 된다. Now the Student class has the same properties and methods as the Person class. example12x = Student(&quot;Mike&quot;, &quot;Olsen&quot;)x.printname() 3. Add the init() Function자식 클래스에 생성자 함수를 만들어 봅시다. So far we have created a child class that inherits the properties and methods from its parent. We want to add the __init__() function to the child class (instead of the pass keyword). note: __init__()함수는 클래스를 사용하여 새 개체를 만들 때마다 자동으로 호출됩니다 Note: The __init__() function is called automatically every time the class is being used to create a new object. example123class Student(Person): def __init__(self, fname, lname): #add properties etc. 자식 클래스에서 __init__() 함수를 넣게되면 더이상 부모 클래스의 __init__() 함수를 상속받지 않습니다. When you add the init() function, the child class will no longer inherit the parent’s init() function. 자식 클래스에서 부모 클래스의 __init__() 함수를 상속받고 싶다면 부모 클래스의 __init__() 함수를 호출하면 된다. To keep the inheritance of the parent’s init() function, add a call to the parent’s init() function example123class Student(Person): def __init__(self, fname, lname): Person.__init__(self, fname, lname) 4. Use the super() Functionsuper() 함수를 사용하면 자식 클래스가 부모 클래스의 모든 속성과 메소드를 상속할 수 있다. Python also has a super() function that will make the child class inherit all the methods and properties from its parent example123class Student(Person): def __init__(self, fname, lname): super().__init__(fname, lname) super() 함수를 사용하면 부모의 요소를 언급할 필요가 없다. By using the super() function, you do not have to use the name of the parent element, it will automatically inherit the methods and properties from its parent. 5. Add Propertiesexample Add a property called graduationyear to the Student class: 1234class Student(Person): def __init__(self, fname, lname): super().__init__(fname, lname) self.graduationyear = 2019 클래스 매개변수로 Student Properties를 추가할 수 있습니다. In the example below, the year 2019 should be a variable, and passed into the Student class when creating student objects. To do so, add another parameter in the __init__() function example123456class Student(Person): def __init__(self, fname, lname, year): super().__init__(fname, lname) self.graduationyear = yearx = Student(&quot;Mike&quot;, &quot;Olsen&quot;, 2019) 6. Add Methodsexample1234567class Student(Person): def __init__(self, fname, lname, year): super().__init__(fname, lname) self.graduationyear = year def welcome(self): print(&quot;Welcome&quot;, self.firstname, self.lastname, &quot;to the class of&quot;, self.graduationyear) 부모 클래스의 함수와 이름이 같은 메서드를 자식 클래스에 추가하면 부모 메서드의 상속이 무시됩니다. If you add a method in the child class with the same name as a function in the parent class, the inheritance of the parent method will be overridden. Exercisespy-exercises-13 Referencew3schools python","link":"/2021/07/14/py-day17-inheritance/"},{"title":"py-exercises-13","text":"Exercise 1123456789class Person: def __init__(self, fname): self.firstname = fname def printname(self): print(self.firstname)class Student(Person): pass Exercise 1.1변수 x 에 student 클래스를 선언하여 “Miss Fortune” 을 생성자로 넣어 보시오. Exercise 1.2변수 x 를 통해 printname을 사용하여 보시오. Exercise 2123456789class LOL: def __init__(self, fname): self.name = fname def printname(self): print(self.name)class Champion(LOL): ??? Exercise 2.1Champion 클래스에 setLevel 메소드를 만들어 Level 을 입력할 수 있게 하시오. Exercise 2.2Champion 클래스에 getState 메소드를 만들어 아래와 같이 출력할 수 있게 하시오. 12name: Miss FortuneLV: 10","link":"/2021/07/15/py-exercises-13/"},{"title":"py-day18-iterators","text":"Python Iterators (반복자)반복자는 셀 수 있는 값을 포함하는 개체입니다. 반복자는 반복될 수 있는 개체입니다. 즉, 모든 값을 순회할 수 있습니다. __iter__() , __next__() An iterator is an object that contains a countable number of values. An iterator is an object that can be iterated upon, meaning that you can traverse through all the values. Technically, in Python, an iterator is an object which implements the iterator protocol, which consist of the methods iter() and next(). 1. Iterator vs IterableLists, tuples, dictionaries, sets 들이 반복가능(Iterable) 객체이다.반복자(Iterator)를 얻을 수 있는 반복 가능한(Iterable) 컨테이너 입니다. 이러한 객체들은 반복자를 얻는데 사용되는 iter() 메소드를 가지고 있습니다. Lists, tuples, dictionaries, and sets are all iterable objects. They are iterable containers which you can get an iterator from. All these objects have a iter() method which is used to get an iterator example123456mytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)myit = iter(mytuple)print(next(myit))print(next(myit))print(next(myit)) 문자열조차도 반복 가능한 객체이며 반복자를 반환할 수 있습니다. example123456789mystr = &quot;banana&quot;myit = iter(mystr)print(next(myit))print(next(myit))print(next(myit))print(next(myit))print(next(myit))print(next(myit)) 2. Looping Through an Iteratorfor loop를 이용하여 반복 가능한 객체를 반복 할 수도 있습니다. example1234mytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)for x in mytuple: print(x) example1234mystr = &quot;banana&quot;for x in mystr: print(x) 3. Create an IteratorObject/Class 반복자를 만들기 위해서는 __iter__() , __next__() 메소드를 구현하여야 한다. __iter__(): 항상 반복자 개체 자체를 반환해야 합니다. __next__(): 작업을 수행할 수 있으며 시퀀스의 다음 항목을 반환해야 합니다. To create an object/class as an iterator you have to implement the methods __iter__() and __next__() to your object. example123456789101112131415161718class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return xmyclass = MyNumbers()myiter = iter(myclass)print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter)) 4. StopIteration(반복 중지)반복이 영원히 계속되는 것을 방지하기 위해 StopIteration명령문을 사용할 수 있습니다 . example123456789101112131415161718class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIterationmyclass = MyNumbers()myiter = iter(myclass)for x in myiter: print(x) Referencew3schools python","link":"/2021/07/16/py-day18-iterators/"},{"title":"py-day19-scope","text":"Python Scope변수는 생성된 영역 내에서만 사용할 수 있습니다. 이를 scope 라고 합니다. 1. local scope함수 내에서 변수를 생성하여 사용하면 지역변수이다. A variable created inside a function belongs to the local scope of that function, and can only be used inside that function. example12345def myfunc(): x = 300 print(x)myfunc() 1.1 Function Inside Function함수 내부에 함수에서 지역변수를 접근할 수 있습니다. The local variable can be accessed from a function within the function example1234567def myfunc(): x = 300 def myinnerfunc(): print(x) myinnerfunc()myfunc() 2. Global Scope파이썬 코드의 본문에 생성된 변수는 전역 변수이며 전역 범위에 속합니다. 전역 변수는 전역 및 지역의 모든 범위 내에서 사용할 수 있습니다. example12345678x = 300def myfunc(): print(x)myfunc()print(x) 2.1 Naming Variables함수 내부와 외부에서 동일한 변수 이름으로 작업하는 경우 Python은 이를 두 개의 개별 변수로 취급합니다. 하나는 전역 범위(함수 외부)에서 사용 가능하고 다른 하나는 로컬 범위(함수 내부)에서 사용 가능합니다. example123456789x = 300def myfunc(): x = 200 print(x)myfunc()print(x) 3. Global Keyword지역 scope에서 global 키워드를 사용하면 전역변수로 사용할 수 있다. example1234567def myfunc(): global x x = 300myfunc()print(x) Referencew3schools python","link":"/2021/07/19/py-day19-scope/"},{"title":"py-day19-modules","text":"Python ModulesWhat is a Module?Module은 Code Library와 동일하다. 응용 프로그램에 포함하려는 함수들의 집합이 포함된 파일입니다. Consider a module to be the same as a code library. A file containing a set of functions you want to include in your application. 1. Create a ModuleMobule을 만들기 위해서는 .py 확장자로 파일을 생성하면 된다. To create a module just save the code you want in a file with the file extension .py exampleSave this code in a file named mymodule.py 12def greeting(name): print(&quot;Hello, &quot; + name) 1.1 Use a Moduleimport 문을 사용하여 module을 사용할 수 있습니다. Now we can use the module we just created, by using the import statement example123import mymodulemymodule.greeting(&quot;Jonathan&quot;) Note: When using a function from a module, use the syntax: module_name.function_name. 2. Variables in Modulemodule은 함수를 포함 할 수 있고, 모든 타입의 변수도 포함할 수 있다. The module can contain functions, as already described, but also variables of all types (arrays, dictionaries, objects etc) exampleSave this code in the file mymodule.py 12345person1 = { &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 36, &quot;country&quot;: &quot;Norway&quot;} example1234import mymodulea = mymodule.person1[&quot;age&quot;]print(a) 3. Naming a ModuleModule 명은 원하는데로 수정이 가능하지만 확장자는 .py를 지켜야 한다. 3.1 Re-naming a Moduleimport module의 명을 as 키워드를 사용하여 바꿀 수 있다. example1234import mymodule as mxa = mx.person1[&quot;age&quot;]print(a) 4. Built-in Modules (내장된 모듈)example1234import platformx = platform.system()print(x) 4.1 Using the dir() Functiondir() 함수를 사용하면 모듈의 내장된 함수를 확인할 수 있다. There is a built-in function to list all the function names (or variable names) in a module. The dir() function: example1234import platformx = dir(platform)print(x) 5. Import From Modulefrom 키워드를 사용하여 Module에 일부분만 가져올 수 있다. example123456789# mymodule.pydef greeting(name): print(&quot;Hello, &quot; + name)person1 = { &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 36, &quot;country&quot;: &quot;Norway&quot;} example123from mymodule import person1print (person1[&quot;age&quot;]) Referencew3schools python","link":"/2021/07/19/py-day19-modules/"},{"title":"js-day8-immutability","text":"객체와 변경불가성(Immutability)Immutability(변경불가성)는 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴을 의미한다. Immutability은 함수형 프로그래밍의 핵심원리이다. 객체는 참조(reference)형태로 전달하고 전달 받는다. 객체가 참조를 통해 공유되어 있다면 그 상태가 언제든지 변경될 수 있기 때문에 문제가 될 가능성도 커지게 된다. 이는 객체의 참조를 가지고 있는 어떤 장소에서 객체를 변경하면 참조를 공유하는 모든 장소에서 그 영향을 받기 때문인데 이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하다. 의도하지 않은 객체의 변경이 발생하는 원인의 대다수는 “레퍼런스를 참조한 다른 객체에서 객체를 변경”하기 때문이다. 이 문제의 해결 방법은 비용은 조금 들지만 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 또는 Observer 패펀으로 객체의 변경에 대처할 수도 있다. 불변 객체를 사용하면 복제나 비교를 위한 조작을 단순화 할 수 있고 성능 개선에도 도움이 된다. 하지만 객체가 변경 가능한 데이터를 많이 가지고 있는 경우 오히려 부적절한 경우가 있다. ES6에서는 불변 데이터 패턴(immutable data pattern)을 쉽게 구현할 수 있는 새로운 기능이 추가되었다. 1. immutable value vs. mutable valuejavascript의 원시타입(primitive data type)은 변경 불가능한(immutable value)이다. Boolean null undefined Number String Symbol(New in ECMAScript 6) 원시타입 이외의 모든 값은 객체(Object)타입이며 변경 가능한 값(mutable value)이다. 즉, 객체는 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다는 것이다. 예를 들어 살펴보자. C언어와는 다르게 Javascript의 문자열은 변경 불가능한 값(immutable value)이다. 이런 값을 “primitive values”라 한다. (변경이 불가능하다는 뜻은 메모리 영역에서의 변경이 불가능하다는 뜻이다. 재할당은 가능하다.) 12var str = 'Hello';str = 'world'; 첫번째 구문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 메모리에 생성된 문자열 ‘Hello’의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고이 있다. 변수 str은 문자열 ‘Hello’를 카리키고 있다가 문자열 ‘world’를 가르키도록 변경되었을 뿐이다. 123456var statement = 'I am an immutable value'; // string은 immutable valuevar otherStr = statement.slice(8, 17);console.log(otherStr); // 'immutable'console.log(statement); // 'I am an immutable value' 2행에서 String 객체의 slice() 메소드는 statement 변수에 저장된 문자열을 변경하는 것이 아니라 사실 새로운 문자열을 생성하여 반환하고 있다. 그 이유는 문자열은 변경할 수 없는 immutable value이기 때문이다. 12345var arr = [];console.log(arr.length); // 0var v2 = arr.push(2); // arr.push()는 메소드 실행 후 arr의 length를 반환console.log(arr.length); // 1 상기 예제에서 v2의 값은 무엇인가? 문자열의 예와 같이 배열이 동작한다면 v2는 새로운 배열(하나의 요소를 가지고 그 값은 2인)가지게 될것이다. 그러나 객체인 arr은 push 메소드에 의해 update 되고 v2에는 배열의 새로운 length 값이 반환된다. 처리 후 결과의 복사본을 리턴하는 문자열의 메소드 slice()와는 달리 배열(객체)의 메소드 push()는 직접 대상 배열을 변경한다. 그 이유는 배열은 객체이고 객체는 immutable value가 아닌 변경 가능한 값이기 때문이다. 1234567891011121314var user = { name: 'Lee', address: { city: 'Seoul' }};var myName = user.name; // 변수 myName은 string 타입이다.user.name = 'Kim';console.log(myName); // LeemyName = user.name; // 재할당console.log(myName); // Kim user.name의 값을 변경했지만 변수 myName의 값은 병경되지 않았다. 이는 변수 myName에 user.name을 할당했을 때 user.name의 참조를 할당하는 것이 아니라 immutable한 값 ‘Lee’가 메모리에 새로 생성되고 myName은 이것을 참조하기 떄문이다. 따라서 user.name의 값이 변경된다 하더라도 변수 myName이 참조하고 있는 ‘Lee’는 변함이 없다. 12345678910111213var user1 = { name: 'Lee', address: { city: 'Seoul' }};var user2 = user1; // 변수 user2는 객체 타입이다.user2.name = 'Kim';console.log(user1.name); // Kimconsole.log(user2.name); // Kim 위의 경우 객체 user2의 name 프로퍼티에 새로운 값을 할당하면 객체는 변경 불가능한 값이 아니므로 객체 user2는 변경된다. 그런데 변경하지도 않은 객체 user1도 동시에 변경된다. 이는 user1과 user2가 같은 어드레스를 참조하고 있기 때문이다. 이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하다. 2. 불변 데이터 패턴(immutable data pattern)의도하지 않은 객체의 변경이 발생하는 원인의 대다수는 “레퍼런스를 참조한 다른 객체에서 객체를 변경”하기 때문이다. 이 문제의 해결 방법은 비용은 조금 들지만 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 객체의 방어적 복사(defensive copy): Object.assign 불변객체화를 통한 객체 변경 방지: Object.freeze 2.1 Object.assignObject.assign은 타깃 객체로 소스 객체의 프로퍼티를 복사한다. 이때 소스 객체의 프로퍼티와 동일한 프로퍼티를 가진 타깃 객체의 프로퍼티들은 소스 객체의 프로퍼티로 덮어쓰기 된다. 리턴값으로 타깃 객체를 반환한다. ES6에서 추가된 메소드이며 Internet Explorer는 지원하지 않는다. 12// SyntaxObject.assign(target, ...sources) 12345678910111213141516171819202122232425// Copyconst obj = { a: 1 };const copy = Object.assign({}, obj);console.log(copy); // { a: 1 }console.log(obj == copy); // false// Mergeconst o1 = { a: 1 };const o2 = { b: 2 };const o3 = { c: 3 };const merge1 = Object.assign(o1, o2, o3);console.log(merge1); // { a: 1, b: 2, c: 3 }console.log(o1); // { a: 1, b: 2, c: 3 }, 타겟 객체가 변경된다!// Mergeconst o4 = { a: 1 };const o5 = { b: 2 };const o6 = { c: 3 };const merge2 = Object.assign({}, o4, o5, o6);console.log(merge2); // { a: 1, b: 2, c: 3 }console.log(o4); // { a: 1 } Object.assign을 사용하여 기존 객체를 변경하지 않고 객체를 복사하여 사용할 수 있다. Object.assign은 완전한 deep copy를 지원히지 않는다. 객체 내부의 객체(Nested Object)는 Shallow copy된다. 12345678910111213141516171819202122const user1 = { name: 'Lee', address: { city: 'Seoul' }};// 새로운 빈 객체에 user1을 copy한다.const user2 = Object.assign({}, user1);// user1과 user2는 참조값이 다르다.console.log(user1 === user2); // falseuser2.name = 'Kim';console.log(user1.name); // Leeconsole.log(user2.name); // Kim// 객체 내부의 객체(Nested Object)는 Shallow copy된다.console.log(user1.address === user2.address); // trueuser1.address.city = 'Busan';console.log(user1.address.city); // Busanconsole.log(user2.address.city); // Busan 2.2 Object.freezeObject.freeze()를 사용하여 불변(immutable)객체를 만들 수 있다. 1234567891011121314151617181920const user1 = { name: 'Lee', address: { city: 'Seoul' }};// Object.assign은 완전한 deep copy를 지원하지 않는다.const user2 = Object.assign({}, user1, {name: 'Kim'});console.log(user1.name); // Leeconsole.log(user2.name); // KimObject.freeze(user1);user1.name = 'Kim'; // 무시된다!console.log(user1); // { name: 'Lee', address: { city: 'Seoul' } }console.log(Object.isFrozen(user1)); // true 하지만 객체 내부의 객체(Nested Object)는 변경이 가능하다. 1234567891011const user = { name: 'Lee', address: { city: 'Seoul' }};Object.freeze(user);user.address.city = 'Busan'; // 변경된다!console.log(user); // { name: 'Lee', address: { city: 'Busan' } } 내부 객체까지 변경 불가능하게 만들려면 Deep freeze를 하여야 한다. 12345678910111213141516171819202122232425function deepFreeze(obj) { const props = Object.getOwnPropertyNames(obj); props.forEach((name) =&gt; { const prop = obj[name]; if(typeof prop === 'object' &amp;&amp; prop !== null) { deepFreeze(prop); } }); return Object.freeze(obj);}const user = { name: 'Lee', address: { city: 'Seoul' }};deepFreeze(user);user.name = 'Kim'; // 무시된다user.address.city = 'Busan'; // 무시된다console.log(user); // { name: 'Lee', address: { city: 'Seoul' } } 2.3 Immutable.jsObject.assign과 Object.freeze을 사용하여 불변 객체를 만드는 방법은 번거러울 뿐더러 성능상 이슈가 있어서 큰 객체에는 사용하지 않는 것이 좋다. 또다른 대안으로 Facsbook이 제공하는 Immutable.js를 사용하는 방법이 있다. Immutable.js는 List, Stack, Map, OrderedMap, Set, OrderedSet, Record와 같은 영구 불변 (Permit Immutable) 데이터 구조를 제공한다. npm을 사용하여 Immutable.js를 설치한다. 1$ npm install immutable Immutable.js의 Map 모듈을 임포트하여 사용한다. 12345const { Map } = require('immutable')const map1 = Map({ a: 1, b: 2, c: 3 })const map2 = map1.set('b', 50)map1.get('b') // 2map2.get('b') // 50 map1.set(‘b’, 50)의 실행에도 불구하고 map1은 불변하였다. map1.set()은 결과를 반영한 새로운 객체를 반환한다. Referencepoiemaweb.com/js-immutability Deep-copying in JavaScript","link":"/2021/07/21/js-day8-immutability/"},{"title":"js-day9-function","text":"함수란 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. 1234// 함수의 정의(함수 선언문)function square(number) { return number * number;} 함수는 호출에 의해 실행되는데 한번만 호출할 수 있는 것이 아니라 여러번 호출할 수 있다. 1234567// 함수의 정의(함수 선언문)function square(number) { return number * number;}// 함수의 호출square(2); // 4 동일한 작업을 반복적으로 수행해야 한다면 (동일한 구문을 계속해서 중복해서 작성하는 것이 아니라) 미리 정의된 함수를 재사용하는 것이 효율적이다. 이러한 특성은 코드의 재사용이라는 측면에서 매우 유용하다. 함수의 일반적 기능은 어떤 작업을 수행하는 문(statement)들의 집합을 정의하여 코드의 재사용에 목적이 있다. 이러한 일반적 기능 이외에 객체 생성, 객체의 행위 정의(메소드), 정보 은닉, 클로저, 모듈화 등의 기능을 수행할 수 있다. 자바스크립트의 함수는 객체(일급 객체, First-class object)이다. 다른 객체와 구분될 수 있는 특징은 호출할 수 있다는 것이다. 함수도 객체이므로 다른 값들처럼 사용할 수 있다. 즉, 변수나 객체, 배열 등에 저장할 수 있고 다른 함수에 전달되는 인수로도 사용할 수 있으며 함수의 반환값이 될 수도 있다. 1. 함수 정의함수를 정의하는 방식은 3가지가 있다. 함수 선언문 함수 표현식 Function 생성자 함수 1.1 함수 선언문함수 선언문(Function declaration) 방식으로 정의한 함수는 function 키워드와 이하의 내용으로 구성된다. 함수명함수 선언문의 경우, 함수명은 생략할 수 없다. 함수명은 함수 몸체에서 자신을 재귀적(recursive)호출하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자이다. 매개변수 목록0개 이상의 목록으로 괄호로 감싸고 콤마로 분리한다. 다른 언어와의 차이점은 매개변수의 타입을 기술하지 않는다는 것이다. 이 때문에 함수 몸체 내에서 매개변수의 타입 체크가 필요할 수 있다. 함수 몸체함수가 호출되었을 때 실행되는 문들의 집합이다. 중괄호({})로 문들을 감싸고 return 문으로 결과값을 반환할 수 있다. 이를 반환값 (return value)라 한다. 1234// 함수 선언문function square(number) { return number * number;} 1.2 함수 표현식자바스크립트의 함수는 일급 객체(first-class object)이므로 아래와 같은 특징이 있다. 무명의 리터럴로 표현이 가능하다. 변수나 자료 구조(객체, 배열… )에 저장할 수 있다. 함수의 파라미터로 전달할 수 있다. 반환값(return value)으로 사용할 수 있다. 함수의 일급객체 특성을 이용하여 함수 리터럴 방식으로 함수를 정의하고 변수에 할당할 수 있는데 이러한 방식을 함수 표현식(Function expression)이라 한다. 함수 선언문으로 정의한 함수 square()를 함수 표현식으로 정의하면 아래와 같다. 1234// 함수 표현식var square = function(number) { return number * number;}; 함수 표현식 방식으로 정의한 함수를 함수명을 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다. 함수 표현식에서는 함수명을 생략하는 것이 일반적이다. 123456789101112// 기명 함수 표현식(named function expression)var foo = function multiply(a, b) { return a * b;};// 익명 함수 표현식(anonymous function expression)var bar = function(a, b) { return a * b;};console.log(foo(10, 5)); // 50console.log(multiply(10, 5)); // Uncaught ReferenceError: multiply is not defined 함수는 일급객체이기 때문에 변수에 할당할 수 있는데 이 변수는 함수명이 아니라 할당된 함수를 가리키는 참조값을 저장하게 된다. 함수 호출 시 함수명이 아니라 함수를 가리키는 변수명을 사용하여야 한다. 12345678var foo = function(a, b) { return a * b;};var bar = foo;console.log(foo(10, 10)); // 100console.log(bar(10, 10)); // 100 변수 bar와 변수 foo는 동일한 익명 함수의 참조값을 갖는다. foo -&gt; 익명 함수 &lt;- bar 함수가 할당된 변수를 사용해 함수를 호출하지 않고 기명함수의 함수명을 사용해 호출하게 되면 에러가 발생한다. 이를 함수 표현식에서 사용한 함수명은 외부 코드에서 접근 불가능하기 때문이다. (사실 함수 선언문의 경우도 마찬가지이다.) 함수 표현식과 함수 선언문에서 사용한 함수명은 함수 몸체에서 자신을 재귀적 호출(Recursize function call)하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자의 역할을 한다. 함수 선언문으로 정의한 함수 square의 경우, 함수명으로 호출 할 수 있었는데 이는 자바스크립트 엔진에 의해 아래와 같은 함수 표현식으로 형태가 변경되었기 때문이다. 123var square = function square(number) { return number * number;}; 함수명과 함수 참조값을 가진 변수명이 일치하므로 함수명으로 호출되는 듯 보이지만 사실은 변수명으로 호출된 것이다. 결국 함수 선언문도 함수 표현식과 동일하게 함수 리터럴 방식으로 정의되는 것이다. 1.3 Function 생성자 함수함수 표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다. 함수 선언문도 내부적으로 자바스크립트 엔진이 기명 함수 표현식으로 변환하므로 결국 함수 리터럴 방식을 사용한다. 따라서 함수 선언문과 함수 표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function 생성자 함수로 함수를 생성하는 것을 단순화 시킨 short-hand(축약법)이다. Function 생성자 함수는 Function.prototype.constructor 프로퍼티로 접근할 수 있다. Function 생성자 함수로 함수를 생성하는 문법은 다음과 같다. 1new Function(arg1, arg2, ... argN, functionBody) 12var square = new Function('number', 'return number * number');console.log(square(10)); // 100 Function 생성자 함수로 함수를 생성하는 방식은 일반적으로 사용하지 않는다. 2. 함수 호이스팅3가지의 함수 정의 방식을 알아보았다. 정의 방식은 달라도 결국 Function 생성자 함수를 통해 함수를 생성하는 것까지 확인하였다. 그런데 이 3가지 함수 정의 방식은 동작 방식에 약간의 차이가 있다. 12345var res = square(5);function square(number) { return number * number;} 위 코드를 보면 함수 선언문으로 함수가 정의되기 이전에 함수 호출이 가능하다. 함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느곳에서든지 호출이 가능한데 이것을 함수 호이스팅(Function Hoisting)이라 한다. 자바스크립트는 ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅(Hoisting)한다. 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문(var, let, const, function, function*, class)이 선언되기 이전에 참조 가능하다. 함수 선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 vo(variable object)에 저장한다. 함수 선언, 초기화, 할당이 한번에 이루어진다. 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다. 다음은 함수 표현식으로 함수를 정의한 경우이다. 12345var res = square(5); // TypeError: square is not a functionvar square = function(number) { return number * number;} 함수 선언문의 경우와는 달리 Type Error가 방생하였다. 함수 표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생한다. 변수 호이스팅은 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undefined로 초기화 되고 실제값의 할당은 할당문에서 이루어 진다. 함수 표현식은 함수 선언문과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고 runtime에 해석되고 실행되므로 이 두가지를 구분하는 것은 중요하다. JavaScript: The Good Parts의 저자이며 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있다. 함수 호이스팅이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적한다. 또한 함수 선언문으로 함수를 정의하면 사용하기에 쉽지만 대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다. 3. First-class object(일급 객체)일급 객체(first-class object)란 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다. 다음 조건을 만족하면 일급 객체로 간주한다. 무명의 리터럴로 표현이 가능하다. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다. 함수의 매개변수에 전달할 수 있다. 반환값으로 사용할 수 있다. 123456789101112131415161718192021222324252627282930// 1. 무명의 리터럴로 표현이 가능하다.// 2. 변수나 자료 구조에 저장할 수 있다.var increase = function (num) { return ++num;};var decrease = function (num) { return --num;};var predicates = { increase, decrease };// 3. 함수의 매개변수에 전달할 수 있다.// 4. 반환값으로 사용할 수 있다.function makeCounter(predicate) { var num = 0; return function () { num = predicate(num); return num; };}var increaser = makeCounter(predicates.increase);console.log(increaser()); // 1console.log(increaser()); // 2var decreaser = makeCounter(predicates.decrease);console.log(decreaser()); // -1console.log(decreaser()); // -2 Javascript의 함수는 위의 조건을 모두 만족하므로 Javascript의 함수는 일급객체이다. 따라서 Javascript의 함수는 흡사 변수와 같이 사용할 수 있으며 코드의 어디에서든지 정의할 수 있다. 함수와 다른 객체를 구분짓는 특징은 호출할 수 있다는 것이다. 4. 매개변수(Parameter, 인자)함수의 작업 실행을 위해 추가적인 정보가 필요할 경우, 매개변수를 지정한다. 매개변수는 함수 내에서 변수와 동일하게 동작한다. 4.1 매개변수(parameter, 인자) vs 인수(argument)매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 함수에 전달한 인수는 매개변수에 할당된다. 만약 인수를 전달하지 않으면 매개변수는 Undefined로 초기화 된다. 12345var foo = function (p1, p2) { console.log(p1, p2);};foo(1); // 1 undefined 4.2 Call-by-value원시 타입 인수는 Call-by-value(값에 의한 호출)로 동작한다. 이는 함수 호출 시 원시 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식이다. 이때 함수 내에서 매개변수를 통해 값이 변경되어도 전달이 완료된 원시 타입 값은 변경되지 않는다. 123456789function foo(primitive) { primitive += 1; return primitive;}var x = 0;console.log(foo(x)); // 1console.log(x); // 0 4.3 Call-by-reference객체형(참조형) 인수는 Call-by-reference(참조에 의한 호출)로 동작한다. 이는 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식이다. 이때 함수 내에서 매개변수의 참조값이 이용하여 객체의 값을 변경했을 때 전달되어진 참조형의 인수값도 같이 변경된다. 12345678910111213141516171819function changeVal(primitive, obj) { primitive += 100; obj.name = 'Kim'; obj.gender = 'female';}var num = 100;var obj = { name: 'Lee', gender: 'male'};console.log(num); // 100console.log(obj); // Object {name: 'Lee', gender: 'male'}changeVal(num, obj);console.log(num); // 100console.log(obj); // Object {name: 'Kim', gender: 'female'} changeVal 함수는 원시 타입과 객체 타입 인수를 전달 받아 함수 몸체에서 매개변수의 값을 변경하였다. 이때 원시 타입 인수는 값을 복사하여 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경하여도 어떠한 부수 효과(side-effect)도 발생시키지 않는다. 하지만 객체형 인수는 참조값을 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경할 경우 원본 객체가 변경되는 부수 효과(side-effect)가 발생한다. 이와 같이 부수 효과를 발생시키는 비순수 함수(Impure function)는 복잡성을 증가시킨다. 비순수 함수를 최대한 줄이는 것은 부수 효과를 최대한 억제하는 것과 같다. 이것은 디버깅을 쉽게 만든다. 어떤 외부 상태도 변경하지 않는 함수를 순수함수(Pure function), 외부 상태도 변경시켜는 부수 효과(side-effect)가 발생시키는 함수를 비순수 함수(Impure function)라 한다. 5. 반환값함수는 자신을 호출한 코드에게 수행한 결과를 반환(return)할 수 있다. 이때 반환된 값을 반환값(return value)이라 한다. return 키워드는 함수를 호출한 코드(caller)에게 값을 반환할 때 사용한다. 함수는 배열 등을 이용하여 한번에 여러 개의 값을 리턴할 수 있다. 함수는 반환을 생략할 수 있다. 이때 함수는 암묵적으로 undefined를 반환한다. 자바스크립트 해석기는 return 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 만일 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다. 123456789101112131415function calculateArea(width, height) { var area = width * height; return area; // 단일 값의 반환}console.log(calculateArea(3, 5)); // 15console.log(calculateArea(8, 5)); // 40function getSize(width, height, depth) { var area = width * height; var volume = width * height * depth; return [area, volume]; // 복수 값의 반환}console.log('area is ' + getSize(3, 2, 3)[0]); // area is 6console.log('volume is ' + getSize(3, 2, 3)[1]); // volume is 18 6. 함수 객체의 프로퍼티함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. 12345678function square(number) { return number * number;}square.x = 10;square.y = 20;console.log(square.x, square.y); 함수는 일반 객체와는 다른 함수만의 프로퍼티를 갖는다. 1234function square(number) { return number * number;}console.dir(square); 6.1 arguments 프로퍼티arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한 (iterble)유사 배열 객체(array-like object)이며 함수 내부에서 지역변수처럼 사용된다. 즉, 함수 외부에서는 사용할 수 없다. arguments 프로퍼티는 현재 일부 브라우저에서 지원하고 있지만 ES3부터 표준에서 deprecated 되었다. Function.arguments와 같은 사용 방법은 권장되지 않으며 함수 내부에서 지역변수처럼 사용할 수 있는 arguments 객체를 참조하도록 한다. 자바스트립트는 함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다. 123456789function multiply(x, y) { console.log(arguments); return x * y;}multiply(); // {}multiply(1); // { '0': 1 }multiply(1, 2); // { '0': 1, '1': 2 }multiply(1, 2, 3); // { '0': 1, '1': 2, '2': 3 } 매개변수(parameter)는 인수(argument)로 초기화 된다. 매개변수의 갯수보다 인수를 적게 전달했을 때(multiply(), multiply(1)) 인수가 전달되지 않은 매개변수는 undefined 으로 초기화 된다. 매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다. 이러한 자바스크립트의 특성떄문에 런타임 시에 호출된 함수의 인자 갯수를 확인하고 이에따라 동작을 달리 정의할 필요가 있을 수 있다. 이때 유용하게 사용되는 것이 arguments 객체이다. arguments 객체는 매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하게 사용된다. 12345678910111213function sum() { var res = 0; for (var i = 0; i &lt; arguments.length; i++) { res += arguments[i]; } return res;}console.log(sum()); // 0console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3)); // 6 자바스크립트는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다. arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다. 유사배열객체란 length 프로퍼티를 가진 객체를 말한다. 유사배열객체는 배열이 아니므로 배열 메소드를 사용하는 경우 에러가 발생하게 된다. 따라서 배열 메소드를 사용하려면 Function.prototype.call, [Function.prototype.apply]https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)를 사용하여야 하는 번거로움이 있다. 1234567891011121314151617function sum() { if (!arguments.length) return 0; // arguments 객체를 배열로 변환 var array = Array.prototype.slice.call(arguments); return array.reduce(function (pre, cur) { return pre + cur; });}// ES6// function sum(...args) {// if (!args.length) return 0;// return args.reduce((pre, cur) =&gt; pre + cur);// }console.log(sum(1, 2, 3, 4, 5)); // 15 6.2 caller 프로퍼티caller 프로퍼티는 자신을 호출한 함수를 의미한다. 1234567891011function foo(func) { var res = func(); return res;}function bar() { return 'caller : ' + bar.caller;}console.log(foo(bar)); // caller : function foo(func) {...}console.log(bar()); // null (browser에서의 실행 결과) 6.3 length 프로퍼티length 프로퍼티는 함수 정의 시 작성된 매개변수 갯수를 의미한다. 123456789101112function foo() {}console.log(foo.length); // 0function bar(x) { return x;}console.log(bar.length); // 1function baz(x, y) { return x * y;}console.log(baz.length); // 2 arguments.length의 값과는 다를 수 있으므로 주의하여야 한다. arguments.length는 함수 호출 시 인자의 갯수이다. 6.4 name 프로퍼티함수명을 나타낸다. 기명함수의 경우 함수명을 값으로 갖고 익명함수의 경우 빈문자열을 값으로 갖는다. 1234567891011// 기명 함수 표현식(named function expression)var namedFunc = function multiply(a, b) { return a * b;};// 익명 함수 표현식(anonymous function expression)var anonymousFunc = function(a, b) { return a * b;};console.log(namedFunc.name); // multiplyconsole.log(anonymousFunc.name); // '' 6.5 proto 접근자 프로퍼티모든 객체는 [[prototype]]이라는 내부 슬롯이 있다. [[prototype]] 내부 슬롯은 프로포타입 객체를 가리킨다. 프로토타입 객체란 프로포타입 기반 객체 지향 프로그래밍의 근간을 이루는 객체로서 객체간의 상속(Inheritance)을 구현하기 위해 사용된다. 즉, 프로포타입 객체는 다른 객체에 공유 프로퍼티를 제공하는 개체를 말한다. __proto__ 프로퍼티는 [[prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.[[prototype]] 내부 슬롯에도 직접 접근할 수 없으며 __proto__ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다. 123// __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입 객체에 접근할 수 있다.// 객체 리터럴로 생성한 객체의 프로토타입 객체는 Object.prototype이다.console.log({}.__proto__ === Object.prototype); // true __proto__ 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 모든 객체의 프로토타입 객체인 Object.prototype 객체의 프로퍼티이다. 모든 객체는 상속을 통해 __proto__ 접근자 프로퍼티는 사용할 수 있다. 12345678910// 객체는 __proto__ 프로퍼티를 소유하지 않는다.console.log(Object.getOwnPropertyDescriptor({}, '__proto__'));// undefined// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티이다.console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));// {get: ƒ, set: ƒ, enumerable: false, configurable: true}// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.console.log({}.__proto__ === Object.prototype); // true 함수도 객치이므로 __proto__ 접근자 프로퍼티를 통해 프로토타입 객체에 접근할 수 있다. 12// 함수 객체의 프로토타입 객체는 Function.prototype이다.console.log((function() {}).__proto__ === Function.prototype); // true 6.6 prototype 프로퍼티prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 즉 일반 객체에는 prototype 프로퍼티가 없다. 1234567// 함수 객체는 prototype 프로퍼티를 소유한다.console.log(Object.getOwnPropertyDescriptor(function() {}, 'prototype'));// {value: {…}, writable: true, enumerable: false, configurable: false}// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.console.log(Object.getOwnPropertyDescriptor({}, 'prototype'));// undefined prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체를 가리킨다. 7. 함수의 다양한 형태7.1 즉시 실행 함수함수의 정의와 동시에 실행되는 함수를 즉시 실행 함수 (IIFE, Immediately Invoke Function Expression)라고 한다. 최초 한번만 호출되며 다시 호출할 수는 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다. 12345678910111213141516171819202122232425262728// 기명 즉시 실행 함수(named immediately-invoked function expression)(function myFunction() { var a = 3; var b = 5; return a * b;}());// 익명 즉시 실행 함수(immediately-invoked function expression)(function () { var a = 3; var b = 5; return a * b;}());// SyntaxError: Unexpected token (// 함수선언문은 자바스크립트 엔진에 의해 함수 몸체를 닫는 중괄호 뒤에 ;가 자동 추가된다.function () { // ...}(); // =&gt; };();// 따라서 즉시 실행 함수는 소괄호로 감싸준다.(function () { // ...}());(function () { // ...})(); 자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다하여도 글로벌 스코프가 하나이며 글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근이 가능하다는 것이다. 따라서 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 원치 않는 결과를 가져올 수 있다. 즉시 실행 함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 또는 함수명의 충돌을 방지할 수 있어 이를 위한 목적으로 즉시실행함수를 사용되기도 한다. 특히 jQuery와 같은 라이브러리의 경우, 코드를 즉시 실행 함수 내에 정의해 두면 라이브러리의 변수들이 독립된 영역 내에 있게 되므로 여러 라이브러리들은 동시에 사용하더라도 변수명 충돌과 같은 문제를 방지할 수 있다. 1234567(function () { var foo = 1; console.log(foo);}());var foo = 100;console.log(foo); 7.2 내부 함수함수 내부에 정의된 함수를 내부함수(Inner function)라 한다. 아래 예제의 내부함수 child는 자신을 포함하고 있는 부모함수 parent의 변수에 접근할 수 있다. 하지만 부모함수는 자식함수(내부함수)의 변수에 접근할 수 없다. 1234567891011function parent(param) { var parentVar = param; function child() { var childVar = 'lee'; console.log(parentVar + ' ' + childVar); // Hello lee } child(); console.log(parentVar + ' ' + childVar); // Uncaught ReferenceError: childVar is not defined}parent('Hello'); 또한 내부함수는 부모함수의 외부에서 접근할 수 없다. 12345678function sayHello(name){ var text = 'Hello ' + name; var logHello = function(){ console.log(text); } logHello();}sayHello('lee'); // Hello leelogHello('lee'); // logHello is not defined 7.3 재귀 함수재귀 함수(Recusive function)는 자기 자신을 호출하는 함수를 말한다. 12345678910111213141516171819202122232425262728293031// 피보나치 수열// 피보나치 수는 0과 1로 시작하며, 다음 피보나치 수는 바로 앞의 두 피보나치 수의 합이 된다.// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...function fibonacci(n) { if (n &lt; 2) return n; return fibonacci(n - 1) + fibonacci(n - 2);}console.log(fibonacci(0)); // 0console.log(fibonacci(1)); // 1console.log(fibonacci(2)); // 1console.log(fibonacci(3)); // 2console.log(fibonacci(4)); // 3console.log(fibonacci(5)); // 5console.log(fibonacci(6)); // 8// 팩토리얼// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.// n! = 1 * 2 * ... * (n-1) * nfunction factorial(n) { if (n &lt; 2) return 1; return factorial(n - 1) * n;}console.log(factorial(0)); // 1console.log(factorial(1)); // 1console.log(factorial(2)); // 2console.log(factorial(3)); // 6console.log(factorial(4)); // 24console.log(factorial(5)); // 120console.log(factorial(6)); // 720 재귀 함수는 자신을 무한히 연쇄 호출하므로 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다. 탈출 조건이 없는 경우, 함수가 무한 호출되어 stackoverflow 에러가 발생한다. 위의 두개의 예제 모두 조건식을 통해 재귀 호출을 중지하고 있다. 재귀 함수는 반복 연산을 간단히 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 수 있고, stackoverflow 에러를 발생시킬 수 있으므로 주의하여야 한다. 대부분의 재귀 함수는 for나 while 문으로 구현이 가능하다. 반복문보다 재귀 함수를 통해 보다 직관적으로 이해하기 쉬운 구현이 가능한 경우에만 한정적으로 적용하는 것이 바람직하다. 7.4 콜백 함수콜백 함수(Callback function)는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다. 콜백 함수가 자주 사용되는 대표적인 예는 이벤트 헨들러 처리이다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=&quot;myButton&quot;&gt;Click me&lt;/button&gt; &lt;script&gt; var button = document.getElementById('myButton'); button.addEventListener('click', function() { console.log('button clicked!'); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Javascript의 함수는 일급객체이다. 따라서 Javascript의 함수는 흡사 변수와 같이 사용될 수 있다. 콜백 함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행된다.setTimeout()의 콜백 함수를 살펴보자. 두번째 매개변수에 전달된 시간이 경과되면 첫번째 매개변수에 전달한 콜백 함수가 호출된다. 123setTimeout(function () { console.log('1초 후 출력된다.');}, 1000); 콜백 함수는 주로 비동기식 처리 모델(Asynchronous processing model)에 사용된다. 비동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다. 콜백함수는 콜백 큐에 들어가 있다가 해당 이벤트가 발생하면 호출된다. 콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다. 123456789function doSomething() { var name = 'Lee'; setTimeout(function () { console.log('My name is ' + name); }, 100);}doSomething(); // My name is Lee Referencepoiemaweb.com/js-function","link":"/2021/07/23/js-day9-function/"},{"title":"js-day10-typechecking","text":"타입 체크 (Type Checking)자바스크립트는 동적타입(dynamic typed)언어이므로 변수에 어떤 값이 할당될지 예측하기 어렵다. 123function sum(a, b) { return a + b;} 위 코드를 작성한 개발자의 의도는 아마도 2개의 number 타입 인수를 전달받아 그 합계를 반환하려는 것으로 추측된다. 하지만 코드 상으로는 어떤 타입의 인수를 전달하여야 하는지, 어떤 타입의 값을 반환해야하는지 명확하지 않다. 따라서 위 코드는 다음처럼 호출 될 수 있다. 12345function sum(a, b) { return a + b;}sum('x', 'y'); // 'xy' 위 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실행할 것이다. 이러한 상황이 발생한 이유는 변수나 반환값의 타입을 사전에 지정하지 않는 자바스크립트의 동적 타이핑(Dynamic Typing)에 의한것이다. 이와같은 이유로 자바스크립트는 타입 체크가 필요하다. 1234function sum(a, b) { // a와 b가 number 타입인지 체크 return a + b;} 1. typeof타입 연산자(Type Operator) typeof는 피연산자의 데이터 타입을 문자열로 반환한다. 12345678910111213typeof ''; // stringtypeof 1; // numbertypeof NaN; // numbertypeof true; // booleantypeof []; // objecttypeof {}; // objecttypeof new String(); // objecttypeof new Date(); // objecttypeof /test/gi; // objecttypeof function () {}; // functiontypeof undefined; // undefinedtypeof null; // object (설계적 결함)typeof undeclared; // undefined (설계적 결함) 그런데 typeof 연산자는 null과 배열의 경우 object, 함수의 경우 function를 반환하고, Date, RegExp, 사용자 정의 객체 등 거의 모든 객체의 경우, object를 반환한다. 따라서 typeof는 null을 제외한 원시 타입을 체크하는 데는 문제가 없지만 객체의 종류까지 구분하여 체크하려할 때는 사용하기는 곤란하다. 여러 종류의 객체(일반 객체, 배열, Date, RegExp, Function, DOM 요소 등)를 구분할 수 있는 타입 체크 기능을 만들어보자. 2. Object.prototype.toStringObject.prototype.toString 메소드는 개체를 나타내는 문자열을 반환한다. 12var obj = new Object();obj.toString(); // [object Object] Funciton.prototype.call 메소드를 사용하면 모든 타입의 값의 타입을 알아낼 수 있다. 12345678910111213141516171819Object.prototype.toString.call(''); // [object String]Object.prototype.toString.call(new String()); // [object String]Object.prototype.toString.call(1); // [object Number]Object.prototype.toString.call(new Number()); // [object Number]Object.prototype.toString.call(NaN); // [object Number]Object.prototype.toString.call(Infinity); // [object Number]Object.prototype.toString.call(true); // [object Boolean]Object.prototype.toString.call(undefined); // [object Undefined]Object.prototype.toString.call(); // [object Undefined]Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call([]); // [object Array]Object.prototype.toString.call({}); // [object Object]Object.prototype.toString.call(new Date()); // [object Date]Object.prototype.toString.call(Math); // [object Math]Object.prototype.toString.call(/test/i); // [object RegExp]Object.prototype.toString.call(function () {}); // [object Function]Object.prototype.toString.call(document); // [object HTMLDocument]Object.prototype.toString.call(argument); // [object Arguments]Object.prototype.toString.call(undeclared); // ReferenceError 이것을 이용하여 타입을 반환하는 함수를 만들어보자. 123function getType(target) { return Object.prototype.toString.call(target).slice(8, -1);} String.prototype.slice 메소드를 사용하여 Object.prototype.toString.call 메소드가 반환한 문자열에서 “[object”와 “]”를 제외하고 타입을 나타내는 문자열만을 추출하였다. 1234567891011getType(''); // StringgetType(1); // NumbergetType(true); // BooleangetType(undefined); // UndefinedgetType(null); // NullgetType({}); // ObjectgetType([]); // ArraygetType(/test/i); // RegExpgetType(Math); // MathgetType(new Date()); // DategetType(function () {}); // Function 이제 앞에서 살펴본 sum 함수에 타입 체크 기능을 추가해 보자. 12345678910function sum(a, b) { // a와 b가 number 타입인지 체크 if (getType(a) !== 'Number' || getType(b) !== 'Number') { throw new TypeError('파라미터에 number 타입이 아닌 값이 할당되었습니다.'); } return a + b;}console.log(sum(10, 20)); // 30console.log(sum('10', 20)); // TypeError 타입별로 체크하는 기능을 만들려면 아래와 같이 함수를 작성한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243function getType(target) { return Object.prototype.toString.call(target).slice(8, -1);}function isString(target) { return getType(target) === 'String';}function isNumber(target) { return getType(target) === 'Number';}function isBoolean(target) { return getType(target) === 'Boolean';}function isNull(target) { return getType(target) === 'Null';}function isUndefined(target) { return getType(target) === 'Undefined';}function isObject(target) { return getType(target) === 'Object';}function isArray(target) { return getType(target) === 'Array';}function isDate(target) { return getType(target) === 'Date';}function isRegExp(target) { return getType(target) === 'RegExp';}function isFunction(target) { return getType(target) === 'Function';} 3. instanceof이와 같이 Object.prototype.toString를 사용하여 객체의 종류(일반 객체, 배열, Date, RegExp, Function, DOM 요소 등)까지 식별할 수 있는 타입 체크 기능을 작성하였다. 그런데, 이 방법으로는 객체의 상속관계까지 체크할 수는 없다. 12345678// HTMLElement를 상속받은 모든 DOM 요소에 css 프로퍼티를 추가하고 값을 할당한다.function css(elem, prop, val) { // type checking... elem.style[prop] = val;}css({}, 'color', 'red');// TypeError: Cannot set property 'color' of undefined css 함수의 첫번째 매개변수에는 반드시 HTMLElement를 상속받은 모든 DOM 요소를 전달하여야 한다. 다시말해, css 함수의 첫번째 매개변수에는 HTMLDivElement, HTMLUListElement, HTMLLIElement, HTMLParagraphElement 등 모든 DOM 요소가 전달될 수 있다. 이를 일일이 체크할 수는 없기 때문에 HTMLElement를 상속받은 객체, 즉 DOM 요소인지 확인하여야 한다. 타입 연산자(Type Operator)에는 앞서 살펴본 typeof 이외에 instanceof를 제공한다. instanceof 연산자는 피연산자인 객체가 우항에 명시한 타입의 인스턴스인지 여부를 알려준다. 이때 타입이란 constructor를 말하며 프로토타입 체인에 존재하는 모든 constructor를 검색하여 일치하는 constructor가 있다면 true를 반환한다. 12345function Person() {}const person = new Person();console.log(person instanceof Person); // trueconsole.log(person instanceof Object); // true 이를 이용해 css 함수에 타입 체크 기능을 추가해 보자. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;script&gt; function getType(target) { return Object.prototype.toString.call(target).slice(8, -1); } function isString(target) { return getType(target) === 'String'; } function isElement(target) { return !!(target &amp;&amp; target instanceof HTMLElement); // 또는 `nodeType`을 사용할 수도 있다. // return !!(target &amp;&amp; target.nodeType === 1); } // HTMLElement를 상속받은 모든 DOM 요소에 css 프로퍼티를 추가하고 값을 할당한다. function css(elem, prop, val) { // type checking if (!(isElement(elem) &amp;&amp; isString(prop) &amp;&amp; isString(val))) { throw new TypeError('매개변수의 타입이 맞지 않습니다.'); } elem.style[prop] = val; } css(document.querySelector('p'), 'color', 'red'); css(document.querySelector('div'), 'color', 'red'); // TypeError: 매개변수의 타입이 맞지 않습니다. &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. 유사 배열 객체배열인지 체크하기 위해서는 Array.isArray 메소드를 사용한다. 123console.log(Array.isArray([])); // trueconsole.log(Array.isArray({})); // falseconsole.log(Array.isArray('123')); // false 유사 배열 객체(array-like object)은 length 프로퍼티를 갖는 객체로 문자열, arguments, HTMLCollection, NodeList 등은 유사 배열이다. 유사 배열 객체는 length 프로퍼티가 있으므로 순회할 수 있으며 call, apply 함수를 사용하여 배열의 메소드를 사용할 수도 있다. 어떤 객체가 유사 배열인지 체크하려면 우선 length 프로퍼티를 갖는지 length 프로퍼티의 값이 정상적인 값인지 체크한다. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; console.log(undefined == null) const isArrayLike = function (collection) { // 배열 인덱스: 32bit 정수(2의 32제곱 - 1) // 유사 배열 인덱스: 자바스크립트로 표현할 수 있는 양의 정수(2의 53제곱 - 1) const MAX_ARRAY_INDEX = Math.pow(2, 53) - 1; // 빈문자열은 유사배열이다. undefined == null =&gt; true const length = collection == null ? undefined : collection.length; return typeof length === 'number' &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX; }; // true console.log(isArrayLike([])); console.log(isArrayLike('abc')); console.log(isArrayLike('')); console.log(isArrayLike(document.querySelectorAll('li'))); console.log(isArrayLike(document.getElementsByName('li'))); console.log(isArrayLike({ length: 0 })); (function () { console.log(isArrayLike(arguments)); }()); // false console.log(isArrayLike(123)); console.log(isArrayLike(document.querySelector('li'))); console.log(isArrayLike({ foo: 1 })); console.log(isArrayLike()); console.log(isArrayLike(null)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Referencepoiemaweb.com/js-type-check","link":"/2021/08/03/js-day10-typechecking/"},{"title":"js-day11-prototype","text":"1. Prototype 객체Java, C++과 같은 클래스 기반 객체지향 프로그래밍 언어와 달리 자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어이다. 따라서 자바스크립트의 동작 원리를 이해하기 위해서는 프로토타입의 개념을 잘 이해하고 있어야 한다. 클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체(인스턴스)를 생성한다. 하지만 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이(Class-less)도 객체를 생성할 수 있다. 자바스크립트의 객체 생성방법 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입)객체 또는 줄여서 Prototype(프로토타입)이라 한다. Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다. 123456789var student = { name: 'Lee', score: 90};// student에는 hasOwnProperty 메소드가 없지만 아래 구문은 동작한다.console.log(student.hasOwnProperty('name')); // trueconsole.dir(student); ECMAScript spec에서는 자바스크립트의 모든 객체는 [[Prototype]]이라는 이터널 슬롯(internal slot)를 가진다. [[Prototype]]의 값은 null 또는 객체이며 상속을 구현하는데 사용된다. [[Prototype]] 객체의 데이터 프로퍼티는 get 액세스를 위해 상속되어 자식 객체의 프로퍼티처럼 사용할 수 있다. 하지만 set 액세스는 허용되지 않는다. 라고 되어있다. [[Prototype]]의 값은 Prototype(프로토타입)객체이며 __proto__ accessor property로 접근할 수 있다. __proto__프로퍼티에 접근하면 내부적으로 Object.getPrototypeOf가 호출되어 프로토타입 객체를 반환한다. student 객체는 __proto__ 프로퍼티로 자신의 부모 객체(프로토타입 객체)인 Object.prototype을 가리키고 있다. 12345var student = { name: 'Lee', score: 90}console.log(student.__proto__ === Object.prototype); // true 객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다. 2. [[Prototype]] vs prototype 프로퍼티모든 객체는 자신의 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯(internal slot)을 갖으며 상속을 위해 사용된다. 함수도 객체이므로 [[Prototype]] 인터널 슬롯을 갖는다. 그런데 함수 객체는 일반 객체와는 달리 prototype 프로퍼티도 소유하게 된다. 주의해야 할 것은 prototype 프로퍼티는 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯은 다르다는 것이다. prototype 프로퍼티와 [[Prototype]]은 모두 프로토타입 객체를 가리키지만 관점의 차이가 있다. 12345678function Person(name) { this.name = name;}var foo = new Person('Lee');console.dir(Person); // prototype 프로퍼티가 있다.console.dir(foo); // prototype 프로퍼티가 없다. [[Prototype]] 함수 객체만 가지고 있는 프로퍼티이다. 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성 될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킨다. 1console.log(Person.prototype === foo.__proto__); 3. constructor 프로퍼티프로토타입 객체는 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다. 예를 들어 Person() 생성자 함수에 의해 생성된 객체를 foo라 하자. 이 foo 객체를 생성한 객체는 Person() 생성자 함수이다. 이때 foo 객체 입장에서 자신을 생성한 객체는 Person() 생성자 함수이며, foo 객체의 프로토타입 객체는 Person.prototype이다. 따라서 프로토타입 객체 Person.prototype 의 constructor 프로퍼티는 Person() 생성자 함수를 가리킨다. 1234567891011121314function Person(name) { this.name = name;}var foo = new Person('Lee');// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.console.log(Person.prototype.constructor === Person);// foo 객체를 생성한 객체는 Person() 생성자 함수이다.console.log(foo.constructor === Person);// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.console.log(Person.constructor === Function); 4.Prototype chain자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]]이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다. 1234567var student = { name: 'Lee', score: 90}// Object.prototype.hasOwnProperty()console.log(student.hasOwnProperty('name')); // true student 객체는 hasOwnProperty 메소드를 가지고 있지 않으므로 에러가 발행하여야 하나 정상적으로 결과가 출력되었다. 이는 student 객체의 [[Prototype]]이 가리키는 링크를 따라가서 student 객체의 부모 역할을 하는 프로토타입 객체(Object.prototype)의 메소드 hasOwnProterty를 호출하였기 때문에 가능한 것이다. 12345678var student = { name: 'Lee', score: 90}console.dir(student);console.log(student.hasOwnProperty('name')); // trueconsole.log(student.__proto__ === Object.prototype); // trueconsole.log(Object.prototype.hasOwnProperty('hasOwnProperty')); // true 4.1 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인객체생성 방법은 3가지가 있다. 객체 리터럴 생성자 함수 Object() 생성자 함수 객체 리터럴 방식으로 생성된 객체는 결국 내장함수(Built-in)인 Object() 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object() 생성자 함수를 사용하여 객체를 생성한다. Object() 생성자 함수는 물론 함수이다. 따라서 함수 객체인 Object() 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다. prototype 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체, 즉 프로토타입 객체를 가리킨다. [[Prototype]]은 객체의 입장에서 자신의 부모 역할을 하는 객체, 즉 프로토타입 객체를 가리킨다. 1234567891011121314var person = { name: 'Lee', gender: 'male', sayHello: function(){ console.log('Hi! my name is ' + this.name); }};console.dir(person);console.log(person.__proto__ === Object.prototype); // ① trueconsole.log(Object.prototype.constructor === Object); // ② trueconsole.log(Object.__proto__ === Function.prototype); // ③ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ④ true 결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 Object.prototype이다. 4.2 생성자 함수로 생성된 객체의 프로토타입 체인생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다. 함수를 정의하는 방식은 3가지가 있다. 함수선언식(Function declaration) 함수표현식(Funciton expression) Funciton() 생성자 함수 함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다. 123var square = function(number) { return number * number;}; 함수 선언식의 경우 자바스크립트 엔진이 내부적으로 기명 함수표현식으로 변환한다. 123var square = function square(number) { return number * number;}; 결국 함수선언식, 함수표현식 모두 함수 리터럴 방식을 사용한다. 함수 리터럴 방식은 Function() 생성자 함수로 함수를 생성하는 것을 단순화 시킨것이다. 즉, 3자기 함수 정의 방식은 결국 Function() 생성자 함수를 통해 함수 객체를 생성한다, 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 prototype 객체는 Function.prototype이다. 생성자 함수도 함수 객체이므로 생성자 함수의 prototyupe 객체는 Function.prototype이다. 이제 객체의 관점에서 prototype 객체를 살펴보자. 객체를 생성하는 방식은 3가지가 있다. 3가지 객체 생성 방식에 의해 생성된 객체의 prototype 객체를 정리해 보면 아래와 같다. 객체 생성 방식 엔진의 객체 생성 인스턴스의 prototype 객체 객체 리터럴 Object() 생성자 함수 Object.prototype Object() 생성자 함수 Object() 생성자 함수 Object.prototype 생성자 함수 생성자 함수 생성자 함수 이름.prototype 123456789101112131415161718function Person(name, gender) { this.name = name; this.gender = gender; this.sayHello = function(){ console.log('Hi! my name is ' + this.name); };}var foo = new Person('Lee', 'male');console.dir(Person);console.dir(foo);console.log(foo.__proto__ === Person.prototype); // ① trueconsole.log(Person.prototype.__proto__ === Object.prototype); // ② trueconsole.log(Person.prototype.constructor === Person); // ③ trueconsole.log(Person.__proto__ === Function.prototype); // ④ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true foo 객체의 프로토타입 객체 Person.prototype 객체와 Person() 생성자 함수의 프로토타입 객체인 Function.prototype의 프로토타입 객체는 Object.prototype 객체이다. 이는 객체 리터럴 방식이나 생성자 함수 방식이나 결국은 모든 객체의 부모 객체인 Object.prototype 객체에서 프로토타입 체인이 끝나기 때문이다. 이때 Object.prototype 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다. 5. 프로토타입 객체의 확장프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다. 1234567891011function Person(name) { this.name = name;}var foo = new Person('Lee');Person.prototype.sayHello = function(){ console.log('Hi! my name is ' + this.name);};foo.sayHello(); 생성자 함수 Person은 프로토타입 객체 Person.prototype와 prototype 프로퍼티에 의해 바인딩되어 있다. Person.prototype 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다. 위의 예에서는 Person.prototype 객체에 메소드 sayHello를 추가하였다. 이때 sayHello 메소드는 프로토타입 체인에 반영된다. 따라서 생성자 함수 Person에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 Person.prototype의 메소드를 사용할 수 있게 되었다. 6. 원시 타입(Primitive data type)의 확장자바스크립트에서 원시 타입(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 그런데 아래 예제를 살펴보면 원시 타입인 문자열이 객체와 유사하게 동작한다. 12345678910111213var str = 'test';console.log(typeof str); // stringconsole.log(str.constructor === String); // trueconsole.dir(str); // testvar strObj = new String('test');console.log(typeof strObj); // objectconsole.log(strObj.constructor === String); // trueconsole.dir(strObj);// {0: &quot;t&quot;, 1: &quot;e&quot;, 2: &quot;s&quot;, 3: &quot;t&quot;, length: 4, __proto__: String, [[PrimitiveValue]]: &quot;test&quot; }console.log(str.toUpperCase()); // TESTconsole.log(strObj.toUpperCase()); // TEST 원시 타입 문자열과 String() 생성자 함수로 생성한 문자열 객체의 타입은 분명이 다르다. 원시 타입은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 원시타입으로 프로퍼티나 메소드를 호출할 때 원시 타입과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다. 원시 타입은 객체가 아니므로 프로퍼티나 메소드를 직접 추가할 수 없다. 12345678var str = 'test';// 에러가 발생하지 않는다.str.myMethod = function () { console.log('str.myMethod');};str.myMethod(); // Uncaught TypeError: str.myMethod is not a function 하지만 String 객체의 프로토타입 객체 String.prototype에 메소드를 추가하면 원시 타입, 객체 모두 메소드를 사용할 수 있다. 123456789var str = 'test';String.prototype.myMethod = function () { return 'myMethod';};console.log(str.myMethod()); // myMethodconsole.log('string'.myMethod()); // myMethodconsole.dir(String.prototype); 앞서 살펴본 바와 같이 모든 객체는 프로토타입 체인에 의해 Object.prototype 객체의 메소드를 사용할 수 있었다. Object.prototype 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다. 이후 살펴보게 될 Built-in object(내장 객체)의 Global objects (Standard Built-in Objects)인 String, Number, Array 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 String.prototype, Number.prototype, Array.prototype 등에 정의되어 있다. 이들 프로토타입 객체 또한 Object.prototype를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다. 자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다. 1234567891011121314var str = 'test';String.prototype.myMethod = function() { return 'myMethod';}console.log(str.myMethod());console.dir(String.prototype);console.log(str.__proto__ === String.prototype); // ① trueconsole.log(String.prototype.__proto__ === Object.prototype); // ② trueconsole.log(String.prototype.constructor === String); // ③ trueconsole.log(String.__proto__ === Function.prototype); // ④ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true 7. 프로토타입 객체의 변경객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다. 이때 주의할 것은 프로토타입 객체를 변경하면 프로토타입 객체 변경 시점 이젠에 생성된 객체: 기존 프로토타입 객체를 [[Prototype]]에 바인딩한다. 프로토타입 객체 변경 시점 이후에 생성된 객체:변경된 프로토타입 객체를 [[Prototype]]에 바인딩한다. 12345678910111213141516function Person(name) { this.name = name;}var foo = new Person('Lee');// 프로토타입 객체의 변경Person.prototype = { gender: 'male' };var bar = new Person('Kim');console.log(foo.gender); // undefinedconsole.log(bar.gender); // 'male'console.log(foo.constructor); // ① Person(name)console.log(bar.constructor); // ② Object() construnctor 프로퍼티는 Person() 생성자 함수를 가리킨다. 프로토타입 객체 변경 후, Person() 생성자 함수의 Prototype 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 Person.prototype.constructor 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 bar.constructor의 값은 프로토타입 체이닝에 의해 Object.prototype.constructor 즉 Object() 생성자 함수가 된다. 8. 프로토타입 체인 동작 조건객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작한다. 객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다. 123456789101112131415161718function Person(name) { this.name = name;}Person.prototype.gender = 'male'; // ①var foo = new Person('Lee');var bar = new Person('Kim');console.log(foo.gender); // ① 'male'console.log(bar.gender); // ① 'male'// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당foo.gender = 'female'; // ②console.log(foo.gender); // ② 'female'console.log(bar.gender); // ① 'male' foo 객체의 gender 프로퍼티에 값을 할당하면 프로토타입 체인이 발생하여 Person.prototype 객체의 gender 프로퍼티에 값을 할당하는 것이 아니라 foo 객체에 프로퍼티를 동적으로 추가한다. Referencepoiemaweb.com/js-prototype","link":"/2021/08/04/js-day11-prototype/"},{"title":"js-day12-scope","text":"1. 스코프란?스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 개념으로 확실한 이해가 필요하다. 먼저 아래 예제의 실행 결과에 대해 생각해보자. 123456789var x = 'global';function foo () { var x = 'function scope'; console.log(x);}foo(); // ?console.log(x); // ? 이름이 같은 변수 x가 중복 선언되었다. 전역에서 변수 x를 참조할 때, 그리고 함수 foo 내부에서 변수 x를 참조할 때 이름이 중복된 2개의 변수 중 어떤 변수를 참조해야 하는가? 자바스크립트는 어떻게 변수를 식별하는 것일까? 스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. 자바스크립트는 이 규칙대로 식별자를 찾는다. 프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며 이것으로 프로그램의 상태를 관리할 수 있다. 변수는 전역 또는 코드 블록(if, for, while, try/catch 등)이나 함수 내에 선언하며 코드 블록이나 함수는 중첩될 수 있다. 식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 갖는다. 위 예제에서 전역에 선언된 변수 x는 어디에든 참조할 수 있다. 하지만 함수 foo 내에서 선언된 변수 x는 함수 foo 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없다. 이러한 규칙을 스코프라고 한다. 2. 스코프의 구분자바스크립트에서 스코프를 구분해보면 다음과 같이 2가지로 나눌 수 있다. 전역 스코프(Global scope)코드 어디에서든지 참조할 수 있다. 지역 스코프(Local scope or Function-level scope)함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다. 모든 변수는 스코프를 갖는다. 변수의 관점에서 스코프를 구분하면 다음과 같이 2가지로 나눌 수 있다. 전역변수(Global variable)전역에서 선언된 변수이며 어디에든 참조할 수 있다. 지역변수(Local variable)지역(함수)내에서 선언된 변수이며 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다. 변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가지게 된다. 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다. 전역 스코프를 갖는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다. 3. 자바스크립트 스코프의 특징자바스크립트의 스코프는 타 언어와는 다른 특징을 가지고 있다. 대부분의 C-family language는 블록 레벨 스코프(block-level scope)를 따른다. 블록 레벨 스코프란 코드 블록({…})내에서 유효한 스코프를 의미한다. 여기서 “유효하다”라는 것은 “참조(접근)할 수 있다”라는 뜻이다. 1234567891011int main(void) { // block-level scope if (1) { int x = 5; printf(&quot;x = %d\\n&quot;, x); } printf(&quot;x = %d\\n&quot;, x); // use of undeclared identifier 'x' return 0;} 위의 C언어 코드를 보면 if문 내에서 선언된 변수 x는 if문 코드 블록 내에서만 유효하다. 즉, if문 코드 블록 밖에서는 참조가 불가능하다. 하지만 자바스크립트는 함수 레벨 스코프를 따른다. 함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것이다. 단, ECMAScript 6에서 도입된 let keyword를 사용하면 블록 레벨 스코프를 사용할 수 있다. 12345678910111213var x = 0;{ var x = 1; console.log(x); // 1}console.log(x); // 1let y = 0;{ let y = 1; console.log(y); // 1}console.log(y); // 0 4. 전역 스코프(Global scope)전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 전역 스코프를 갖는 전역 변수가 된다. var 키워드로 선언한 전역 변수는 전역 객체(Global Object) window의 프로퍼티이다. 1234567891011var global = 'global';function foo() { var local = 'local'; console.log(global); console.log(local);}foo();console.log(global);console.log(local); // Uncaught ReferenceError: local is not defined 변수 global는 함수 영역밖의 전역에서 선언되었다. 자바스크립트는 타 언어와는 달리 특별한 시작점(Entry point)이 없어서 위 코드와 같이 전역에 변수나 함수를 선언하기 쉽다. C언어의 경우 main 함수가 시작점이 되기 때문에 대부분은 코드는 main 함수 내에 포함된다. C언어의 경우 전역 변수를 선언하기 위해서는 의도적으로 main함수 밖에 변수를 선언하여야 한다. 12345678910111213141516171819#include &lt;stdio.h&gt;/* global variable declaration */int g;int main () { // local variable declaration int a, b; // actual initialization a = 10; b = 20; g = a + b; printf (&quot;value of a = %d, b = %d and g = %d\\n&quot;, a, b, g); return 0;} 하지만 자바스크립트는 다른 C-family language와는 달리 특별한 시작점이 없으며 코드가 나타나는 즉시 해석되고 실행된다. 따라서 전역에 변수를 선언하기 쉬우며 이것는 전역 변수를 남발하게 하는 문제를 야기시킨다. 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 사용을 억제하여야 한다. 5. 비 블록 레벨 스코프(Non block-level scope)1234if (true) { var x = 5;}console.log(x); 변수 x는 코드 블록 내에서 선언되었다. 하지만 자바스크립트는 블록 레벨 스코프를 사용하지 않으므로 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 스코프를 갖게된다. 따라서 변수 x는 전역 변수이다. 6. 함수 레벨 스코프(Function-level scope)12345678var a = 10; // 전역변수(function () { var b = 20; // 지역변수})();console.log(a); // 10console.log(b); // &quot;b&quot; is not defined 자바스크립트는 함수 레벨 스코프를 사용한다. 즉, 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다. 따라서 변수 b는 지역변수이다. 123456789var x = 'global';function foo() { var x = 'local'; console.log(x);}foo(); // localconsole.log(x); // global 전역변수 x와 지역변수 x가 중복 선언되었다. 전역 영역에서는 전역변수만이 참조 가능하고 함수 내 지역 영역에서는 전역과 지역 변수 모두 참조 가능하나 위 예제와 같이 변수명이 중복된 경우, 지역변수를 우선하여 참조한다. 다음은 함수 내에 존재하는 함수인 내부 함수의 경우를 살펴보자. 1234567891011121314var x = 'global';function foo() { var x = 'local'; console.log(x); function bar() { // 내부함수 console.log(x); // ? } bar();}foo();console.log(x); // ? 내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다. 이는 매우 유용하다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보인다. 함수 bar에서 참조하는 변수 x는 함수 foo에서 선언된 지역변수이다. 이는 실행 컨텍스트의 스코프 체인에 의해 참조 순위에서 전역변수 x가 뒤로 밀렸기 때문이다. 12345678var x = 10;function foo() { x = 100; console.log(x);}foo();console.log(x); // ? 함수(지역) 영역에서 전역변수를 참조할 수 있으므로 전역변수의 값도 변경할 수 있다. 내부 함수의 경우, 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능하다. 123456789101112131415var x = 10;function foo(){ var x = 100; console.log(x); function bar(){ // 내부함수 x = 1000; console.log(x); // ? } bar();}foo();console.log(x); // ? 중첩 스코프는 가장 인접한 지역을 우선하여 참조한다. 12345678910111213var foo = function ( ) { var a = 3, b = 5; var bar = function ( ) { var b = 7, c = 11; // 이 시점에서 a는 3, b는 7, c는 11 a += b + c; // 이 시점에서 a는 21, b는 7, c는 11 }; // 이 시점에서 a는 3, b는 5, c는 not defined bar( ); // 이 시점에서 a는 21, b는 5}; 7. 렉시컬 스코프12345678910111213var x = 1;function foo() { var x = 10; bar();}function bar() { console.log(x);}foo(); // ?bar(); // ? 위 예제의 실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있는데 첫번째는 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것이고 두번째는 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것이다. 첫번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고, 두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다. 프로그래밍 언어는 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다. 첫번째 방식을 동적 스코프(Dynamic scope)라 하고, 두번째 방식을 렉시컬 스코프(Lexical scope) 또는 정적 스코프(Static scope)라 한다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다. **렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다. ** 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다. 위 예제의 함수 bar는 전역에 선언되었다. 따라서 함수 bar의 상위 스코프는 전역 스코프이고 위 예제는 전역 변수 x의 값 1을 두번 출력한다. 8. 암묵적 전역123456789var x = 10; // 전역 변수function foo () { // 선언하지 않은 식별자 y = 20; console.log(x + y);}foo(); // 30 위 예제의 y는 선언하지 않은 식별자이다. 따라서 y = 20이 실행되면 참조 에러가 발생할 것처럼 보인다. 하지만 선언하지 않은 식별자 y는 마치 선언된 변수처럼 동작한다. 이는 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기 때문이다. foo 함수가 호출되면 자바스크립트 엔진은 변수 y에 값을 할당하기 위해 먼저 스코프 체인을 통해 선언된 변수인지 확인한다. 이때 foo 함수의 스코프와 전역 스코프 어디에서도 변수 y의 선언을 찾을 수 없으므로 참조 에러가 발생해야 하지만 자바스크립트 엔진은 y = 20을 window.y = 20으로 해석하여 프로퍼티를 동적 생성한다. 결국 y는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다. 이러한 현상을 암묵적 전역(implicit global)이라 한다. 하지만 y는 변수 선언없이 단지 전역 객체의 프로퍼티로 추가되었을 뿐이다. 따라서 y는 변수가 아니다. 따라서 변수가 아닌 y는 변수 호이스팅이 발생하지 않는다. 1234567891011121314// 전역 변수 x는 호이스팅이 발생한다.console.log(x); // undefined// 전역 변수가 아니라 단지 전역 프로퍼티인 y는 호이스팅이 발생하지 않는다.console.log(y); // ReferenceError: y is not definedvar x = 10; // 전역 변수function foo () { // 선언하지 않은 변수 y = 20; console.log(x + y);}foo(); // 30 또한 변수가 아니라 단지 프로퍼티인 y는 delete 연산자로 삭제할 수 있다. 전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다. 123456789101112131415161718var x = 10; // 전역 변수function foo () { // 선언하지 않은 변수 y = 20; console.log(x + y);}foo(); // 30console.log(window.x); // 10console.log(window.y); // 20delete x; // 전역 변수는 삭제되지 않는다.delete y; // 프로퍼티는 삭제된다.console.log(window.x); // 10console.log(window.y); // undefined 9. 최소한의 전역변수 사용전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역변수 객체 하나를 만들어 사용하는 것이다. (더글라스 크락포드의 제안) 12345678var MYAPP = {};MYAPP.student = { name: 'Lee', gender: 'male'};console.log(MYAPP.student.name); 10. 즉시실행함수를 이용한 전역변수 사용 억제전역변수 사용을 억제하기 위해, 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다. 이 방법을 사용하면 전역변수를 만들지 않으므로 라이브러리 등에 자주 사용된다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다. 123456789101112(function () { var MYAPP = {}; MYAPP.student = { name: 'Lee', gender: 'male' }; console.log(MYAPP.student.name);}());console.log(MYAPP.student.name); Referencepoiemaweb.com/js-scope","link":"/2021/08/09/js-day12-scope/"},{"title":"js-day13-strictmode","text":"1. strict mode란?12345function foo() { x = 10;}console.log(x); // ? foo 함수 내에서 선언하지 않은 변수 x에 값 10을 할당하였다. 이때 변수 x를 찾아야 x에 값을 할당할 수 있기 때문에 자바스크립트 엔진은 변수 x가 어디에서 선언되었는지 스코프 체인을 통해 검색하기 시작한다. 자바스크립트 엔진은 먼저 foo 함수의 스코프에서 변수 x의 선언을 검색한다. foo 함수의 스코프에는 변수 x의 선언이 없으므로 검색에 실패할 것이고, 자바스크립트 엔진은 변수 x를 검색하기 위해 foo함수 컨텍스트의 상위 스코프(위 예제의 경우, 전역 스코프)에서 변수 x의 선언을 검색한다. 전역 스코프에도 변수 x의 선언이 존재하지 않기 때문에 ReferenceError를 throw할 것 같지만 자바스크립트 엔진은 암묵적으로 전역 객체에 프로퍼티 x를 동적 생성한다. 결국 식별자 x는 전역 변수가 된다. 이렇게 전역 변수가 된 변수를 암묵적 전역 변수(implicit global) 라 한다. 개발자의 의도와는 상관없이 자바스크립트 엔진이 생성한 암묵적 전역 변수는 오류를 발생시키는 원인이 될 가능성이 크다. 따라서 반드시 var, let, const 키워드를 사용하여 변수를 선언한 다음 변수를 사용해야 한다. 하지만, 오타나 문법 지식의 미비로 인한 실수는 언제나 발생하는 것이다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 보다 근본적인 접근이 필요하다. 다시 말해, 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발을 하는 것이 보다 근본적인 해결책이라고 할 수 있다. 이를 지원하기 위해 ES5부터 strict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대한 명시적인 에러를 발생시킨다. ESLint와 같은 린트 도구를 사용하여도 strict mode와 유사한 효과를 얻을 수 있다. 린트 도구는 정적 분석(static analysis) 기능을 통해 소스 코드를 실행하기 전에 소스 코드를 스캔하여 문법적 오류만이 아니라 잠재적 오류까지 찾아내고 오류의 이유를 리포팅해주는 유용한 도구이다. 또한 strict mode가 제한하는 오류는 물론 코딩 컨벤션을 설정 파일 형태로 정의하고 강제할 수 있기 때문에 보다 강력한 효과를 얻을 수 있다. strict mode의 적용 방법과 strict mode가 발생시키는 에러에 대해 간략히 살펴보도록 하자. 2. strict mode의 적용strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 ‘use strict’; 를 추가한다. 전역의 선두에 추가하면스크립트 전체에 strict mode가 적용된다. 1234567// 전역에 strict mode의 적용하는 것은 바람직하지 않다!'use strict';function foo() { x = 10; // ReferenceError: x is not defined}foo(); 함수 몸체의 선두에 추가하면 해당 함수와 중첩된 내부 함수에 strict mode가 적용된다. 1234567// 함수 단위로 strict mode 적용function foo() { 'use strict'; x = 10; // ReferenceError: x is not defined}foo(); 코드의 선두에 strict mode를 위치시키지 않으면 제대로 동작하지 않는다. 12345function foo() { x = 10; // 에러를 발생시키지 않는다. 'use strict';}foo(); 3. 전역에 strict mode를 적용하는 것은 피하자.전역에 적용한 strict mode는 스크립트 단위로 적용된다. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; 'use strict'; &lt;/script&gt; &lt;script&gt; x = 1; // 에러가 발생하지 않는다. console.log(x); // 1 &lt;/script&gt; &lt;script&gt; 'use strict'; y = 1; // ReferenceError: y is not defined console.log(y); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제와 같이 스크립트 단위로 적용된 strict mode는 다른 스크립트에 영향을 주지 않고 자신의 스크립트에 한정되어 적용된다. 하지만 strict mode 스크립트와 non-strict mode 스크립트를 혼용하는 것은 오류를 발생시킬 수 있다. 특히 외부 서드 파티 라이브러리를 사용하는 경우, 라이브러리가 non-strict mode일 경우도 있기 때문에 전역에 strict mode를 적용하는 것은 바람직하지 않다. 이러한 경우, 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다. 123456// 즉시실행 함수에 strict mode 적용(function () { 'use strict'; // Do something...}()); 따라서 strict mode는 즉시실행함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다. 5. strict mode가 발생시키는 에러다음은 strict mode를 적용했을 때의 에러가 발생하는 대표적인 사례이다. 5.1 암묵적 전역 변수선언하지 않은 변수를 참조하면 ReferenceError가 발생한다. 123456(function () { 'use strict'; x = 1; console.log(x); // ReferenceError: x is not defined}()); 5.2 변수, 함수, 매개변수의 삭제1234567891011121314(function () { 'use strict'; var x = 1; delete x; // SyntaxError: Delete of an unqualified identifier in strict mode. function foo(a) { delete a; // SyntaxError: Delete of an unqualified identifier in strict mode. } delete foo; // SyntaxError: Delete of an unqualified identifier in strict mode.}()); 5.3 매개변수 이름의 중복중복된 함수 파라미터 이름을 사용하면 SyntaxError가 발생한다. 123456789(function () { 'use strict'; //SyntaxError: Duplicate parameter name not allowed in this context function foo(x, x) { return x + x; } console.log(foo(1, 2));}()); 5.4 with 문의 사용with 문을 사용하면 SyntaxError가 발생한다. 12345678(function () { 'use strict'; // SyntaxError: Strict mode code may not include a with statement with({ x: 1 }) { console.log(x); }}()); 5.5 일반 함수의 thisstrict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다. 이때 에러는 발생하지 않는다. 12345678910111213(function () { 'use strict'; function foo() { console.log(this); // undefined } foo(); function Foo() { console.log(this); // Foo } new Foo();}()); 6. 브라우저 호환성IE 9이하는 지원하지 않는다. Referencepoiemaweb.com/js-strict-mode","link":"/2021/08/11/js-day13-strictmode/"},{"title":"js-day15-this","text":"함수 호출 방식에 의해 결정되는 this자바스크립트의 함수는 호출될 때, 매개변수로 전달 되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다. 123456789function square(number) { console.log(arguments); console.log(this); return number * number;}square(2); 자바스크립트의 this keyword는 Java와 같은익숙한 언어의 개념과 달라 개발자에게 혼란을 준다. Java에서의 this는 인스턴스 자신(self)을 가리키는 참조변수이다. this가 객체 자신에 대한 참조 값을 가지고 있다는 뜻이다. 주로 매개변수와 객체 자신이 가지고 있는 멤버변수명이 같을 경우 이를 구분하기 위해서는 사용된다. 아래 Java 코드의 생성자 함수 내의 this.name은 멤버변수를 의미하며 name은 생성자 함수가 전달받은 매개변수를 의미한다. 12345678public Class Person { private String name; public Person(String name) { this.name = name; }} 하지만 자바스크립트의 경우 Java와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 방식에 따라 this에 바인딩되는 객체가 달라진다. 함수 호출 방식과 this 바인딩자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정된다. 다시말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결저오디는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(Lexical scope)는 함수를 선언할 때 결정된다. this 바인딩과 혼동하지 않도록 주의하기 바란다. 함수의 호출하는 방식은 아래와 같이 다양하다. 함수 호출 메소드 호출 생성자 함수 호출 apply/call/bind 호출 1234567891011121314151617181920var foo = function () { console.dir(this);};// 1. 함수 호출foo(); // window// window.foo();// 2. 메소드 호출var obj = { foo: foo };obj.foo(); // obj// 3. 생성자 함수 호출var instance = new foo(); // instance// 4. apply/call/bind 호출var bar = { name: 'bar' };foo.call(bar); // barfoo.apply(bar); // barfoo.bind(bar)(); // bar 1. 함수 호출전역객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. 123456// in browser consolethis === window // true// in Terminalnodethis === global // true 전역객체는 전역 스코프(Global Scope)를 갖는 전역변수(Global variable)를 프로퍼티로 소유한다. 글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역 변수의 메소드이다. 123456789var ga = 'Global variable';console.log(ga);console.log(window.ga);function foo() { console.log('invoked!');}window.foo(); 기본적으로 this는 전역객체(Global Object)에 바인딩된다. 전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다. 12345678function foo() { console.log(&quot;foo's this: &quot;, this); // window function bar() { console.log(&quot;bar's this: &quot;, this); // window } bar();}foo(); 또한 메소드의 내부함수일 경우에도 this는 전역객체에 바인딩 된다. 12345678910111213141516var value = 1;var obj = { value: 100, foo: function() { console.log(&quot;foo's this: &quot;, this); // obj console.log(&quot;foo's this.value: &quot;, this.value); // 100 function bar() { console.log(&quot;bar's this: &quot;, this); // window console.log(&quot;bar's this.value: &quot;, this.value); // 1 } bar(); }};obj.foo(); 콜백함수의 경우에도 this는 전역객체에 바인딩된다. 12345678910111213var value = 1;var obj = { value: 100, foo: function() { setTimeout(function() { console.log(&quot;callback's this: &quot;, this); // window console.log(&quot;callback's this.value: &quot;, this.value); // 1 }, 100); }};obj.foo(); 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 this는 전역객체를 바인딩한다. 더글라스 크락포드는 “이것은 설계 단계의 결함으로 메소드가 내부함수를 사용하여 자신의 작업을 돕게 할 수 없다는 것을 의미한다” 라고 말한다. 내부함수의 this가 전역객체를 참조하는 것을 회피방법은 아래와 같다. 123456789101112131415161718192021var value = 1;var obj = { value: 100, foo: function() { var that = this; // Workaround : this === obj console.log(&quot;foo's this: &quot;, this); // obj console.log(&quot;foo's this.value: &quot;, this.value); // 100 function bar() { console.log(&quot;bar's this: &quot;, this); // window console.log(&quot;bar's this.value: &quot;, this.value); // 1 console.log(&quot;bar's that: &quot;, that); // obj console.log(&quot;bar's that.value: &quot;, that.value); // 100 } bar(); }};obj.foo(); 위 방법 이외에도 자바스크립트는 this를 명시적으로 바인딩할 수 있는 apply, call, bind 메소드를 제공한다. 12345678910111213141516171819var value = 1;var obj = { value: 100, foo: function() { console.log(&quot;foo's this: &quot;, this); // obj console.log(&quot;foo's this.value: &quot;, this.value); // 100 function bar(a, b) { console.log(&quot;bar's this: &quot;, this); // obj console.log(&quot;bar's this.value: &quot;, this.value); // 100 console.log(&quot;bar's arguments: &quot;, arguments); } bar.apply(obj, [1, 2]); bar.call(obj, 1, 2); bar.bind(obj)(1, 2); }};obj.foo(); 2. 메소드 호출함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다. 123456789101112131415var obj1 = { name: 'Lee', sayName: function() { console.log(this.name); }}var obj2 = { name: 'Kim'}obj2.sayName = obj1.sayName;obj1.sayName();obj2.sayName(); 프로토타입 객체도 메소드를 가실 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다. 12345678910111213function Person(name) { this.name = name;}Person.prototype.getName = function() { return this.name;}var me = new Person('Lee');console.log(me.getName());Person.prototype.name = 'Kim';console.log(Person.prototype.getName()); 3. 생성자 함수 호출자바스크립트의 생성자 함수는 말 그대로 객체를 생성하는 역할을 한다. 하지만 자바와 같은 객체지향 언어의 생성자 함수와는 다르게 그 형식이 정해져 있는 것이 아니라 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 이는 반대로 생각하면 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출 하면 생성자 함수처럼 동작할 수 있다. 따라서 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼란을 방지하려는 노력을 한다. 1234567891011// 생성자 함수function Person(name) { this.name = name;}var me = new Person('Lee');console.log(me); // Person&amp;nbsp;{name: &quot;Lee&quot;}// new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수로 동작하지 않는다.var you = Person('Kim');console.log(you); // undefined new 연산자와 함께 생성자 함수를 호출하면 this 바인딩이 메소드나 함수 호출 때와는 다르게 동작한다. 3.1 생성자 함수 동작 방식new 연산자와 함께 생성자 함수를 호출하면 다음과 같은 수순으로 동작한다. 빈 객체 생성 및 this 바인딩생성자 함수의 코드가 실행되기 전 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다. 그리고 생성된 빈 객체는 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. this를 통한 프로퍼티 생성생성자 함수의 코드가 실행되기 전 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다. 그리고 생성된 빈 객체는 생서자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. 생성된 객체 반환 반환문이 없는 경우, this에 바인딩된 새로 생성한 객체가 반환된다. 명시적으로 this를 반환하여도 결과는 같다. 반환문이 this가 아닌 다른 객체를 명시적으로 반환하는 경우, this가 아닌 해당 객체가 반환된다. 이때 this를 반환하지 않은 함수는 생성자 함수로서의 역할을 수행하지 못한다. 따라서 생성자 함수는 반환문을 명시적으로 사용하지 않는다. 12345678function Person(name) { // 생성자 함수 코드 실행 전 -------- 1 this.name = name; // --------- 2 // 생성된 함수 반환 -------------- 3}var me = new Person('Lee');console.log(me.name); 3.2 객체 리터럴 방식과 생성자 함수 방식의 차이객체 리터럴 방식과 생성자 함수의 차이를 비교해 보자. 12345678910111213141516171819// 객체 리터럴 방식var foo = { name: 'foo', gender: 'male'}console.dir(foo);// 생성자 함수 방식function Person(name, gender) { this.name = name; this.gender = gender;}var me = new Person('Lee', 'male');console.dir(me);var you = new Person('Kim', 'female');console.dir(you); 객체 리터럴 방식과 생성자 함수 방식의 차이는 프로토타입 객체([[Prototype]])에 있다. 객체 리터럴방식의 경우, 생성된 객체의 프로토타입 객체는 Object.prototype이다. 생성자 함수 방식의 경우, 생성된 객체의 프로토타입 객체는 Person.prototype이다. 3.3 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우일반함수와 생성자 함수에 특별한 형식적 차이는 없으며 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 그러나 객체 생성 목적으로 작성한 생성자 함수를 new 없이 호출하거나 일반함수에 new를 붙여 호출하면 오류가 발생할 수 있다. 일반함수와 생성자 함수의 호출 시 this 바인딩 방식이 다르기 때문이다. 일반 함수를 호출하면 this는 전역객체에 바인딩되지만 new 연산자와 함께 생성자 함수를 호출하면 this는 생성자 함수가 암묵적으로 생성한 빈 객체에 바인딩된다. 1234567891011function Person(name) { // new없이 호출하는 경우, 전역객체에 name 프로퍼티를 추가 this.name = name;};// 일반 함수로서 호출되었기 때문에 객체를 암묵적으로 생성하여 반환하지 않는다.// 일반 함수의 this는 전역객체를 가리킨다.var me = Person('Lee');console.log(me); // undefinedconsole.log(window.name); // Lee 생성자 함수를 new 없이 호출한 경우, 함수 Person 내부의 this는 전역객체를 가리키므로 name은 전역변수(window)에 바인딩된다. 또한 new와 함께 생성자 함수를 호출하는 경우에 암묵적으로 반환하던 this도 반환하지 않으며, 반환문이 없으므로 undefined를 반환하게 된다. 일반함수와 생성자 함수에 특별한 형식적 차이는 없기 때문에 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼란을 방지하려는 노력을 한다. 그러나 이러한 규칙을 사용한다 하더라도 실수는 발생할 수 있다. 이러한 위험성을 회피하기 위해 사용되는 패턴(Scope-Safe Constructor)은 다음과 같다. 이 패턴은 대부분의 라이브러리에서 광범위하게 사용된다. 참고로 대부분의 빌트인 생성자(Object, Regex, Array 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다. 다시 말하지만 new 연산자와 함께 생성자 함수를 호출하는 경우, 생성자 함수 내부의 this는 생성자 함수에 의해 생성된 인스턴스를 가리킨다. 따라서 아래 A 함수가 new 연산자와 함께 생성자 함수로써 호출되면 A 함수 내부의 this는 A 생성자 함수에 의해 생성된 인스턴스를 가리킨다. 123456789101112131415161718192021// Scope-Safe Constructor Patternfunction A(arg) { // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈객체를 생성하고 this에 바인딩한다. /* this가 호출된 함수(arguments.callee, 본 예제의 경우 A)의 인스턴스가 아니면 new 연산자를 사용하지 않은 것이므로 이 경우 new와 함께 생성자 함수를 호출하여 인스턴스를 반환한다. arguments.callee는 호출된 함수의 이름을 나타낸다. 이 예제의 경우 A로 표기하여도 문제없이 동작하지만 특정함수의 이름과 의존성을 없애기 위해서 arguments.callee를 사용하는 것이 좋다. */ if (!(this instanceof arguments.callee)) { return new arguments.callee(arg); } // 프로퍼티 생성과 값의 할당 this.value = arg ? arg : 0;}var a = new A(100);var b = A(10);console.log(a.value);console.log(b.value); callee는 arguments 객체의 프로퍼티로서 함수 바디 내에서 현재 실행 중인 함수를 참조할 때 사용한다. 다시 말해, 함수 바디 내에서 현재 실행 중인 함수의 이름을 반환한다. 4. apply/call/bind 호출this에 바인딩될 객체는 함수 호출 패턴에 의해 결정된다. 이는 자바스크립트 엔진이 수행하는 것이다. 이러한 자바스크립트 엔진의 암묵적 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인딩하는 방법도 제공된다. 이것을 가능하게 하는 것이 Function.prototype.apply, Function.prototype.call 메소드이다. 이 메소드들은 모든 함수 객체의 프로토타입 객체인 Function.prototype 객체의 메소드이다. 1234func.apply(thisArg, [argsArray])// thisArg: 함수 내부의 this에 바인딩할 객체// argsArray: 함수에 전달할 argument의 배열 기억해야 할 것은 apply() 메소드를 호출하는 주체는 함수이며 apply() 메소드는 this를 특정 객체에 바인딩할 뿐 본질적인 기능은 함수 호출이라는 것이다. 12345678910var Person = function (name) { this.name = name;};var foo = {};// apply 메소드는 생성자함수 Person을 호출한다. 이때 this에 객체 foo를 바인딩한다.Person.apply(foo, ['name']);console.log(foo); // { name: 'name' } 빈 객체 foo를 apply() 메소드의 첫번째 매개변수에, argument의 배열을 두번째 매개변수에 전달하면서 Person 함수를 호출하였다. 이때 Person 함수의 this는 foo 객체가 된다. Person 함수는 this의 name 프로퍼티에 매개변수 name에 할당된 인수를 할당하는데 this에 바인딩된 foo 객체에는 name 프로퍼티가 없으므로 name 프로퍼티가 동적 추가되고 값이 할당된다. apply() 메소드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우이다. arguments 객체는 배열이 아니기 때문에 slice() 같은 배열의 메소드를 사용할 수 없으나 apply() 메소드를 이용하면 가능하다. 12345678910111213function convertArgsToArray() { console.log(arguments); // arguments 객체를 배열로 변환 // slice: 배열의 특정 부분에 대한 복사본을 생성한다. var arr = Array.prototype.slice.apply(arguments); // arguments.slice // var arr = [].slice.apply(arguments); console.log(arr); return arr;}convertArgsToArray(1, 2, 3); Array.prototype.slice.apply(arguments)는 “Array.prototype.slice() 메소드를 호출하라. 단 this는 arguments 객체로 바인딩하라”는 의미가 된다. 결국 Array.prototype.slice() 메소드를 arguments 객체 자신의 메소드인 것처럼 arguments.slice()와 같은 형태로 호출하라는 것이다. call() 메소드의 경우, apply()와 기능은 같지만 apply()의 두번째 인자에서 배열 형태로 넘긴 것을 각각 하나의 인자로 넘긴다. 123Person.apply(foo, [1, 2, 3]);Person.call(foo, 1, 2, 3); apply()와 call() 메소드는 콜백 함수의 this를 위해서 사용되기도 한다. 1234567891011121314151617function Person(name) { this.name = name;}Person.prototype.doSomething = function(callback) { if(typeof callback == 'function') { // --------- 1 callback(); }};function foo() { console.log(this.name); // --------- 2}var p = new Person('Lee');p.doSomething(foo); // undefined 1의 시점에서 this는 Person 객체이다. 그러나 2의 시점에서 this는 전역 객체 window를 가리킨다. 콜백함수를 호출하는 외부 함수 내부의 this와 콜백함수 내부의 this가 상이하기 때문에 문맥상 문제가 발생한다. 따라서 콜백함수 내부의 this를 콜백함수를 호출하는 함수 내부의 this와 일치시켜 주어야 하는 번거로움이 발생한다. 12345678910111213141516function Person(name) { this.name = name;}Person.prototype.doSomething = function (callback) { if (typeof callback == 'function') { callback.call(this); }};function foo() { console.log(this.name);}var p = new Person('Lee');p.doSomething(foo); // 'Lee' Function.prototype.bind는 함수에 인자로 전달한 this가 바인딩된 새로운 함수를 리턴한다. 즉, Function.prototype.bind는 Function.prototype.apply, Function.prototype.call 메소드와 같이 함수를 실행하지 않기 때문에 명시적으로 함수를 호출할 필요가 있다. 123456789101112131415161718function Person(name) { this.name = name;}Person.prototype.doSomething = function (callback) { if (typeof callback == 'function') { // callback.call(this); // this가 바인딩된 새로운 함수를 호출 callback.bind(this)(); }};function foo() { console.log('#', this.name);}var p = new Person('Lee');p.doSomething(foo); // 'Lee' Referencepoiemaweb.com/js-this","link":"/2021/08/18/js-day15-this/"}],"tags":[{"name":"asp.net","slug":"asp-net","link":"/tags/asp-net/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"request","slug":"request","link":"/tags/request/"},{"name":"response","slug":"response","link":"/tags/response/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"syntax","slug":"syntax","link":"/tags/syntax/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"tag","slug":"tag","link":"/tags/tag/"},{"name":"img","slug":"img","link":"/tags/img/"},{"name":"video","slug":"video","link":"/tags/video/"},{"name":"audio","slug":"audio","link":"/tags/audio/"},{"name":"form","slug":"form","link":"/tags/form/"},{"name":"Structure","slug":"Structure","link":"/tags/Structure/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"typechecking","slug":"typechecking","link":"/tags/typechecking/"}],"categories":[{"name":"ASP.NET","slug":"ASP-NET","link":"/categories/ASP-NET/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"python-string","slug":"python-string","link":"/categories/python-string/"},{"name":"python-booleans","slug":"python-booleans","link":"/categories/python-booleans/"},{"name":"python-list","slug":"python-list","link":"/categories/python-list/"},{"name":"python-operators","slug":"python-operators","link":"/categories/python-operators/"},{"name":"python-if","slug":"python-if","link":"/categories/python-if/"},{"name":"python-while","slug":"python-while","link":"/categories/python-while/"},{"name":"python-for","slug":"python-for","link":"/categories/python-for/"},{"name":"python-function","slug":"python-function","link":"/categories/python-function/"},{"name":"python-object","slug":"python-object","link":"/categories/python-object/"},{"name":"python-syntax","slug":"python-syntax","link":"/categories/python-syntax/"},{"name":"python-variables","slug":"python-variables","link":"/categories/python-variables/"},{"name":"python-comments","slug":"python-comments","link":"/categories/python-comments/"},{"name":"python-datatypes","slug":"python-datatypes","link":"/categories/python-datatypes/"},{"name":"python-numbers","slug":"python-numbers","link":"/categories/python-numbers/"},{"name":"python-exercises","slug":"python-exercises","link":"/categories/python-exercises/"},{"name":"python-test","slug":"python-test","link":"/categories/python-test/"},{"name":"python-inheritance","slug":"python-inheritance","link":"/categories/python-inheritance/"},{"name":"python-iterators","slug":"python-iterators","link":"/categories/python-iterators/"},{"name":"python-scope","slug":"python-scope","link":"/categories/python-scope/"},{"name":"python-modules","slug":"python-modules","link":"/categories/python-modules/"}]}