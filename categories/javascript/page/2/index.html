<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>카테고리: javascript - git blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="git blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="git blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="git blog"><meta property="og:url" content="https://wontaejang.github.io/"><meta property="og:site_name" content="git blog"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://wontaejang.github.io/img/og_image.png"><meta property="article:author" content="WT.Jang"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wontaejang.github.io"},"headline":"git blog","image":["https://wontaejang.github.io/img/og_image.png"],"author":{"@type":"Person","name":"WT.Jang"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="git blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">카테고리</a></li><li class="is-active"><a href="#" aria-current="page">javascript</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-03T06:01:38.000Z" title="2021-8-3 15:01:38">2021-08-03</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-03T06:25:51.295Z" title="2021-8-3 15:25:51">2021-08-03</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">13분안에 읽기 (약 1895 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/03/js-day10-typechecking/">js-day10-typechecking</a></h1><div class="content"><h1 id="타입-체크-Type-Checking"><a href="#타입-체크-Type-Checking" class="headerlink" title="타입 체크 (Type Checking)"></a>타입 체크 (Type Checking)</h1><p>자바스크립트는 동적타입(dynamic typed)언어이므로 변수에 어떤 값이 할당될지 예측하기 어렵다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드를 작성한 개발자의 의도는 아마도 2개의 number 타입 인수를 전달받아 그 합계를 반환하려는 것으로 추측된다. 하지만 코드 상으로는 어떤 타입의 인수를 전달하여야 하는지, 어떤 타입의 값을 반환해야하는지 명확하지 않다. 따라서 위 코드는 다음처럼 호출 될 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>); <span class="comment">// &#x27;xy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>위 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실행할 것이다. 이러한 상황이 발생한 이유는 변수나 반환값의 타입을 사전에 지정하지 않는 자바스크립트의 동적 타이핑(Dynamic Typing)에 의한것이다. 이와같은 이유로 자바스크립트는 타입 체크가 필요하다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a와 b가 number 타입인지 체크</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h1><p>타입 연산자(Type Operator) typeof는 피연산자의 데이터 타입을 문자열로 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span>;              <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>;               <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>;             <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;            <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [];              <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;;              <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>();    <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>();      <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> /test/gi;        <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;  <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;       <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;            <span class="comment">// object (설계적 결함)</span></span><br><span class="line"><span class="keyword">typeof</span> undeclared;      <span class="comment">// undefined (설계적 결함)</span></span><br></pre></td></tr></table></figure>

<p>그런데 typeof 연산자는 null과 배열의 경우 object, 함수의 경우 function를 반환하고, Date, RegExp, 사용자 정의 객체 등 거의 모든 객체의 경우, object를 반환한다. 따라서 typeof는 null을 제외한 원시 타입을 체크하는 데는 문제가 없지만 객체의 종류까지 구분하여 체크하려할 때는 사용하기는 곤란하다. 여러 종류의 객체(일반 객체, 배열, Date, RegExp, Function, DOM 요소 등)를 구분할 수 있는 타입 체크 기능을 만들어보자.</p>
<h1 id="2-Object-prototype-toString"><a href="#2-Object-prototype-toString" class="headerlink" title="2. Object.prototype.toString"></a>2. Object.prototype.toString</h1><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">Object.prototype.toString</a> 메소드는 개체를 나타내는 문자열을 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.toString(); <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Funciton.prototype.call</a> 메소드를 사용하면 모든 타입의 값의 타입을 알아낼 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>);             <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">String</span>());   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>);              <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Number</span>());   <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">NaN</span>);            <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">Infinity</span>);       <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>);           <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>);      <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call();               <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>);           <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]);             <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;);             <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>());     <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>);           <span class="comment">// [object Math]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/test/i</span>);        <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>);       <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(argument);       <span class="comment">// [object Arguments]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(undeclared);     <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<p>이것을 이용하여 타입을 반환하는 함수를 만들어보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String.prototype.slice 메소드를 사용하여 Object.prototype.toString.call 메소드가 반환한 문자열에서 “[object”와 “]”를 제외하고 타입을 나타내는 문자열만을 추출하였다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getType(<span class="string">&#x27;&#x27;</span>);         <span class="comment">// String</span></span><br><span class="line">getType(<span class="number">1</span>);          <span class="comment">// Number</span></span><br><span class="line">getType(<span class="literal">true</span>);       <span class="comment">// Boolean</span></span><br><span class="line">getType(<span class="literal">undefined</span>);  <span class="comment">// Undefined</span></span><br><span class="line">getType(<span class="literal">null</span>);       <span class="comment">// Null</span></span><br><span class="line">getType(&#123;&#125;);         <span class="comment">// Object</span></span><br><span class="line">getType([]);         <span class="comment">// Array</span></span><br><span class="line">getType(<span class="regexp">/test/i</span>);    <span class="comment">// RegExp</span></span><br><span class="line">getType(<span class="built_in">Math</span>);       <span class="comment">// Math</span></span><br><span class="line">getType(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// Date</span></span><br><span class="line">getType(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// Function</span></span><br></pre></td></tr></table></figure>

<p>이제 앞에서 살펴본 sum 함수에 타입 체크 기능을 추가해 보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a와 b가 number 타입인지 체크</span></span><br><span class="line">  <span class="keyword">if</span> (getType(a) !== <span class="string">&#x27;Number&#x27;</span> || getType(b) !== <span class="string">&#x27;Number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;파라미터에 number 타입이 아닌 값이 할당되었습니다.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">20</span>));   <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="string">&#x27;10&#x27;</span>, <span class="number">20</span>)); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<p>타입별로 체크하는 기능을 만들려면 아래와 같이 함수를 작성한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;String&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Number&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBoolean</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Boolean&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Null&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndefined</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Undefined&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDate</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Date&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRegExp</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;RegExp&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(target) === <span class="string">&#x27;Function&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-instanceof"><a href="#3-instanceof" class="headerlink" title="3. instanceof"></a>3. instanceof</h1><p>이와 같이 Object.prototype.toString를 사용하여 객체의 종류(일반 객체, 배열, Date, RegExp, Function, DOM 요소 등)까지 식별할 수 있는 타입 체크 기능을 작성하였다. </p>
<p>그런데, 이 방법으로는 객체의 상속관계까지 체크할 수는 없다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTMLElement를 상속받은 모든 DOM 요소에 css 프로퍼티를 추가하고 값을 할당한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">elem, prop, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// type checking...</span></span><br><span class="line">  elem.style[prop] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">css(&#123;&#125;, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;color&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>css 함수의 첫번째 매개변수에는 반드시 HTMLElement를 상속받은 모든 DOM 요소를 전달하여야 한다. 다시말해, css 함수의 첫번째 매개변수에는 HTMLDivElement, HTMLUListElement, HTMLLIElement, HTMLParagraphElement 등 모든 DOM 요소가 전달될 수 있다. 이를 일일이 체크할 수는 없기 때문에 HTMLElement를 상속받은 객체, 즉 DOM 요소인지 확인하여야 한다.</p>
<p>타입 연산자(Type Operator)에는 앞서 살펴본 typeof 이외에 instanceof를 제공한다. instanceof 연산자는 피연산자인 객체가 우항에 명시한 타입의 인스턴스인지 여부를 알려준다. 이때 타입이란 constructor를 말하며 프로토타입 체인에 존재하는 모든 constructor를 검색하여 일치하는 constructor가 있다면 true를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>이를 이용해 css 함수에 타입 체크 기능을 추가해 보자.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, -<span class="number">1</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">target</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> getType(target) === <span class="string">&#x27;String&#x27;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">isElement</span>(<span class="params">target</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> !!(target &amp;&amp; target <span class="keyword">instanceof</span> HTMLElement);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 또는 `nodeType`을 사용할 수도 있다.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// return !!(target &amp;&amp; target.nodeType === 1);</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// HTMLElement를 상속받은 모든 DOM 요소에 css 프로퍼티를 추가하고 값을 할당한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">elem, prop, val</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// type checking</span></span></span><br><span class="line">      if (!(isElement(elem) &amp;&amp; isString(prop) &amp;&amp; isString(val))) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;매개변수의 타입이 맞지 않습니다.&#x27;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">      elem.style[prop] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    css(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>), <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    css(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>), <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// TypeError: 매개변수의 타입이 맞지 않습니다.</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-유사-배열-객체"><a href="#4-유사-배열-객체" class="headerlink" title="4. 유사 배열 객체"></a>4. 유사 배열 객체</h1><p>배열인지 체크하기 위해서는 Array.isArray 메소드를 사용한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([]));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123;&#125;));    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>유사 배열 객체(array-like object)은 length 프로퍼티를 갖는 객체로 문자열, arguments, HTMLCollection, NodeList 등은 유사 배열이다. 유사 배열 객체는 length 프로퍼티가 있으므로 순회할 수 있으며 call, apply 함수를 사용하여 배열의 메소드를 사용할 수도 있다.</p>
<p>어떤 객체가 유사 배열인지 체크하려면 우선 length 프로퍼티를 갖는지 length 프로퍼티의 값이 정상적인 값인지 체크한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> isArrayLike = <span class="function"><span class="keyword">function</span> (<span class="params">collection</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 배열 인덱스: 32bit 정수(2의 32제곱 - 1)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 유사 배열 인덱스: 자바스크립트로 표현할 수 있는 양의 정수(2의 53제곱 - 1)</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> MAX_ARRAY_INDEX = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 빈문자열은 유사배열이다. undefined == null =&gt; true</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> length = collection == <span class="literal">null</span> ? <span class="literal">undefined</span> : collection.length;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">typeof</span> length === <span class="string">&#x27;number&#x27;</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike([]));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(<span class="string">&#x27;abc&#x27;</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(<span class="string">&#x27;&#x27;</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(<span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;li&#x27;</span>)));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(&#123; <span class="attr">length</span>: <span class="number">0</span> &#125;));</span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(isArrayLike(<span class="built_in">arguments</span>));</span></span><br><span class="line">    &#125;());</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// false</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(<span class="number">123</span>));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;li&#x27;</span>)));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;));</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike());</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(isArrayLike(<span class="literal">null</span>));</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-type-check">poiemaweb.com/js-type-check</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-23T08:12:01.914Z" title="2021-7-23 17:12:01">2021-07-23</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-02T07:33:53.724Z" title="2021-8-2 16:33:53">2021-08-02</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">한 시간안에 읽기 (약 7068 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/23/js-day9-function/">js-day9-function</a></h1><div class="content"><p>함수란 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수의 정의(함수 선언문)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>함수는 호출에 의해 실행되는데 한번만 호출할 수 있는 것이 아니라 여러번 호출할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수의 정의(함수 선언문)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수의 호출</span></span><br><span class="line">square(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>동일한 작업을 반복적으로 수행해야 한다면 (동일한 구문을 계속해서 중복해서 작성하는 것이 아니라) 미리 정의된 함수를 재사용하는 것이 효율적이다. 이러한 특성은 코드의 재사용이라는 측면에서 매우 유용하다.</p>
<p>함수의 일반적 기능은 어떤 작업을 수행하는 문(statement)들의 집합을 정의하여 코드의 재사용에 목적이 있다. 이러한 일반적 기능 이외에 객체 생성, 객체의 행위 정의(메소드), 정보 은닉, 클로저, 모듈화 등의 기능을 수행할 수 있다.</p>
<p>자바스크립트의 함수는 객체(일급 객체, First-class object)이다. 다른 객체와 구분될 수 있는 특징은 호출할 수 있다는 것이다. 함수도 객체이므로 다른 값들처럼 사용할 수 있다. 즉, 변수나 객체, 배열 등에 저장할 수 있고 다른 함수에 전달되는 인수로도 사용할 수 있으며 함수의 반환값이 될 수도 있다.</p>
<h1 id="1-함수-정의"><a href="#1-함수-정의" class="headerlink" title="1. 함수 정의"></a>1. 함수 정의</h1><p>함수를 정의하는 방식은 3가지가 있다. </p>
<ul>
<li>함수 선언문</li>
<li>함수 표현식</li>
<li>Function 생성자 함수</li>
</ul>
<h2 id="1-1-함수-선언문"><a href="#1-1-함수-선언문" class="headerlink" title="1.1 함수 선언문"></a>1.1 함수 선언문</h2><p>함수 선언문(Function declaration) 방식으로 정의한 함수는 function 키워드와 이하의 내용으로 구성된다. </p>
<blockquote>
<ul>
<li>함수명<br>함수 선언문의 경우, 함수명은 생략할 수 없다. 함수명은 함수 몸체에서 자신을 재귀적(recursive)호출하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자이다. </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>매개변수 목록<br>0개 이상의 목록으로 괄호로 감싸고 콤마로 분리한다. 다른 언어와의 차이점은 매개변수의 타입을 기술하지 않는다는 것이다. 이 때문에 함수 몸체 내에서 매개변수의 타입 체크가 필요할 수 있다. </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>함수 몸체<br>함수가 호출되었을 때 실행되는 문들의 집합이다. 중괄호({})로 문들을 감싸고 return 문으로 결과값을 반환할 수 있다. 이를 반환값 (return value)라 한다. </li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-함수-표현식"><a href="#1-2-함수-표현식" class="headerlink" title="1.2 함수 표현식"></a>1.2 함수 표현식</h2><p>자바스크립트의 함수는 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4">일급 객체(first-class object)</a>이므로 아래와 같은 특징이 있다. </p>
<blockquote>
<ol>
<li>무명의 리터럴로 표현이 가능하다. </li>
<li>변수나 자료 구조(객체, 배열… )에 저장할 수 있다. </li>
<li>함수의 파라미터로 전달할 수 있다. </li>
<li>반환값(return value)으로 사용할  수 있다. </li>
</ol>
</blockquote>
<p>함수의 일급객체 특성을 이용하여 함수 리터럴 방식으로 함수를 정의하고 변수에 할당할 수 있는데 이러한 방식을 함수 표현식(Function expression)이라 한다. </p>
<p>함수 선언문으로 정의한 함수 square()를 함수 표현식으로 정의하면 아래와 같다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수 표현식 방식으로 정의한 함수를 함수명을 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다. 함수 표현식에서는 함수명을 생략하는 것이 일반적이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수 표현식(named function expression)</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 함수 표현식(anonymous function expression)</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">10</span>, <span class="number">5</span>)); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">10</span>, <span class="number">5</span>)); <span class="comment">// Uncaught ReferenceError: multiply is not defined</span></span><br></pre></td></tr></table></figure>

<p>함수는 일급객체이기 때문에 변수에 할당할 수 있는데 이 변수는 함수명이 아니라 할당된 함수를 가리키는 참조값을 저장하게 된다. 함수 호출 시 함수명이 아니라 함수를 가리키는 변수명을 사용하여야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(bar(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>변수 bar와 변수 foo는 동일한 익명 함수의 참조값을 갖는다. </p>
<p>foo -&gt; 익명 함수 &lt;- bar</p>
<p>함수가 할당된 변수를 사용해 함수를 호출하지 않고 기명함수의 함수명을 사용해 호출하게 되면 에러가 발생한다. 이를 함수 표현식에서 사용한 함수명은 외부 코드에서 접근 불가능하기 때문이다. (사실 함수 선언문의 경우도 마찬가지이다.)</p>
<p>함수 표현식과 함수 선언문에서 사용한 함수명은 함수 몸체에서 자신을 재귀적 호출(Recursize function call)하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자의 역할을 한다. </p>
<p>함수 선언문으로 정의한 함수 square의 경우, 함수명으로 호출 할 수 있었는데 이는 자바스크립트 엔진에 의해 아래와 같은 함수 표현식으로 형태가 변경되었기 때문이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수명과 함수 참조값을 가진 변수명이 일치하므로 함수명으로 호출되는 듯 보이지만 사실은 변수명으로 호출된 것이다.</p>
<p>결국 함수 선언문도 함수 표현식과 동일하게 함수 리터럴 방식으로 정의되는 것이다.</p>
<h2 id="1-3-Function-생성자-함수"><a href="#1-3-Function-생성자-함수" class="headerlink" title="1.3 Function 생성자 함수"></a>1.3 Function 생성자 함수</h2><p>함수 표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다. 함수 선언문도 내부적으로 자바스크립트 엔진이 기명 함수 표현식으로 변환하므로 결국 함수 리터럴 방식을 사용한다. </p>
<p>따라서 함수 선언문과 함수 표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function 생성자 함수로 함수를 생성하는 것을 단순화 시킨 short-hand(축약법)이다. </p>
<p>Function 생성자 함수는 Function.prototype.constructor 프로퍼티로 접근할 수 있다. </p>
<p>Function 생성자 함수로 함수를 생성하는 문법은 다음과 같다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(arg1, arg2, ... argN, functionBody)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;return number * number&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">10</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>Function 생성자 함수로 함수를 생성하는 방식은 일반적으로 사용하지 않는다. </p>
<h1 id="2-함수-호이스팅"><a href="#2-함수-호이스팅" class="headerlink" title="2. 함수 호이스팅"></a>2. 함수 호이스팅</h1><p>3가지의 함수 정의 방식을 알아보았다. 정의 방식은 달라도 결국 Function 생성자 함수를 통해 함수를 생성하는 것까지 확인하였다. 그런데 이 3가지 함수 정의 방식은 동작 방식에 약간의 차이가 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = square(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드를 보면 함수 선언문으로 함수가 정의되기 이전에 함수 호출이 가능하다. 함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느곳에서든지 호출이 가능한데 이것을 함수 호이스팅(Function Hoisting)이라 한다. </p>
<p>자바스크립트는 ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅(Hoisting)한다. </p>
<p>호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문(var, let, const, function, function*, class)이 선언되기 이전에 참조 가능하다. </p>
<p>함수 선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 vo(variable object)에 저장한다. 함수 선언, 초기화, 할당이 한번에 이루어진다. 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다. </p>
<p>다음은 함수 표현식으로 함수를 정의한 경우이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = square(<span class="number">5</span>); <span class="comment">// TypeError: square is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>함수 선언문의 경우와는 달리 Type Error가 방생하였다. 함수 표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생한다. </p>
<blockquote>
<p>변수 호이스팅은 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undefined로 초기화 되고 실제값의 할당은 할당문에서 이루어 진다. </p>
</blockquote>
<p>함수 표현식은 함수 선언문과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고 runtime에 해석되고 실행되므로 이 두가지를 구분하는 것은 중요하다.</p>
<p>JavaScript: The Good Parts의 저자이며 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있다. 함수 호이스팅이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적한다.</p>
<p>또한 함수 선언문으로 함수를 정의하면 사용하기에 쉽지만 대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다.</p>
<h1 id="3-First-class-object-일급-객체"><a href="#3-First-class-object-일급-객체" class="headerlink" title="3. First-class object(일급 객체)"></a>3. First-class object(일급 객체)</h1><p>일급 객체(first-class object)란 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다. </p>
<p>다음 조건을 만족하면 일급 객체로 간주한다. </p>
<blockquote>
<ol>
<li>무명의 리터럴로 표현이 가능하다. </li>
<li>변수나 자료 구조(객체, 배열 등)에 저장할 수 있다. </li>
<li>함수의 매개변수에 전달할 수 있다. </li>
<li>반환값으로 사용할 수 있다. </li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 무명의 리터럴로 표현이 가능하다.</span></span><br><span class="line"><span class="comment">// 2. 변수나 자료 구조에 저장할 수 있다.</span></span><br><span class="line"><span class="keyword">var</span> increase = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> decrease = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> --num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> predicates = &#123; increase, decrease &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 함수의 매개변수에 전달할 수 있다.</span></span><br><span class="line"><span class="comment">// 4. 반환값으로 사용할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    num = predicate(num);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increaser = makeCounter(predicates.increase);</span><br><span class="line"><span class="built_in">console</span>.log(increaser()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(increaser()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> decreaser = makeCounter(predicates.decrease);</span><br><span class="line"><span class="built_in">console</span>.log(decreaser()); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(decreaser()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>

<p>Javascript의 함수는 위의 조건을 모두 만족하므로 Javascript의 함수는 일급객체이다. 따라서 Javascript의 함수는 흡사 변수와 같이 사용할 수 있으며 코드의 어디에서든지 정의할 수 있다. </p>
<p><strong>함수와 다른 객체를 구분짓는 특징은 호출할 수 있다는 것이다.</strong>       </p>
<h1 id="4-매개변수-Parameter-인자"><a href="#4-매개변수-Parameter-인자" class="headerlink" title="4. 매개변수(Parameter, 인자)"></a>4. 매개변수(Parameter, 인자)</h1><p>함수의 작업 실행을 위해 추가적인 정보가 필요할 경우, 매개변수를 지정한다. 매개변수는 함수 내에서 변수와 동일하게 동작한다.</p>
<h2 id="4-1-매개변수-parameter-인자-vs-인수-argument"><a href="#4-1-매개변수-parameter-인자-vs-인수-argument" class="headerlink" title="4.1 매개변수(parameter, 인자) vs 인수(argument)"></a>4.1 매개변수(parameter, 인자) vs 인수(argument)</h2><p>매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 함수에 전달한 인수는 매개변수에 할당된다. 만약 인수를 전달하지 않으면 매개변수는 Undefined로 초기화 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p1, p2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 1 undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-Call-by-value"><a href="#4-2-Call-by-value" class="headerlink" title="4.2 Call-by-value"></a>4.2 Call-by-value</h2><p>원시 타입 인수는 Call-by-value(값에 의한 호출)로 동작한다. 이는 함수 호출 시 원시 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식이다. 이때 함수 내에서 매개변수를 통해 값이 변경되어도 전달이 완료된 원시 타입 값은 변경되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">primitive</span>) </span>&#123;</span><br><span class="line">  primitive += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> primitive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(x)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(x);      <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-Call-by-reference"><a href="#4-3-Call-by-reference" class="headerlink" title="4.3 Call-by-reference"></a>4.3 Call-by-reference</h2><p>객체형(참조형) 인수는 Call-by-reference(참조에 의한 호출)로 동작한다. 이는 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식이다. 이때 함수 내에서 매개변수의 참조값이 이용하여 객체의 값을 변경했을 때 전달되어진 참조형의 인수값도 같이 변경된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVal</span>(<span class="params">primitive, obj</span>) </span>&#123;</span><br><span class="line">  primitive += <span class="number">100</span>;</span><br><span class="line">  obj.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line">  obj.gender = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object &#123;name: &#x27;Lee&#x27;, gender: &#x27;male&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">changeVal(num, obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object &#123;name: &#x27;Kim&#x27;, gender: &#x27;female&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>changeVal 함수는 원시 타입과 객체 타입 인수를 전달 받아 함수 몸체에서 매개변수의 값을 변경하였다. 이때 원시 타입 인수는 값을 복사하여 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경하여도 어떠한 부수 효과(side-effect)도 발생시키지 않는다.</p>
<p>하지만 객체형 인수는 참조값을 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경할 경우 원본 객체가 변경되는 부수 효과(side-effect)가 발생한다. 이와 같이 부수 효과를 발생시키는 비순수 함수(Impure function)는 복잡성을 증가시킨다. 비순수 함수를 최대한 줄이는 것은 부수 효과를 최대한 억제하는 것과 같다. 이것은 디버깅을 쉽게 만든다.</p>
<p>어떤 외부 상태도 변경하지 않는 함수를 순수함수(Pure function), 외부 상태도 변경시켜는 부수 효과(side-effect)가 발생시키는 함수를 비순수 함수(Impure function)라 한다.</p>
<h1 id="5-반환값"><a href="#5-반환값" class="headerlink" title="5. 반환값"></a>5. 반환값</h1><p>함수는 자신을 호출한 코드에게 수행한 결과를 반환(return)할 수 있다. 이때 반환된 값을 반환값(return value)이라 한다. </p>
<ul>
<li>return 키워드는 함수를 호출한 코드(caller)에게 값을 반환할 때 사용한다. </li>
<li>함수는 배열 등을 이용하여 한번에 여러 개의 값을 리턴할 수 있다. </li>
<li>함수는 반환을 생략할 수 있다. 이때 함수는 암묵적으로 undefined를 반환한다. </li>
<li>자바스크립트 해석기는 return 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 만일 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateArea</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> area = width * height;</span><br><span class="line">  <span class="keyword">return</span> area; <span class="comment">// 단일 값의 반환</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(calculateArea(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateArea(<span class="number">8</span>, <span class="number">5</span>)); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSize</span>(<span class="params">width, height, depth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> area = width * height;</span><br><span class="line">  <span class="keyword">var</span> volume = width * height * depth;</span><br><span class="line">  <span class="keyword">return</span> [area, volume]; <span class="comment">// 복수 값의 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;area is &#x27;</span> + getSize(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>)[<span class="number">0</span>]);   <span class="comment">// area is 6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;volume is &#x27;</span> + getSize(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>)[<span class="number">1</span>]); <span class="comment">// volume is 18</span></span><br></pre></td></tr></table></figure>

<h1 id="6-함수-객체의-프로퍼티"><a href="#6-함수-객체의-프로퍼티" class="headerlink" title="6. 함수 객체의 프로퍼티"></a>6. 함수 객체의 프로퍼티</h1><p>함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square.x = <span class="number">10</span>;</span><br><span class="line">square.y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square.x, square.y);</span><br></pre></td></tr></table></figure>

<p>함수는 일반 객체와는 다른 함수만의 프로퍼티를 갖는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.dir(square);</span><br></pre></td></tr></table></figure>

<h2 id="6-1-arguments-프로퍼티"><a href="#6-1-arguments-프로퍼티" class="headerlink" title="6.1 arguments 프로퍼티"></a>6.1 arguments 프로퍼티</h2><p>arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한 (iterble)유사 배열 객체(array-like object)이며 함수 내부에서 지역변수처럼 사용된다. 즉, 함수 외부에서는 사용할 수 없다. </p>
<blockquote>
<p>arguments 프로퍼티는 현재 일부 브라우저에서 지원하고 있지만 ES3부터 표준에서 deprecated 되었다. Function.arguments와 같은 사용 방법은 권장되지 않으며 함수 내부에서 지역변수처럼 사용할 수 있는 arguments 객체를 참조하도록 한다.</p>
</blockquote>
<p>자바스트립트는 함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply();        <span class="comment">// &#123;&#125;</span></span><br><span class="line">multiply(<span class="number">1</span>);       <span class="comment">// &#123; &#x27;0&#x27;: 1 &#125;</span></span><br><span class="line">multiply(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2 &#125;</span></span><br><span class="line">multiply(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<p>매개변수(parameter)는 인수(argument)로 초기화 된다. </p>
<ul>
<li>매개변수의 갯수보다 인수를 적게 전달했을 때(multiply(), multiply(1)) 인수가 전달되지 않은 매개변수는 undefined 으로 초기화 된다. </li>
<li>매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다. </li>
</ul>
<p>이러한 자바스크립트의 특성떄문에 런타임 시에 호출된 함수의 인자 갯수를 확인하고 이에따라 동작을 달리 정의할 필요가 있을 수 있다. 이때 유용하게 사용되는 것이 arguments 객체이다. </p>
<p>arguments 객체는 매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하게 사용된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    res += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum());        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다. arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다.</p>
<p>유사배열객체란 length 프로퍼티를 가진 객체를 말한다. 유사배열객체는 배열이 아니므로 배열 메소드를 사용하는 경우 에러가 발생하게 된다. 따라서 배열 메소드를 사용하려면 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call</a>, [Function.prototype.apply]<a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)%EB%A5%BC">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)를</a> 사용하여야 하는 번거로움이 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments 객체를 배열로 변환</span></span><br><span class="line">  <span class="keyword">var</span> array = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="comment">// function sum(...args) &#123;</span></span><br><span class="line"><span class="comment">//   if (!args.length) return 0;</span></span><br><span class="line"><span class="comment">//   return args.reduce((pre, cur) =&gt; pre + cur);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-caller-프로퍼티"><a href="#6-2-caller-프로퍼티" class="headerlink" title="6.2 caller 프로퍼티"></a>6.2 caller 프로퍼티</h2><p>caller 프로퍼티는 자신을 호출한 함수를 의미한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = func();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;caller : &#x27;</span> + bar.caller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(bar)); <span class="comment">// caller : function foo(func) &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar());    <span class="comment">// null (browser에서의 실행 결과)</span></span><br></pre></td></tr></table></figure>

<h2 id="6-3-length-프로퍼티"><a href="#6-3-length-프로퍼티" class="headerlink" title="6.3 length 프로퍼티"></a>6.3 length 프로퍼티</h2><p>length 프로퍼티는 함수 정의 시 작성된 매개변수 갯수를 의미한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar.length); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(baz.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>arguments.length의 값과는 다를 수 있으므로 주의하여야 한다. arguments.length는 함수 호출 시 인자의 갯수이다. </p>
<h2 id="6-4-name-프로퍼티"><a href="#6-4-name-프로퍼티" class="headerlink" title="6.4 name 프로퍼티"></a>6.4 name 프로퍼티</h2><p>함수명을 나타낸다. 기명함수의 경우 함수명을 값으로 갖고 익명함수의 경우 빈문자열을 값으로 갖는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수 표현식(named function expression)</span></span><br><span class="line"><span class="keyword">var</span> namedFunc = <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 익명 함수 표현식(anonymous function expression)</span></span><br><span class="line"><span class="keyword">var</span> anonymousFunc = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(namedFunc.name);     <span class="comment">// multiply</span></span><br><span class="line"><span class="built_in">console</span>.log(anonymousFunc.name); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-5-proto-접근자-프로퍼티"><a href="#6-5-proto-접근자-프로퍼티" class="headerlink" title="6.5 proto 접근자 프로퍼티"></a>6.5 <strong>proto</strong> 접근자 프로퍼티</h2><p>모든 객체는 [[prototype]]이라는 내부 슬롯이 있다. [[prototype]] 내부 슬롯은 프로포타입 객체를 가리킨다. 프로토타입 객체란 프로포타입 기반 객체 지향 프로그래밍의 근간을 이루는 객체로서 객체간의 상속(Inheritance)을 구현하기 위해 사용된다. 즉, 프로포타입 객체는 다른 객체에 공유 프로퍼티를 제공하는 개체를 말한다. </p>
<p>&#95;&#95;proto&#95;&#95; 프로퍼티는 [[prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.<br>[[prototype]] 내부 슬롯에도 직접 접근할 수 없으며 &#95;&#95;proto&#95;&#95; 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입 객체에 접근할 수 있다.</span></span><br><span class="line"><span class="comment">// 객체 리터럴로 생성한 객체의 프로토타입 객체는 Object.prototype이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>&#95;&#95;proto&#95;&#95; 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 모든 객체의 프로토타입 객체인 Object.prototype 객체의 프로퍼티이다. 모든 객체는 상속을 통해 &#95;&#95;proto&#95;&#95; 접근자 프로퍼티는 사용할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체는 __proto__ 프로퍼티를 소유하지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">&#x27;__proto__&#x27;</span>));</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">&#x27;__proto__&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>함수도 객치이므로 &#95;&#95;proto&#95;&#95; 접근자 프로퍼티를 통해 프로토타입 객체에 접근할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 객체의 프로토타입 객체는 Function.prototype이다.</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="6-6-prototype-프로퍼티"><a href="#6-6-prototype-프로퍼티" class="headerlink" title="6.6 prototype 프로퍼티"></a>6.6 prototype 프로퍼티</h2><p>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 즉 일반 객체에는 prototype 프로퍼티가 없다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 객체는 prototype 프로퍼티를 소유한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="string">&#x27;prototype&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">&#x27;prototype&#x27;</span>));</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체를 가리킨다. </p>
<h1 id="7-함수의-다양한-형태"><a href="#7-함수의-다양한-형태" class="headerlink" title="7. 함수의 다양한 형태"></a>7. 함수의 다양한 형태</h1><h2 id="7-1-즉시-실행-함수"><a href="#7-1-즉시-실행-함수" class="headerlink" title="7.1 즉시 실행 함수"></a>7.1 즉시 실행 함수</h2><p>함수의 정의와 동시에 실행되는 함수를 즉시 실행 함수 (IIFE, Immediately Invoke Function Expression)라고 한다. 최초 한번만 호출되며 다시 호출할 수는 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 즉시 실행 함수(named immediately-invoked function expression)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 즉시 실행 함수(immediately-invoked function expression)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br><span class="line"><span class="comment">// 함수선언문은 자바스크립트 엔진에 의해 함수 몸체를 닫는 중괄호 뒤에 ;가 자동 추가된다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;(); <span class="comment">// =&gt; &#125;;();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 따라서 즉시 실행 함수는 소괄호로 감싸준다.</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다하여도 글로벌 스코프가 하나이며 글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근이 가능하다는 것이다.</p>
<p>따라서 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 원치 않는 결과를 가져올 수 있다.</p>
<p>즉시 실행 함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 또는 함수명의 충돌을 방지할 수 있어 이를 위한 목적으로 즉시실행함수를 사용되기도 한다.</p>
<p>특히 jQuery와 같은 라이브러리의 경우, 코드를 즉시 실행 함수 내에 정의해 두면 라이브러리의 변수들이 독립된 영역 내에 있게 되므로 여러 라이브러리들은 동시에 사용하더라도 변수명 충돌과 같은 문제를 방지할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></figure>

<h2 id="7-2-내부-함수"><a href="#7-2-내부-함수" class="headerlink" title="7.2 내부 함수"></a>7.2 내부 함수</h2><p>함수 내부에 정의된 함수를 내부함수(Inner function)라 한다. </p>
<p>아래 예제의 내부함수 child는 자신을 포함하고 있는 부모함수 parent의 변수에 접근할 수 있다. 하지만 부모함수는 자식함수(내부함수)의 변수에 접근할 수 없다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parentVar = param;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> childVar = <span class="string">&#x27;lee&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(parentVar + <span class="string">&#x27; &#x27;</span> + childVar); <span class="comment">// Hello lee</span></span><br><span class="line">  &#125;</span><br><span class="line">  child();</span><br><span class="line">  <span class="built_in">console</span>.log(parentVar + <span class="string">&#x27; &#x27;</span> + childVar);</span><br><span class="line">  <span class="comment">// Uncaught ReferenceError: childVar is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">parent(<span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>또한 내부함수는 부모함수의 외부에서 접근할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">&#x27;Hello &#x27;</span> + name;</span><br><span class="line">  <span class="keyword">var</span> logHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(text); &#125;</span><br><span class="line">  logHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello(<span class="string">&#x27;lee&#x27;</span>);  <span class="comment">// Hello lee</span></span><br><span class="line">logHello(<span class="string">&#x27;lee&#x27;</span>);  <span class="comment">// logHello is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="7-3-재귀-함수"><a href="#7-3-재귀-함수" class="headerlink" title="7.3 재귀 함수"></a>7.3 재귀 함수</h2><p>재귀 함수(Recusive function)는 자기 자신을 호출하는 함수를 말한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 피보나치 수열</span></span><br><span class="line"><span class="comment">// 피보나치 수는 0과 1로 시작하며, 다음 피보나치 수는 바로 앞의 두 피보나치 수의 합이 된다.</span></span><br><span class="line"><span class="comment">// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">3</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">6</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 팩토리얼</span></span><br><span class="line"><span class="comment">// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.</span></span><br><span class="line"><span class="comment">// n! = 1 * 2 * ... * (n-1) * n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>)); <span class="comment">// 720</span></span><br></pre></td></tr></table></figure>

<p>재귀 함수는 자신을 무한히 연쇄 호출하므로 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다. 탈출 조건이 없는 경우, 함수가 무한 호출되어 stackoverflow 에러가 발생한다. 위의 두개의 예제 모두 조건식을 통해 재귀 호출을 중지하고 있다.</p>
<p>재귀 함수는 반복 연산을 간단히 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 수 있고, stackoverflow 에러를 발생시킬 수 있으므로 주의하여야 한다.</p>
<p>대부분의 재귀 함수는 for나 while 문으로 구현이 가능하다. 반복문보다 재귀 함수를 통해 보다 직관적으로 이해하기 쉬운 구현이 가능한 경우에만 한정적으로 적용하는 것이 바람직하다.</p>
<h2 id="7-4-콜백-함수"><a href="#7-4-콜백-함수" class="headerlink" title="7.4 콜백 함수"></a>7.4 콜백 함수</h2><p>콜백 함수(Callback function)는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다. </p>
<p>콜백 함수가 자주 사용되는 대표적인 예는 이벤트 헨들러 처리이다. </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myButton&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myButton&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;button clicked!&#x27;</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Javascript의 함수는 일급객체이다. 따라서 Javascript의 함수는 흡사 변수와 같이 사용될 수 있다.</p>
<p>콜백 함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행된다.<br>setTimeout()의 콜백 함수를 살펴보자. 두번째 매개변수에 전달된 시간이 경과되면 첫번째 매개변수에 전달한 콜백 함수가 호출된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1초 후 출력된다.&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>콜백 함수는 주로 비동기식 처리 모델(Asynchronous processing model)에 사용된다. 비동기식 처리 모델이란 처리가 종료하면 호출될 함수(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다.</p>
<p>콜백함수는 콜백 큐에 들어가 있다가 해당 이벤트가 발생하면 호출된다. 콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span> + name);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(); <span class="comment">// My name is Lee</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-function">poiemaweb.com/js-function</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-21T00:38:26.869Z" title="2021-7-21 9:38:26">2021-07-21</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-22T00:43:11.064Z" title="2021-7-22 9:43:11">2021-07-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">16분안에 읽기 (약 2416 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/21/js-day8-immutability/">js-day8-immutability</a></h1><div class="content"><h1 id="객체와-변경불가성-Immutability"><a href="#객체와-변경불가성-Immutability" class="headerlink" title="객체와 변경불가성(Immutability)"></a>객체와 변경불가성(Immutability)</h1><p>Immutability(변경불가성)는 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴을 의미한다. Immutability은 함수형 프로그래밍의 핵심원리이다. </p>
<p>객체는 참조(reference)형태로 전달하고 전달 받는다. 객체가 참조를 통해 공유되어 있다면 그 상태가 언제든지 변경될 수 있기 때문에 문제가 될 가능성도 커지게 된다. 이는 객체의 참조를 가지고 있는 어떤 장소에서 객체를 변경하면 참조를 공유하는 모든 장소에서 그 영향을 받기 때문인데 이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하다. </p>
<p>의도하지 않은 객체의 변경이 발생하는 원인의 대다수는 “레퍼런스를 참조한 다른 객체에서 객체를 변경”하기 때문이다. 이 문제의 해결 방법은 비용은 조금 들지만 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 또는 Observer 패펀으로 객체의 변경에 대처할 수도 있다. </p>
<p>불변 객체를 사용하면 복제나 비교를 위한 조작을 단순화 할 수 있고 성능 개선에도 도움이 된다. 하지만 객체가 변경 가능한 데이터를 많이 가지고 있는 경우 오히려 부적절한 경우가 있다. </p>
<p>ES6에서는 불변 데이터 패턴(immutable data pattern)을 쉽게 구현할 수 있는 새로운 기능이 추가되었다. </p>
<h1 id="1-immutable-value-vs-mutable-value"><a href="#1-immutable-value-vs-mutable-value" class="headerlink" title="1. immutable value vs. mutable value"></a>1. immutable value vs. mutable value</h1><p>javascript의 원시타입(primitive data type)은 변경 불가능한(immutable value)이다. </p>
<ul>
<li>Boolean</li>
<li>null</li>
<li>undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol(New in ECMAScript 6)</li>
</ul>
<p>원시타입 이외의 모든 값은 객체(Object)타입이며 변경 가능한 값(mutable value)이다. 즉, 객체는 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다는 것이다. </p>
<p>예를 들어 살펴보자. C언어와는 다르게 Javascript의 문자열은 변경 불가능한 값(immutable value)이다. 이런 값을 “primitive values”라 한다. (변경이 불가능하다는 뜻은 메모리 영역에서의 변경이 불가능하다는 뜻이다. 재할당은 가능하다.)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>첫번째 구문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 메모리에 생성된 문자열 ‘Hello’의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고이 있다. 변수 str은 문자열 ‘Hello’를 카리키고 있다가 문자열 ‘world’를 가르키도록 변경되었을 뿐이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> statement = <span class="string">&#x27;I am an immutable value&#x27;</span>; <span class="comment">// string은 immutable value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherStr = statement.slice(<span class="number">8</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(otherStr);   <span class="comment">// &#x27;immutable&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(statement);  <span class="comment">// &#x27;I am an immutable value&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2행에서 String 객체의 slice() 메소드는 statement 변수에 저장된 문자열을 변경하는 것이 아니라 사실 새로운 문자열을 생성하여 반환하고 있다. 그 이유는 문자열은 변경할 수 없는 immutable value이기 때문이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v2 = arr.push(<span class="number">2</span>);    <span class="comment">// arr.push()는 메소드 실행 후 arr의 length를 반환</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>상기 예제에서 v2의 값은 무엇인가? 문자열의 예와 같이 배열이 동작한다면 v2는 새로운 배열(하나의 요소를 가지고  그 값은 2인)가지게 될것이다. 그러나 객체인 arr은 push 메소드에 의해 update 되고 v2에는 배열의 새로운 length 값이 반환된다. </p>
<p>처리 후 결과의 복사본을 리턴하는 문자열의 메소드 slice()와는 달리 배열(객체)의 메소드 push()는 직접 대상 배열을 변경한다. 그 이유는 배열은 객체이고 객체는 immutable value가 아닌 변경 가능한 값이기 때문이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myName = user.name; <span class="comment">// 변수 myName은 string 타입이다.</span></span><br><span class="line"></span><br><span class="line">user.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myName); <span class="comment">// Lee</span></span><br><span class="line"></span><br><span class="line">myName = user.name;  <span class="comment">// 재할당</span></span><br><span class="line"><span class="built_in">console</span>.log(myName); <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>

<p>user.name의 값을 변경했지만 변수 myName의 값은 병경되지 않았다. 이는 변수 myName에 user.name을 할당했을 때 user.name의 참조를 할당하는 것이 아니라 immutable한 값 ‘Lee’가 메모리에 새로 생성되고 myName은 이것을 참조하기 떄문이다. 따라서 user.name의 값이 변경된다 하더라도 변수 myName이 참조하고 있는 ‘Lee’는 변함이 없다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 = user1; <span class="comment">// 변수 user2는 객체 타입이다.</span></span><br><span class="line"></span><br><span class="line">user2.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1.name); <span class="comment">// Kim</span></span><br><span class="line"><span class="built_in">console</span>.log(user2.name); <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>

<p>위의 경우 객체 user2의 name 프로퍼티에 새로운 값을 할당하면 객체는 변경 불가능한 값이 아니므로 객체 user2는 변경된다. 그런데 변경하지도 않은 객체 user1도 동시에 변경된다. 이는 user1과 user2가 같은 어드레스를 참조하고 있기 때문이다.</p>
<p>이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하다.</p>
<h1 id="2-불변-데이터-패턴-immutable-data-pattern"><a href="#2-불변-데이터-패턴-immutable-data-pattern" class="headerlink" title="2. 불변 데이터 패턴(immutable data pattern)"></a>2. 불변 데이터 패턴(immutable data pattern)</h1><p>의도하지 않은 객체의 변경이 발생하는 원인의 대다수는 “레퍼런스를 참조한 다른 객체에서 객체를 변경”하기 때문이다. 이 문제의 해결 방법은 비용은 조금 들지만 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. </p>
<ul>
<li>객체의 방어적 복사(defensive copy): Object.assign</li>
<li>불변객체화를 통한 객체 변경 방지: Object.freeze</li>
</ul>
<h2 id="2-1-Object-assign"><a href="#2-1-Object-assign" class="headerlink" title="2.1 Object.assign"></a>2.1 Object.assign</h2><p>Object.assign은 타깃 객체로 소스 객체의 프로퍼티를 복사한다. 이때 소스 객체의 프로퍼티와 동일한 프로퍼티를 가진 타깃 객체의 프로퍼티들은 소스 객체의 프로퍼티로 덮어쓰기 된다. 리턴값으로 타깃 객체를 반환한다. ES6에서 추가된 메소드이며 Internet Explorer는 지원하지 않는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syntax</span></span><br><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj == copy); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge</span></span><br><span class="line"><span class="keyword">const</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge1 = <span class="built_in">Object</span>.assign(o1, o2, o3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(merge1); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1);     <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 타겟 객체가 변경된다!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge</span></span><br><span class="line"><span class="keyword">const</span> o4 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o5 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o6 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge2 = <span class="built_in">Object</span>.assign(&#123;&#125;, o4, o5, o6);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(merge2); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o4);     <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign을 사용하여 기존 객체를 변경하지 않고 객체를 복사하여 사용할 수 있다. Object.assign은 완전한 deep copy를 지원히지 않는다. 객체 내부의 객체(Nested Object)는 Shallow copy된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 빈 객체에 user1을 copy한다.</span></span><br><span class="line"><span class="keyword">const</span> user2 = <span class="built_in">Object</span>.assign(&#123;&#125;, user1);</span><br><span class="line"><span class="comment">// user1과 user2는 참조값이 다르다.</span></span><br><span class="line"><span class="built_in">console</span>.log(user1 === user2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">user2.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user1.name); <span class="comment">// Lee</span></span><br><span class="line"><span class="built_in">console</span>.log(user2.name); <span class="comment">// Kim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 내부의 객체(Nested Object)는 Shallow copy된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.address === user2.address); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">user1.address.city = <span class="string">&#x27;Busan&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user1.address.city); <span class="comment">// Busan</span></span><br><span class="line"><span class="built_in">console</span>.log(user2.address.city); <span class="comment">// Busan</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Object-freeze"><a href="#2-2-Object-freeze" class="headerlink" title="2.2 Object.freeze"></a>2.2 Object.freeze</h2><p>Object.freeze()를 사용하여 불변(immutable)객체를 만들 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.assign은 완전한 deep copy를 지원하지 않는다.</span></span><br><span class="line"><span class="keyword">const</span> user2 = <span class="built_in">Object</span>.assign(&#123;&#125;, user1, &#123;<span class="attr">name</span>: <span class="string">&#x27;Kim&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1.name); <span class="comment">// Lee</span></span><br><span class="line"><span class="built_in">console</span>.log(user2.name); <span class="comment">// Kim</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(user1);</span><br><span class="line"></span><br><span class="line">user1.name = <span class="string">&#x27;Kim&#x27;</span>; <span class="comment">// 무시된다!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1); <span class="comment">// &#123; name: &#x27;Lee&#x27;, address: &#123; city: &#x27;Seoul&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(user1)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>하지만 객체 내부의 객체(Nested Object)는 변경이 가능하다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(user);</span><br><span class="line"></span><br><span class="line">user.address.city = <span class="string">&#x27;Busan&#x27;</span>; <span class="comment">// 변경된다!</span></span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123; name: &#x27;Lee&#x27;, address: &#123; city: &#x27;Busan&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>내부 객체까지 변경 불가능하게 만들려면 Deep freeze를 하여야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  props.forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prop = obj[name];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> prop === <span class="string">&#x27;object&#x27;</span> &amp;&amp; prop !== <span class="literal">null</span>) &#123;</span><br><span class="line">      deepFreeze(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deepFreeze(user);</span><br><span class="line"></span><br><span class="line">user.name = <span class="string">&#x27;Kim&#x27;</span>;           <span class="comment">// 무시된다</span></span><br><span class="line">user.address.city = <span class="string">&#x27;Busan&#x27;</span>; <span class="comment">// 무시된다</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123; name: &#x27;Lee&#x27;, address: &#123; city: &#x27;Seoul&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-Immutable-js"><a href="#2-3-Immutable-js" class="headerlink" title="2.3 Immutable.js"></a>2.3 Immutable.js</h2><p>Object.assign과 Object.freeze을 사용하여 불변 객체를 만드는 방법은 번거러울 뿐더러 성능상 이슈가 있어서 큰 객체에는 사용하지 않는 것이 좋다. </p>
<p>또다른 대안으로 Facsbook이 제공하는 <a target="_blank" rel="noopener" href="https://immutable-js.com/">Immutable.js</a>를 사용하는 방법이 있다. </p>
<p>Immutable.js는 List, Stack, Map, OrderedMap, Set, OrderedSet, Record와 같은 영구 불변 (Permit Immutable) 데이터 구조를 제공한다.</p>
<p>npm을 사용하여 Immutable.js를 설치한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install immutable</span><br></pre></td></tr></table></figure>

<p>Immutable.js의 Map 모듈을 임포트하여 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="built_in">Map</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;immutable&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="built_in">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> map2 = map1.set(<span class="string">&#x27;b&#x27;</span>, <span class="number">50</span>)</span><br><span class="line">map1.get(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line">map2.get(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<p>map1.set(‘b’, 50)의 실행에도 불구하고 map1은 불변하였다. map1.set()은 결과를 반영한 새로운 객체를 반환한다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-immutability">poiemaweb.com/js-immutability</a></p>
<p><a target="_blank" rel="noopener" href="https://dassur.ma/things/deep-copy/">Deep-copying in JavaScript</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-30T01:04:16.340Z" title="2021-6-30 10:04:16">2021-06-30</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-20T01:47:27.349Z" title="2021-7-20 10:47:27">2021-07-20</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">35분안에 읽기 (약 5310 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/30/js-day7-object/">js-day7-object</a></h1><div class="content"><h2 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체 (Object)"></a>객체 (Object)</h2><h1 id="1-객체-Object-란"><a href="#1-객체-Object-란" class="headerlink" title="1. 객체(Object)란?"></a>1. 객체(Object)란?</h1><p>자바스크립트는 객체(object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.</p>
<p>자바스크립트의 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. </p>
<p>이와 같이 객체는 데이터를 의미하는 프로퍼티(property)와 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드(method)로 구성된 집합이다. 객체를 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문에 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다.</p>
<p>자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 “프로토타입(prototype)”이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다. 이 프로토타입은 타 언어와 구별되는 중요한 개념이다. </p>
<h2 id="1-1-프로퍼티"><a href="#1-1-프로퍼티" class="headerlink" title="1.1 프로퍼티"></a>1.1 프로퍼티</h2><p>프로퍼티는 프로퍼티 키(이름)와 프로퍼티 값으로 구성된다. 프로퍼티는 프로퍼티 키로 유일하게 식별할 수 있다. 즉, 프로퍼티 키는 프로퍼티를 식별하기 위한 식별자(identifier)다. 프로퍼티 키의 명명 규칙과 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다. </p>
<ul>
<li>프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 symbol 값</li>
<li>프로퍼티 값: 모든 값</li>
</ul>
<p>프로퍼티 키에 문자열이나 symbol 값 이외의 값을 지정하면 암묵적으로 타입이 변환되어 문자열이 된다. 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 배열과는 달리 객체는 프로퍼티를 열거할 때 순서를 보장하지 않는다. </p>
<h2 id="1-2-메소드"><a href="#1-2-메소드" class="headerlink" title="1.2 메소드"></a>1.2 메소드</h2><p>프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. 즉, 메소드는 객체에 제한되어 있는 함수를 의미한다. </p>
<h1 id="2-객체-생성-방법"><a href="#2-객체-생성-방법" class="headerlink" title="2. 객체 생성 방법"></a>2. 객체 생성 방법</h1><p>자바와 같은 클래스 기반 객체 지향언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 프로토타입 기반 객체 지향 언어로서 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다. </p>
<blockquote>
<p>ECMAScript 6에서 새롭게 클래스가 도입되었다. 프로토타입 기반 프로그래밍은 클래스가 존재하지 않는 객체지향 프로그래밍 스타일이다. 클래스없이 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현한다. 하지만 클래스 기반 언어에 익숙한 프로그래머들은 혼란을 일으킬 수 있으며 자바스크립트를 어렵게 느끼게하는 하나의 장벽처럼 인식되었다. ES6의 클래스는 기존 프로토타입 기반 객체지향 프로그래밍보다 클래스 기반 언어에 익숙한 프로그래머가 보다 빠르게 학습할 수 있는 단순하고 깨끗한 새로운 문법을 제시하고 있다. ES6의 클래스가 새로운 객체지향 모델을 제공하는 것이 아니며 클래스도 사실 함수이고 기존 프로토타입 기반 패턴의 문법적 설탕(Syntactic sugar)이다.</p>
</blockquote>
<h2 id="2-1-객체-리터럴"><a href="#2-1-객체-리터럴" class="headerlink" title="2.1 객체 리터럴"></a>2.1 객체 리터럴</h2><p>가장 일반적인 자바스크립트의 객체 생성 방식이다. 클래스 기반 객체 지향 언어와 비교할 때 매우 간편하게 객체를 생성할 수 있다. 중괄호({})를 사용하여 객체를 생성하는데 {} 내에 1개 이상의 프로퍼티를 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. {} 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> emptyObject); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: &quot;Lee&quot;, gender: &quot;male&quot;, sayHello: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">person.sayHello(); <span class="comment">// Hi! My name is Lee</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Object-생성자-함수"><a href="#2-2-Object-생성자-함수" class="headerlink" title="2.2 Object 생성자 함수"></a>2.2 Object 생성자 함수</h2><p>new 연산자와 Object 생성자 함수를 호출하여 빈 객체를 생성할 수 있다. 빈 객체 생성 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성하는 방법이다. </p>
<p>생성자(Constructor) 함수란 new 키워드와 함께 객체를 생성하고 초기화 하는 함수를 말한다. 생성자 함수를 통해 생성된 객체를 인스턴스(instrance)라 한다. 자바스크립트 Object 생성자 함수 이외에도 String, Number, Boolean, Arraym Date, RegExp 등의 빌트인 생성자 함수를 제공한다. 일반 함수와 생성자 함수를 구분하기 위해 생성자 함수의 이름은 파스칼 케이스(PascalCase)를 사용하는 것이 일반적이다. </p>
<p>객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당하면 해당 객체에 프로퍼티를 추가하고 값을 할당한다. 이미 존재하는 프로퍼티 키에 새로운 값을 할당하면 프로퍼티 값은 할당한 값으로 변경된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빈 객체의 생성</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">person.name = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line">person.gender = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: &quot;Lee&quot;, gender: &quot;male&quot;, sayHello: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">person.sayHello(); <span class="comment">// Hi! My name is Lee</span></span><br></pre></td></tr></table></figure>

<p>반드시 Object 생성자 함수를 사용해 빈 객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다. Object 생성자 함수 방식은 특별한 이유가 없다면 그다지 유용해 보이지 않는다. </p>
<p>사실 객체 리터럴 방식으로 생성된 객체는 결국 빌트인(Built-in) 함수인 Object 생성자 함수로 객체를 생성하는 것을 단순화시킨 축약 표현(short-hand)이다. 다시말해, 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object 생성자 함수를 사용하여 객체를 생성한다. 따라서 개발자가 일부러 Object 생성자 함수를 사용해 객체를 생성해야 할 일은 거의 없다. </p>
<h2 id="2-3-생성자-함수"><a href="#2-3-생성자-함수" class="headerlink" title="2.3 생성자 함수"></a>2.3 생성자 함수</h2><p>객체 리터럴 방식과 Object 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러 개의 객체를 생성할 때 불편하다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Kim&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;female&#x27;</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>생성자 함수를 사용하면 마치 객체를 생성하기 위한 템플릿(클래스)처럼 사용하여 프로퍼티가 동일한 객체 여러 개를 간편하게 생성할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.gender = gender;</span><br><span class="line">  <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;person1: &#x27;</span>, <span class="keyword">typeof</span> person1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;person2: &#x27;</span>, <span class="keyword">typeof</span> person2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;person1: &#x27;</span>, person1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;person2: &#x27;</span>, person2);</span><br><span class="line"></span><br><span class="line">person1.sayHello();</span><br><span class="line">person2.sayHello();</span><br></pre></td></tr></table></figure>

<ul>
<li>생성자 함수 이름은 일반적으로 대문자로 시작한다. 이것은 생성자 함수임을 익식하도록 도움을 준다. </li>
<li>프로퍼티 또는 메소드명 앞에 기술한 this는 생성자 함수가 생성할 인스턴스(instance)를 가르킨다. </li>
<li>this에 연결(바인딩)되어 있는 프로퍼티와 메소드는 public (외부에서 참조 가능)하다. </li>
<li>생성자 함수 내에서 선언된 일반 변수는 private (외부에서 참조 불가능)하다. 즉, 생성자 함수내부에서는 자유롭게 접근이 가능하나 외부에서 접근할 수 없다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> married = <span class="literal">true</span>;         <span class="comment">// private</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;           <span class="comment">// public</span></span><br><span class="line">  <span class="built_in">this</span>.gender = gender;       <span class="comment">// public</span></span><br><span class="line">  <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// public</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Person &#123; name: &#x27;Lee&#x27;, gender: &#x27;male&#x27;, sayHello: [Function] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.gender);  <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.married); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트의 생성자 함수는 이름 그대로 객체를 생성하는 함수이다. 하지만 자바와 같은 클래스 기반 객체지향 언어의 생성자(constructor)와는 다르게 그 형식이 정해져 있는 것이 아니라 기존 함수와 동일한 방법으로 생성자 함수를 선언하고 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. </p>
<p>이는 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것을 의미한다. 따라서 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼락을 방지하려는 노력을 한다. </p>
<p>new 연산자와 함꼐 함수를 호출하면 this 바인딩이 다르게 동작한다. 자세한 내용은 생성자 호출 패턴을 참조</p>
<h1 id="3-객체-프로퍼티-접근"><a href="#3-객체-프로퍼티-접근" class="headerlink" title="3. 객체 프로퍼티 접근"></a>3. 객체 프로퍼티 접근</h1><h2 id="3-1-프로퍼티-키"><a href="#3-1-프로퍼티-키" class="headerlink" title="3.1 프로퍼티 키"></a>3.1 프로퍼티 키</h2><p>프로퍼티 키는 일반적으로 문자열(빈 문자열 포함)을 지정한다. 프로퍼티 키에 문자열이나 symbol 값 이외의 값을 지정하면 암묵적으로 타입이 변환되어 문자열이 된다. 또한 문자열 타입의 값으로 수렴될 수 있는 표현식도 가능하다. 프로ㅓ퍼티 키는 문자열이므로 따옴표 (‘’ 또는 “”)를 사용한다. 하지만 자바스크립트에서 사용 가능한 유효한 이름인 경우, 따옴표를 생략할 수 있다. 반대로 말하면 자바스크립트에서 사용간으한 유효한 이름이 아닌 경우, 반드시 따옴표를 사용하여야 한다. </p>
<p>프로퍼티 값은 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메소드라 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Ung-mo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>: 1 // <span class="title">OK</span>. 하지만 예약어는 사용하지 말아야 한다.</span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>

<p>프로퍼티 키 first-name에는 반드시 따옴표를 사용해야 하지만 first_name 에는 생략 가능하다. first-name은 자바스크립트에서 사용 간으한 유효한 이름이 아니라 ‘-‘연산자가 있는 표현식이기 때문이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  first-name: <span class="string">&#x27;Ung-mo&#x27;</span>, <span class="comment">// SyntaxError: Unexpected token -</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>표현식을 프로퍼티 키로 사용하려면 키로 사용할 표현식을 대괄호로 묶어야 한다. 이때 자바스크립트 엔진은 표현식을 평가하기 위해 식별자 first를 찾을 것이고 이때 ReferenceError가 발생한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  [first-name]: <span class="string">&#x27;Ung-mo&#x27;</span>, <span class="comment">// ReferenceError: first is not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>예약어를 프로퍼티 키로 사용하여도 에러가 발생하지는 않는다. 하지만 예상치 못한 에러가 발생할 수 있으므로 예약어를 프로퍼티 키로 사용해서는 않된다. 자바스크립트 예약어는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">abstract  arguments boolean break byte</span><br><span class="line">case  catch char  class*  const</span><br><span class="line">continue  debugger  default delete  do</span><br><span class="line">double  else  enum* eval  export*</span><br><span class="line">extends*  false final finally float</span><br><span class="line">for function  goto  if  implements</span><br><span class="line">import* in  instanceof  int interface</span><br><span class="line">let long  native  new null</span><br><span class="line">package private protected public  return</span><br><span class="line">short static  super*  switch  synchronized</span><br><span class="line">this  throw throws  transient true</span><br><span class="line">try typeof  var void  volatile</span><br><span class="line">while with  yield</span><br><span class="line">&#x2F;&#x2F; *는 ES6에서 추가된 예약어</span><br></pre></td></tr></table></figure>

<h2 id="3-2-프로퍼티-값-읽기"><a href="#3-2-프로퍼티-값-읽기" class="headerlink" title="3.2 프로퍼티 값 읽기"></a>3.2 프로퍼티 값 읽기</h2><p>객체의 프로퍼티 값에 접근하는 방법은 마침표(.) 표기법과 대괄호([]) 표기법이 있다. 예제를 통해 이 두 방법의 차이를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Ung-mo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.first-name);    <span class="comment">// NaN: undefined-undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person[first-name]);   <span class="comment">// ReferenceError: first is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;first-name&#x27;</span>]); <span class="comment">// &#x27;Ung-mo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.gender);    <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person[gender]);   <span class="comment">// ReferenceError: gender is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;gender&#x27;</span>]); <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;1&#x27;</span>]); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="number">1</span>]);   <span class="comment">// 10 : person[1] -&gt; person[&#x27;1&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(person<span class="number">.1</span>);    <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 키가 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다. </p>
<p>프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, 대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열이어야 한다. </p>
<p>객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Ung-mo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-프로퍼티-값-갱신"><a href="#3-3-프로퍼티-값-갱신" class="headerlink" title="3.3 프로퍼티 값 갱신"></a>3.3 프로퍼티 값 갱신</h2><p>객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 갱신 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Ung-mo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person[<span class="string">&#x27;first-name&#x27;</span>] = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;first-name&#x27;</span>] ); <span class="comment">// &#x27;Kim&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-프로퍼티-동적-생성"><a href="#3-4-프로퍼티-동적-생성" class="headerlink" title="3.4 프로퍼티 동적 생성"></a>3.4 프로퍼티 동적 생성</h2><p>객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당하면 주어진 키와 값으로 프로퍼티를 생성하여 객체에 추가한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Ung-mo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-프로퍼티-삭제"><a href="#3-5-프로퍼티-삭제" class="headerlink" title="3.5 프로퍼티 삭제"></a>3.5 프로퍼티 삭제</h2><p>delete 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. 이때 피연산자는 프로퍼티 키이어야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Ung-mo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.gender;</span><br><span class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Object &#123;first-name: &#x27;Ung-mo&#x27;, last-name: &#x27;Lee&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-6-for-in문"><a href="#3-6-for-in문" class="headerlink" title="3.6 for-in문"></a>3.6 for-in문</h2><p>for-in 문을 사용하면 객체(배열 포함)에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Ung-mo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prop에 객체의 프로퍼티 이름이 반환된다. 단, 순서는 보장되지 않는다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">&#x27;: &#x27;</span> + person[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first-name: Ung-mo</span></span><br><span class="line"><span class="comment">last-name: Lee</span></span><br><span class="line"><span class="comment">gender: male</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// index에 배열의 경우 인덱스가 반환된다</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> array) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27;: &#x27;</span> + array[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0: one</span></span><br><span class="line"><span class="comment">1: two</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>for-in 문은 객체의 문자열 키(key)를 순회하기 위한 문법이다. 배열에는 사용하지 않는것이 좋다. </p>
<ol>
<li><p>객체의 경우, 프로퍼티의 순서가 보장되지 않는다. 그 이유는 원래 객체의 프로퍼티에는 순서가 없기 때문이다. 배열은 순서를 보장하는 데이터 구조이지만 객체와 마찬가지로 순서를 보장하지 않는다. </p>
</li>
<li><p>배열 요소들만을 순회하지 않는다. </p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 요소들만을 순회하지 않는다.</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>];</span><br><span class="line">array.name = <span class="string">&#x27;my array&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> array) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27;: &#x27;</span> + array[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0: one</span></span><br><span class="line"><span class="comment">1: two</span></span><br><span class="line"><span class="comment">name: my array</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>이와 같은 for-in문의 단점을 극복하기 위해 ES6에서 for-of문이 추가되었다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">array.name = <span class="string">&#x27;my array&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> array.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>for–in 문은 객체의 프로퍼티를 순회하기 위해 사용하고 for–of 문은 배열의 요소를 순회하기 위해 사용한다.</p>
<h1 id="4-Pass-by-reference"><a href="#4-Pass-by-reference" class="headerlink" title="4. Pass-by-reference"></a>4. Pass-by-reference</h1><p>object type을 객체 타입 또는 참조 타입이라 한다. 참조 타입이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다. 원시 타입은 값이한번 정해지면 변경할 수 없지만 (immutable), 객체는 프로퍼티를 변경, 추가, 삭제가 가능하므로 변경 가능(mutable)한 값이라 할 수 있다.</p>
<p>따라서 객체 타입은 동적으로 변화할 수 있으므로 어느 정도의 메모리 공간을 확보해야 하는지 예측할 수 없기 때문에 런타임에 메모리 공간을 확보하고 메모리의 힙 영역(Heap Segment)에 저장된다. </p>
<p>이에 반해 원시 타입은 값(value)으로 전달된다. 즉, 복사되어 전달된다. 이를 pass-by-value라 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass-by-reference</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  val: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo.val, bar.val); <span class="comment">// 10 10</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === bar);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">bar.val = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.val, bar.val); <span class="comment">// 20 20</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === bar);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>foo 객체를 객체 리터럴 방식으로 생성하였다. 이때 변수 foo는 객체 자체를 정항하고 있는것이 아니라 생성된 객체의 참조값(address)를 저장하고 있다. </p>
<p>변수 bar에 변수 foo의 값을 할당하였다. 변수 foo의 값은 생성된 객체를 가리키는 참조값이므로 변수 bar에도 같은 참조값이 저장된다. 즉, 변수 foo, bar 모두 동일한 객체를 참조하고 있다. 따라서 참조하고 있는 객체의 val 값이 변경되면 변수 foo, bar 모두 동일한 객체를 팜조하고 있으므로 두 변수 모두 변경된 객체의 프로퍼티 값을 참조하게 된다. 객체는 참조(Reference)방식으로 전달된다. 결코 복사되지 않는다. </p>
<p>foo –&gt; val:10 &lt;– bar</p>
<p>아래의 경우는 위의 경우와 약간 차이가 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">val</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> bar = &#123; <span class="attr">val</span>: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.val, bar.val); <span class="comment">// 10 10</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === bar);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = bar;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(baz.val, bar.val); <span class="comment">// 10 10</span></span><br><span class="line"><span class="built_in">console</span>.log(baz === bar);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>변수 foo와 변수 bar는 비록 내용은 같지만 별개의 객체를 생성하여 참조값을 할당하였다. 따라서 변수 foo와 변수 bar의 참조값 즉 어드레스는 동일하지 않다.</p>
<p>변수 baz에는 변수 bar의 값을 할당하였다. 결국 변수 baz와 변수 bar는 동일한 객체를 가리키는 참조값을 저장하고 있다. 따라서 변수 baz와 변수 bar의 참조값은 동일하다.</p>
<p>foo –&gt; val:10<br>bar –&gt; val:10 &lt;– baz</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;; <span class="comment">// a, b, c는 각각 다른 빈 객체를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b, a === c, b === c); <span class="comment">// false false false</span></span><br><span class="line"></span><br><span class="line">a = b = c = &#123;&#125;; <span class="comment">// a, b, c는 모두 같은 빈 객체를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b, a === c, b === c); <span class="comment">// true true true</span></span><br></pre></td></tr></table></figure>

<h1 id="5-Pass-by-value"><a href="#5-Pass-by-value" class="headerlink" title="5. Pass-by-value"></a>5. Pass-by-value</h1><p>원시타입 값(value)으로 전달된다. 즉, 값이 복사되어 전달된다. 이를 pass-by-value(값에 의한 전달)라 한다. 원시타입은 값이 한번 정해지면 변경할 수 없다.(immutable) 또한 이들 값은 런타임(변수 할당 시점)에 메모리의 스택 영역(Stack Segment)에 고정된 메모리 영역을 점유하고 저장된다. </p>
<p>immutable에 대한 상세한 내용은 객체와 변경불가성(Immutability)을 참조</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass-by-value</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1  1</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1  10</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>변수 a는 원시 타입인 숫자 타입 1을 저장하고 있다. 원시 타입의 경우 값이 복사되어 변수에 저장된다. 즉, 참조 타입으로 저장되는 것이 아니라 값 자체가 저장되게 된다. 변수 b에 변수 a를 할당할 경우, 변수 a의 값 1은 복사되어 변수 b에 저장된다.</p>
<h1 id="6-객체의-분류"><a href="#6-객체의-분류" class="headerlink" title="6. 객체의 분류"></a>6. 객체의 분류</h1><p>객체는 아래와 같이 분류할 수 있다. </p>
<p>Object    </p>
<ul>
<li>Host Obejct    </li>
<li>Built-in Object  <ul>
<li>Standard Built-in Object</li>
<li>Native Object<ul>
<li>BOM(Browser Object Model)</li>
<li>DOM(Document Object Model)</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Built-in Object(내장 객체)는 웹페이지 등을 표현하기 위한 공통의 기능을 제공한다. 웹페이지가 브라우저에 의해 로드되자마자 별다른 행위없이 바로 사용이 가능하다. Built-in Object는 아래와 같이 구분할 수 있다.</p>
<ul>
<li>Standard Built-in Objects (or Global Objects)</li>
<li>BOM (Browser Object Model)</li>
<li>DOM (Document Object Model)</li>
</ul>
</blockquote>
<blockquote>
<p>Standard Built-in Objects(표준 빌트인 객체)를 제외한 BOM과 DOM을 Native Object라고 분류하기도 한다. 또한 사용자가 생성한 객체를 Host Object(사용자 정의 객체)라 한다.</p>
<ul>
<li>Host Object(사용자 정의 객체)<br>사용자가 생성한 객체 들이다. constructor 혹은 객체리터럴을 통해 사용자가 객체를 정의하고 확장시킨 것들이기 때문에 Built-in Object 와 Native Object가 구성된 이후에 구성된다.</li>
</ul>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-object">poiemaweb.com/js-object</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-24T07:32:28.847Z" title="2021-6-24 16:32:28">2021-06-24</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-30T01:25:35.487Z" title="2021-6-30 10:25:35">2021-06-30</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">31분안에 읽기 (약 4616 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/24/js-day6-type-coercion/">js-day6-type-coercion</a></h1><div class="content"><h1 id="1-타입-변환이란"><a href="#1-타입-변환이란" class="headerlink" title="1. 타입 변환이란?"></a>1. 타입 변환이란?</h1><p>자바스크립트의 모든 값은 타입이 있다. 값의 타입은 다른 타입으로 개발자에 의해 의도적으로 변환할 수 있다. 자바스크립트 엔진에 의해 암묵적으로 자동 변환될 수 있다. 개발자에 의해 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type castion)이라 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 명시적 타입 변환</span></span><br><span class="line"><span class="keyword">var</span> str = x.toString(); <span class="comment">// 숫자를 문자열로 타입 캐스팅한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>동적 타입 언어인 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 <strong>암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)</strong> 이라고 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 타입 변환</span></span><br><span class="line"><span class="comment">// 숫자 타입 x의 값을 바탕으로 새로운 문자열 타입의 값을 생성해 표현식을 평가한다.</span></span><br><span class="line"><span class="keyword">var</span> str = x + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 x의 값이 변경된 것은 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>명시적 타입 변환도 마찬가지지만, 암묵적 타입 변환이 기존 값(위 예제의 경우, 변수 x의 값)을 직접 변경하는 것은 아니다. “변수”에서 살펴보았듯이 변수 값이 원시 타입의 값인 경우, 변수 값을 변경하려면 재할당을 통해 새로운 메모리 공간을 확보하고 그 곳에 원시 값을 저장한 후 변수명이 재할당된 원시 값이 저장된 메모리 공간의 주소를 기억하도록 해야 한다.</p>
<p>암묵적 타입 변환은 변수 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 기존 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다. 위 예제의 경우, 자바스크립트 엔진은 표현식 x + ‘‘을 평가하기 위해 변수 x의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’ + ‘‘를 평가한다. 이때 자동 생성된 문자열 ‘10’은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 제거된다.</p>
<p>명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.</p>
<p>따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지, 그리고 타입 변환된 값으로 표현식은 어떻게 평가될 것인지 예측 가능해야 한다. 만약 예측하지 못하거나 예측한 내용이 결과와 일치하지 않는다면 버그를 생산할 가능성이 높아진다.</p>
<p>그렇다면 명시적 타입 변환 만을 사용하고 암묵적 타입 변환은 발생하지 않도록 코드를 작성하면 어떨까? 좋은 생각이긴 하지만 이러한 논리는 옳지 않다. 때로는 명시적 타입 변환보다 암묵적 타입 변환이 가독성 면에서 더 좋을 수도 있다. 예를 들어 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 (10).toString()보다 10 + ‘’이 더욱 간결하고 이해하기 쉬울 수 있다.</p>
<p>중요한 것은 코드를 예측할 수 있어야 한다는 것이다. 동료가 작성한 코드를 정확히 이해할 수 있어야 하고 자신의 코드는 타인에 의해 쉽게 이해될 수 있어야 한다. 이를 위해 타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하도록 하자.</p>
<h1 id="2-암묵적-타입-변환"><a href="#2-암묵적-타입-변환" class="headerlink" title="2. 암묵적 타입 변환"></a>2. 암묵적 타입 변환</h1><p>자바스크립트 엔진은 표현식을 평가할 때 문맥, 즉 컨텍스트(Context)에 고려하여 암묵적 타입 변환을 실행한다. 아래 예제를 살펴보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 표현식이 모두 문자열 타입이여야 하는 컨텍스트</span></span><br><span class="line"><span class="string">&#x27;10&#x27;</span> + <span class="number">2</span>               <span class="comment">// &#x27;102&#x27;</span></span><br><span class="line"><span class="string">`1 * 10 = <span class="subst">$&#123; <span class="number">1</span> * <span class="number">10</span> &#125;</span>`</span> <span class="comment">// &quot;1 * 10 = 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식이 모두 숫자 타입이여야 하는 컨텍스트</span></span><br><span class="line"><span class="number">5</span> * <span class="string">&#x27;10&#x27;</span> <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식이 불리언 타입이여야 하는 컨텍스트</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>이처럼 표현식을 평가할 때 문맥, 즉 컨텍스트에 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다. </p>
<p>암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다. 타입별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자. </p>
<h2 id="2-1-문자열-타입으로-변환"><a href="#2-1-문자열-타입으로-변환" class="headerlink" title="2.1 문자열 타입으로 변환"></a>2.1 문자열 타입으로 변환</h2><p>아래의 예제를 살펴보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;2&#x27;</span> <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 + 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연셜 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 피연산자는 문맥, 즉 컨텍스트 상 문자열 타입이여야 한다. </p>
<p>자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다. </p>
<p>연산자 식의 피연산자(피연산자도 표현식이다)만이 암묵적 타입 변환의 대상이 되는 것은 아니다. 앞서 언급했듯이 자바스크립트 엔진은 표현식을 평가할 때 문맥, 즉 컨텍스트에 부합하도록 암묵적 타입 변환을 실행한다. 예를 들어 ES6에서 도입된 템플릿 리터럴의 문자열 인터폴레이션(String Interpolation)은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`1 + 1 = <span class="subst">$&#123;<span class="number">1</span> + <span class="number">1</span>&#125;</span>`</span>); <span class="comment">// &quot;1 + 1 = 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트 엔진은 문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 숫자 타입</span></span><br><span class="line"><span class="number">0</span> + <span class="string">&#x27;&#x27;</span>              <span class="comment">// &quot;0&quot;</span></span><br><span class="line">-<span class="number">0</span> + <span class="string">&#x27;&#x27;</span>             <span class="comment">// &quot;0&quot;</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;&#x27;</span>              <span class="comment">// &quot;1&quot;</span></span><br><span class="line">-<span class="number">1</span> + <span class="string">&#x27;&#x27;</span>             <span class="comment">// &quot;-1&quot;</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="string">&#x27;&#x27;</span>            <span class="comment">// &quot;NaN&quot;</span></span><br><span class="line"><span class="literal">Infinity</span> + <span class="string">&#x27;&#x27;</span>       <span class="comment">// &quot;Infinity&quot;</span></span><br><span class="line">-<span class="literal">Infinity</span> + <span class="string">&#x27;&#x27;</span>      <span class="comment">// &quot;-Infinity&quot;</span></span><br><span class="line"><span class="comment">// 불리언 타입</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">&#x27;&#x27;</span>           <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">&#x27;&#x27;</span>          <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="comment">// null 타입</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">&#x27;&#x27;</span>           <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="comment">// undefined 타입</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">&#x27;&#x27;</span>      <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="comment">// 심볼 타입</span></span><br><span class="line">(<span class="built_in">Symbol</span>()) + <span class="string">&#x27;&#x27;</span>     <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"><span class="comment">// 객체 타입</span></span><br><span class="line">(&#123;&#125;) + <span class="string">&#x27;&#x27;</span>           <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Math</span> + <span class="string">&#x27;&#x27;</span>           <span class="comment">// &quot;[object Math]&quot;</span></span><br><span class="line">[] + <span class="string">&#x27;&#x27;</span>             <span class="comment">// &quot;&quot;</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>] + <span class="string">&#x27;&#x27;</span>       <span class="comment">// &quot;10,20&quot;</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) + <span class="string">&#x27;&#x27;</span> <span class="comment">// &quot;function()&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">Array</span> + <span class="string">&#x27;&#x27;</span>          <span class="comment">// &quot;function Array() &#123; [native code] &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-숫자-타입으로-변환"><a href="#2-2-숫자-타입으로-변환" class="headerlink" title="2.2 숫자 타입으로 변환"></a>2.2 숫자 타입으로 변환</h2><p>아래의 예제를 살펴보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">&#x27;1&#x27;</span>    <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">&#x27;10&#x27;</span>   <span class="comment">// 10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">&#x27;one&#x27;</span>  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 연산자는 모두 산술 연산자이다. 산술 연산자의 역할은 숫자 값을 만드는 것이다. 따라서 산술 연산자의 피연산자는 문맥, 즉 컨텍스트 상 숫자 타입이여야 한다.</p>
<p>자바스크립트 엔지은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 NaN을 반환한다. </p>
<p>피연산자를 숫자 타입으로 변환해야 할 컨텍스트는 산술 연산자 뿐만이 아니다. 아래 예제를 살펴보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> &gt; <span class="number">0</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>비교 연산자의 역할은 불리언 값을 만드는 것이다. &gt; 비교 연산자는 피연산자의 크기를 비교하므로 피연산자는 컨텍스트 상 숫자 타입이여야 한다. 자바스크립트 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. </p>
<p>자바스크립트 엔진은 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다. + 단항 연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 타입</span></span><br><span class="line">+<span class="string">&#x27;&#x27;</span>             <span class="comment">// 0</span></span><br><span class="line">+<span class="string">&#x27;0&#x27;</span>            <span class="comment">// 0</span></span><br><span class="line">+<span class="string">&#x27;1&#x27;</span>            <span class="comment">// 1</span></span><br><span class="line">+<span class="string">&#x27;string&#x27;</span>       <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 불리언 타입</span></span><br><span class="line">+<span class="literal">true</span>           <span class="comment">// 1</span></span><br><span class="line">+<span class="literal">false</span>          <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// null 타입</span></span><br><span class="line">+<span class="literal">null</span>           <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// undefined 타입</span></span><br><span class="line">+<span class="literal">undefined</span>      <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 심볼 타입</span></span><br><span class="line">+<span class="built_in">Symbol</span>()       <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"><span class="comment">// 객체 타입</span></span><br><span class="line">+&#123;&#125;             <span class="comment">// NaN</span></span><br><span class="line">+[]             <span class="comment">// 0</span></span><br><span class="line">+[<span class="number">10</span>, <span class="number">20</span>]       <span class="comment">// NaN</span></span><br><span class="line">+(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다는 것에 주의하자.</p>
<h2 id="2-3-불리언-타입으로-변환"><a href="#2-3-불리언-타입으로-변환" class="headerlink" title="2.3 불리언 타입으로 변환"></a>2.3 불리언 타입으로 변환</h2><p>아래의 예제를 살펴보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>) <span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>

<p>if 문이나 for문과 같은 제어문의 조건식(conditional expression)은 불리언 값, 즉 논리적 참, 거짓을 반환해야 하는 표현식이다. 자바스크립트 엔진은 제어문의 조건식을 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>)    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)     <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;str&#x27;</span>) <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure>

<p>Falsy 값 이외의 값은 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 컨텍스트에서 모두 true로 평가되는 Truthy 값이다. </p>
<p>아래 예제는 Truthy/Falsy 값을 판별하는 함수다. 함수란 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. 함수에 대해서는 나중에 자세히 살펴볼 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFalsy</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isTruthy</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모두 true를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(isFalsy(<span class="literal">false</span>));</span><br><span class="line"><span class="built_in">console</span>.log(isFalsy(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(isFalsy(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(isFalsy(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(isFalsy(<span class="literal">NaN</span>));</span><br><span class="line"><span class="built_in">console</span>.log(isFalsy(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isTruthy(<span class="literal">true</span>));</span><br><span class="line"><span class="comment">// 빈 문자열이 아닌 문자열은 Truthy 값이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(isTruthy(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(isTruthy(&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(isTruthy([]));</span><br></pre></td></tr></table></figure>

<h1 id="3-명시적-타입-변환"><a href="#3-명시적-타입-변환" class="headerlink" title="3. 명시적 타입 변환"></a>3. 명시적 타입 변환</h1><p>개발자의 의도에 의해 명시적으로 타입을 변경하는 방법은 다양하다. 원래는 래퍼 객체를 생성하기 위해 사용하는 래퍼 객체 생성자 함수를 new 연산자 없이 호출하는 방법과 자바스크립트에서 제공하는 빌트인 메소드를 사용하는 방법, 그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다. </p>
<h2 id="3-1-문자열-타입으로-변환"><a href="#3-1-문자열-타입으로-변환" class="headerlink" title="3.1 문자열 타입으로 변환"></a>3.1 문자열 타입으로 변환</h2><p>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 아래와 같다. </p>
<ol>
<li>string 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>Object.prototype.toString 메소드를 사용하는 방법</li>
<li>문자열 연결 연산자를 이용하는 방법</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">1</span>));        <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">NaN</span>));      <span class="comment">// &quot;NaN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">Infinity</span>)); <span class="comment">// &quot;Infinity&quot;</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>));     <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">false</span>));    <span class="comment">// &quot;false&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.prototype.toString 메소드를 사용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).toString());        <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">NaN</span>).toString());      <span class="comment">// &quot;NaN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">Infinity</span>).toString()); <span class="comment">// &quot;Infinity&quot;</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).toString());     <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span>).toString());    <span class="comment">// &quot;false&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 문자열 연결 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">&#x27;&#x27;</span>);        <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> + <span class="string">&#x27;&#x27;</span>);      <span class="comment">// &quot;NaN&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">Infinity</span> + <span class="string">&#x27;&#x27;</span>); <span class="comment">// &quot;Infinity&quot;</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="string">&#x27;&#x27;</span>);     <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> + <span class="string">&#x27;&#x27;</span>);    <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-숫자-타입으로-변환"><a href="#3-2-숫자-타입으로-변환" class="headerlink" title="3.2 숫자 타입으로 변환"></a>3.2 숫자 타입으로 변환</h2><p>숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 아래와 같다. </p>
<ol>
<li>Number 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)</li>
<li><ul>
<li>단항 연결 연산자를 이용하는 방법</li>
</ul>
</li>
<li><ul>
<li>산술 연산자를 이용하는 방법</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;0&#x27;</span>));     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;-1&#x27;</span>));    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;10.53&#x27;</span>)); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>));   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;0&#x27;</span>));       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;-1&#x27;</span>));      <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;10.53&#x27;</span>)); <span class="comment">// 10.53</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. + 단항 연결 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;0&#x27;</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;-1&#x27;</span>);    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&#x27;10.53&#x27;</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">false</span>);   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. * 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0&#x27;</span> * <span class="number">1</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;-1&#x27;</span> * <span class="number">1</span>);    <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;10.53&#x27;</span> * <span class="number">1</span>); <span class="comment">// 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> * <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> * <span class="number">1</span>);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-불리언-타입으로-변환"><a href="#3-3-불리언-타입으로-변환" class="headerlink" title="3.3 불리언 타입으로 변환"></a>3.3 불리언 타입으로 변환</h2><p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 아래와 같다. </p>
<ol>
<li>Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>!부정 논리 연산자를 두번 사용하는 방법</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;x&#x27;</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>));        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>));         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>));       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">Infinity</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>));      <span class="comment">// false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타 입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(&#123;&#125;));        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>([]));        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ! 부정 논리 연산자를 두번 사용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&#x27;x&#x27;</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&#x27;&#x27;</span>);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&#x27;false&#x27;</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">1</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">Infinity</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">null</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">console</span>.log(!!&#123;&#125;);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!![]);        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="5-단축-평가"><a href="#5-단축-평가" class="headerlink" title="5. 단축 평가"></a>5. 단축 평가</h1><p>아래 예제를 살펴보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span> <span class="comment">// “Dog”</span></span><br></pre></td></tr></table></figure>

<p>논리곱 연산자 <strong>&amp;&amp;</strong> 는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 대부분의 연산자가 그렇듯이 논리곱 연산자도 오른쪽에서 왼쪽으로 평가가 진행된다. </p>
<ol>
<li><p>첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다. 두번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. </p>
</li>
<li><p>두번째 피연산자 ‘Dog’은 Truthy 값이므로 true로 평가된다. 이때 두개의 피연산자가 모두 true로 평가되었다. 이때 논리곱 연산의 결과를 결정한 것은 두번째 피연산자 ‘Dog’다. </p>
</li>
<li><p>논리곱 연산자 <strong>&amp;&amp;</strong> 는 논리 연산의 결과를 결정한 두번째 피연산자의 평가 결과 즉, 문자열 ‘Dog’를 그대로 반환한다. </p>
</li>
</ol>
<p>논리합 연산자 || 도 논리곱 연산자 &amp;&amp;와 동일하게 동작한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Cat&#x27;</span> || <span class="string">&#x27;Dog&#x27;</span> <span class="comment">// &#x27;Cat&#x27;</span></span><br></pre></td></tr></table></figure>

<p>논리합 연산자 <strong>||</strong> 는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다. 대부분의 연산자가 그렇듯이 논리합 연산자도 오른쪽에서 왼쪽으로 평가가 진행된다. </p>
<ol>
<li><p>첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 이 시점에 두번째 피연산자까지 평가해 보지 않아도 위 표현식을 평가할 수 있다. </p>
</li>
<li><p>논리합 연산자 <strong>||</strong> 는 논리 연산의 결과를 결정한 첫번째 피연산자의 평가 결과 즉, 문자열 ‘Cat’를 그대로 반환한다. </p>
</li>
</ol>
<p>논리곱 연산자 <strong>&amp;&amp;</strong> 와 논리합 <strong>||</strong> 는 이와 같이 논리 평가를 결정한 피연산자의 평가 결과를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다. 단축 평가는 아래의 규칙을 따른다. </p>
<table>
<thead>
<tr>
<th>단축 평가 표현식</th>
<th>평가 결과</th>
</tr>
</thead>
<tbody><tr>
<td>true     &#124;    &#124; anything</td>
<td>true</td>
</tr>
<tr>
<td>false     &#124;    &#124; anything</td>
<td>anything</td>
</tr>
<tr>
<td>true &#38;&#38; anything</td>
<td>anything</td>
</tr>
<tr>
<td>false &#38;&#38; anything</td>
<td>false</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> || <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// &#x27;Cat&#x27;</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// &#x27;Dog&#x27;</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> || <span class="literal">false</span>  <span class="comment">// &#x27;Cat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// Dog</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="literal">false</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>단축 평가는 아래와 같은 상황에서 유용하게 사용된다. </p>
<p>아직 살펴보지 않은 객체와 함수에 대한 내용이 나와서 혼한스러울 수 있겠다. 지금은 아래와 같은 단축 평가의 유용한 패턴이 있다는 정도로 이해하고 넘어가도 좋다. 객체와 함수에 대해서는 해당 장에서 자세히 살펴볼 것이다. </p>
<ul>
<li>객체가 null인지 확인하고 프로퍼티를 참조할 때 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(elem.value); <span class="comment">// TypeError: Cannot read property &#x27;value&#x27; of null</span></span><br><span class="line"><span class="built_in">console</span>.log(elem &amp;&amp; elem.value); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(Type Error)가 발생한다. 이때 단축 평가를 사용하면 에러를 발생시키지 않는다. </p>
<ul>
<li>함수의 인수(argument)를 초기화할 때 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 단축 평가를 사용한 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength();     <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">&#x27;hi&#x27;</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6의 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength();     <span class="comment">// 0</span></span><br><span class="line">getStringLength(<span class="string">&#x27;hi&#x27;</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>함수를 호출할 때 인수를 전달하지 않으면 매개변수를 undefined를 갖는다. 이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다. </p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-type-coercion">poiemaweb.com/js-type-coercion</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-21T07:51:42.799Z" title="2021-6-21 16:51:42">2021-06-21</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-07-01T08:10:10.323Z" title="2021-7-1 17:10:10">2021-07-01</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">31분안에 읽기 (약 4659 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/21/js-day5-control-flow/">js-day5-control-flow</a></h1><div class="content"><h3 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h3><h2 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h2><p>제어문(Control flow statement)은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. </p>
<p>일반벅으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문은 코드의 실행 순서를 인위적으로 제어할 수 있다.</p>
<h1 id="1-블록문"><a href="#1-블록문" class="headerlink" title="1. 블록문"></a>1. 블록문</h1><p>블록문(Block statement/Compound statement)는 0개 이상의 문들을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 단위로 취급한다. </p>
<p>블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수 선언문 등에서 사용한다. 문의 끝에는 세미 콜론(;)을 붙이는 것이 일반적이지만 블록문은 세미 콜론을 붙이지 않는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 블록문</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제어문</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h1 id="2-조건문"><a href="#2-조건문" class="headerlink" title="2. 조건문"></a>2. 조건문</h1><p>조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다.</p>
<p>자바스크립트는 2가지의 조건문 if…else 문과 switch 문을 제공한다.</p>
<h2 id="2-1-if…else-문"><a href="#2-1-if…else-문" class="headerlink" title="2.1 if…else 문"></a>2.1 if…else 문</h2><p>if…else 문은 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과, 즉 논리적 참, 거짓에 따라 실행할 코드 블록을 결정한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제변환되어 논리적 참, 거짓을 구별한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식) &#123;</span><br><span class="line">  <span class="comment">// 조건식이 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식이 거짓이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>조건식의 평가 결과가 참(true)일 경우, if문 다음의 코드 블록이 실행된다. 거짓(false)일 경우, else 문 다음의 코드 블록이 실행된다. </p>
<p>조건식을 추가하고 싶으면 else if 문을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식1이 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (조건식<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식2이 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else if 문과 else 문은 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. if문과 else 문은 2번 이상 사용할 수 없지만 else if문은 여러번 사용할 수도 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 2;</span><br><span class="line">var kind;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if 문</span><br><span class="line">if (num &gt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;양수&#39;; &#x2F;&#x2F; 음수를 구별할 수 없다</span><br><span class="line">&#125;</span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if…else 문</span><br><span class="line">if (num &gt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;양수&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  kind &#x3D; &#39;음수&#39;; &#x2F;&#x2F; 0은 음수가 아니다</span><br><span class="line">&#125;</span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if…else if 문</span><br><span class="line">if (num &gt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;양수&#39;;</span><br><span class="line">&#125; else if (num &lt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;음수&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  kind &#x3D; &#39;영&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br></pre></td></tr></table></figure>

<p>만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>)      kind = <span class="string">&#x27;양수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) kind = <span class="string">&#x27;음수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>              kind = <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure>

<p>대부분의 if…else 문은 연산자에서 살펴본 삼항 조건 연산자로 바꿔쓸 수 있다. 아래 예제를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x가 짝수이면 ‘짝수&#x27;를 홀수이면 ‘홀수&#x27;를 반환한다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span>) &#123; <span class="comment">// 2 % 2는 0이고 0은 false로 취급된다.</span></span><br><span class="line">  result = <span class="string">&#x27;홀수&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>위 예제는 아래와 같이 삼항 조건 연산자로 바꿔쓸 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x가 짝수이면 &#x27;짝수&#x27;를 홀수이면 &#x27;홀수&#x27;를 반환한다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>위 예제는 두가지 경우의 수 (‘홀수’ 또는 ‘짝수’)를 갖는 경우이다. 만약 세가지 경우의 수는 아래와 같이 바꿔쓸 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다.</span></span><br><span class="line"><span class="keyword">var</span> kind = num ? (num &gt; <span class="number">0</span> ? <span class="string">&#x27;양수&#x27;</span> : <span class="string">&#x27;음수&#x27;</span>) : <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure>

<p>num &gt; 0? ‘양수’ : ‘음수’ 는 표현식이므로 다른 표현식의 일부가 될 수 있다.</p>
<h2 id="2-2-switch-문"><a href="#2-2-switch-문" class="headerlink" title="2.2 switch 문"></a>2.2 switch 문</h2><p>switch 문은 switch 문의 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동시킨다. </p>
<p>case 문은 상황(case)을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다. </p>
<p>switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (표현식) &#123;</span><br><span class="line">  case 표현식1:</span><br><span class="line">    switch 문의 표현식과 표현식1이 일치하면 실행될 문;</span><br><span class="line">    break;</span><br><span class="line">  case 표현식2:</span><br><span class="line">    switch 문의 표현식과 표현식2가 일치하면 실행될 문;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if…else 문의 조건식은 반드시 불리언 값으로 평가되지만 switch 문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다. if…else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. </p>
<p>아래 예제를 살펴보자. switch 문의 표현식, 즉 변수 month의 평가 결과인 숫자 값 11과 일치하는 case 문으로 실행 순서가 이동한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 월을 영어로 변환한다. (11 → &#x27;November&#x27;)</span></span><br><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;January&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;February&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;March&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;April&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;May&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;June&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;July&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;August&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;September&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;October&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;November&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;December&#x27;</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;Invalid month&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(monthName); <span class="comment">// Invalid month</span></span><br></pre></td></tr></table></figure>

<p>그런데 위 예제를 실행해 보면 ‘November’가 출력되지 않고 ‘Invalid month’가 출력된다. 이는 switch 문의 표현식의 평가 결과와 일치하는 case 문으로 실행 순서가 이동하여 문을 실행한 것은 맞지만, 문을 실행한 후 switch 문을 탈출하지 않고 switch 문이 끝날 때까지 모든 case 문과 default 문을 실행했기 때문이다. 이를 폴스루(fall through)라 한다. 다시 말해 변수 monthName에 ‘November’가 할당된 후 switch 문을 탈출하지 않고 연이어 ‘December’가 재할당되고 마지막으로 ‘Invalid month’가 재할당되었다.</p>
<p>결과가 이러한 이유는 case 문에 해당하는 문의 마지막에 break 문을 사용하지 않았기 때문이다. break 키워드로 구성된 break 문은 코드 블록에서 탈출하는 역할을 수행한다. break 문이 없다면 case 문의 표현식과 일치하지 않더라도 실행 순서는 다음 case 문으로 연이어 이동한다. 올바른 switch 문은 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 월을 영어로 변환한다. (11 → &#x27;November&#x27;)</span></span><br><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;January&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;February&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;March&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;April&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;May&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;June&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;July&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;August&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;September&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;October&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;November&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;December&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;Invalid month&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(monthName); <span class="comment">// November</span></span><br></pre></td></tr></table></figure>

<p>default 문에는 break 문을 생략하는 것이 일반적이다. default 문은 switch 문의 가장 마지막에 위치하므로 default 문의 실행이 종료하면 switch 문을 빠져나간다. 따라서 별도로 break 문이 필요없다.</p>
<p>case 문은 반드시 단독으로 사용되어야 하는 것은 아니다. 아래 예제와 같이 여러 개의 case 문을 중복해 사용할 수도 있다. 아래는 윤년인지 판별해서 2월의 일수를 계산하는 예제다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> year = <span class="number">2000</span>; <span class="comment">// 2000년은 윤년으로 2월이 29일이다.</span></span><br><span class="line"><span class="keyword">var</span> month = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> days = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    days = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    days = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// 윤년 계산 알고리즘</span></span><br><span class="line">    <span class="comment">// 1. 년도가 4로 나누어 떨어지는 해는 윤년(2000, 2004, 2008, 2012, 2016, 2020…)</span></span><br><span class="line">    <span class="comment">// 2. 그 중에서 년도가 100으로 나누어 떨어지는 해는 평년(2000, 2100, 2200...)</span></span><br><span class="line">    <span class="comment">// 3. 그 중에서 년도가 400으로 나누어 떨어지는 해는 윤년(2000, 2400, 2800...)</span></span><br><span class="line">    days = ((year % <span class="number">4</span> === <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !== <span class="number">0</span>) || (year % <span class="number">400</span> === <span class="number">0</span>)) ? <span class="number">29</span> : <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Invalid month&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(days); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>

<p>switch 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생하는 등 문법도 복잡하다. if…else 문으로 해결할 수 있다면 if…else 문을 사용하는 편이 좋다. 하지만 if…else 문보다 switch 문을 사용했을 때 가독성이 더 좋다면 switch 문을 사용하는 편이 좋다.</p>
<h1 id="3-반복문"><a href="#3-반복문" class="headerlink" title="3. 반복문"></a>3. 반복문</h1><p>반복문(Loop statement)은 주어진 조건식(conditional expression)의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. </p>
<p>자바스크립트는 3가지 반복문 for문, while문, do…while문을 제공한다. 그 외에도 for…in문, ES6에서 새롭게 도입된 for…of문이 있다. for…in 문과 for…of문에 대해서는 나중에 살펴보기로 하자.</p>
<h2 id="3-1-for-문"><a href="#3-1-for-문" class="headerlink" title="3.1 for 문"></a>3.1 for 문</h2><p>for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 반복문이다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (초기화식; 조건식; 증감식) &#123;</span><br><span class="line">  조건식이 참인 경우 반복 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 문은 매우 중요하다. 아직 for문에 익숙하지 않다면 많은 연습을 통해 확실히 이해하기를 권장한다. </p>
<p>아래의 예제를 통해 for문이 어떻게 동작하는지 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제의 for 문은 변수 i가 0으로 초기화된 상태에서 시작하여 i가 2보다 작을 때까지 코드 블록을 2번 반복 실행한다. for 문의 실행 순서를 따라가며 어떻게 동작하는지 살펴보자.</p>
<p>for 문을 실행하면 가장 먼저 초기화식 var i = 0이 실행된다. 초기화식은 단 한번만 실행된다.</p>
<p>초기화식의 실행이 종료되면 조건식으로 실행 순서가 이동한다. 현재 변수 i는 0이므로 조건식의 평가 결과는 true다.</p>
<p>조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 증감문으로 실행 순서가 이동하는 것이 아니라 코드 블록으로 실행 순서가 이동하는 것에 주의하자.</p>
<p>코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 1이 된다.</p>
<p>증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 초기화식으로 실행 순서가 이동하는 것이 아니라 조건식으로 실행 순서가 이동하는 것에 주의하자. 초기화식은 단 한번만 실행된다. 현재 변수 i는 1이므로 조건식의 평가 결과는 true다.</p>
<p>조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다.</p>
<p>코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 2가 된다.</p>
<p>증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 현재 변수 i는 2이므로 조건식의 평가 결과는 false다. 조건식의 평가 결과가 false이므로 for 문의 실행이 종료된다.</p>
<p>아래 예제는 위 예제를 역으로 반복하는 for 문이다. 변수 i가 1으로 초기화된 상태에서 시작하여 i가 0보다 같거나 커질 때까지 코드 블록을 2번 반복 실행한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 문의 초기화식, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 어떤 식도 선언하지 않으면 무한 루프가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; &#125; <span class="comment">// 무한루프</span></span><br></pre></td></tr></table></figure>

<p>for 문 내에 for 문을 중첩해 사용할 수 있다. 아래는 두 개의 주사위를 던졌을 때, 두 눈의 합이 6이 되는 모든 경우의 수를 출력하는 예제다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + j === <span class="number">6</span>) <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;i&#125;</span>, <span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>출력 결과는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 5]</span><br><span class="line">[2, 4]</span><br><span class="line">[3, 3]</span><br><span class="line">[4, 2]</span><br><span class="line">[5, 1]</span><br></pre></td></tr></table></figure>

<h2 id="3-2-while-문"><a href="#3-2-while-문" class="headerlink" title="3.2 while 문"></a>3.2 while 문</h2><p>while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>

<p>조건식의 평가 결과가 언제나 참이면 무한루프가 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>무한루프를 탈출하기 위해서는 코드 블럭 탈출 조건을 if 문에 부여하고 break 문으로 코드 블럭을 탈출한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// count가 3이면 코드 블록을 탈출한다.</span></span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-do…while-문"><a href="#3-3-do…while-문" class="headerlink" title="3.3 do…while 문"></a>3.3 do…while 문</h2><p>do…while 문은 코드 블록을 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; <span class="keyword">while</span> (count &lt; <span class="number">3</span>); <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>

<h1 id="4-break-문"><a href="#4-break-문" class="headerlink" title="4. break 문"></a>4. break 문</h1><p>switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다. 좀 더 정확히 표현하자면 코드 블록을 탈출하는 것이 아니라 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용하면 SyntaxError(문법 에러)가 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>레이블 문(Label statement)이란 식별자가 붙은 문을 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo라는 레이블 식별자가 붙은 레이블 문</span></span><br><span class="line">foo: <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>레이블 문은 프로그램의 실행 순서를 제어하기 위해 사용한다. 사실 switch 문의 case 문과 default 문도 레이블 문이다. 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo라는 식별자가 붙은 레이블 블록문</span></span><br><span class="line">foo: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo; <span class="comment">// foo 레이블 블록문을 탈출한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Done!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>중첩된 for 문의 내부 for 문에서 break 문을 실행하면 내부 for 문을 탈출하여 외부 for 문으로 진입한다. 이때 내부 for 문이 아닌 외부 for 문을 탈출하려면 레이블 문을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// outer라는 식별자가 붙은 레이블 for 문</span></span><br><span class="line">outer: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="comment">// i + j === 3이면 외부 for 문을 탈출한다.</span></span><br><span class="line">    <span class="keyword">if</span> (i + j === <span class="number">3</span>) <span class="keyword">break</span> outer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Done!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>중첩된 for 문을 외부로 탈출할 때 레이블 문은 유용하지만 그 외의 경우 레이블 문은 일반적으로 권장하지 않는다. 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다.</p>
<p>break 문은 레이블 문 뿐만이 아니라 반복문, switch 문에서도 사용할 수 있다. 이 경우에는 break 문에 레이블 식별자를 지정하지 않는다. break 문은 반복문을 더 이상 진행하지 않아도 될 때 불필요한 반복을 회피할 수 있어 유용하다.</p>
<p>아래는 문자열에서 특정 문자의 인덱스(위치)를 검색하는 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 문자열의 개별 문자가 &#x27;l&#x27;이면</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] === <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 반복문을 탈출한다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(index); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 참고로 String.prototype.indexOf 메소드를 사용해도 같은 동작을 한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(string.indexOf(<span class="string">&#x27;l&#x27;</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="5-continue-문"><a href="#5-continue-문" class="headerlink" title="5. continue 문"></a>5. continue 문</h1><p>continue 문은 반복문(for, for…in, for…of, while, do…while)의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다.</p>
<p>아래는 문자열에서 특정 문자의 개수를 카운트하는 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] !== <span class="string">&#x27;l&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">  count++; <span class="comment">// continue 문이 실행되면 이 문은 실행되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 참고로 String.prototype.match 메소드를 사용해도 같은 동작을 한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(string.match(<span class="regexp">/l/g</span>).length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 for 문은 아래와 동일하게 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이면 카운트를 증가시킨다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] === <span class="string">&#x27;l&#x27;</span>) count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 if 문 내에서 실행해야 할 코드가 한 줄이라면 continue 문을 사용했을 때보다 간편하며 가독성도 좋다. 하지만 if 문 내에서 실행해야 할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// continue 문을 사용하지 않으면 if 문 내에 코드를 작성해야 한다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이면 카운트를 증가시킨다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] === <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// continue 문을 사용면 if 문 밖에 코드를 작성할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이 아니면 카운트를 증가시키지 않는다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] !== <span class="string">&#x27;l&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-control-flow">poiemaweb.com/js-control-flow</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-14T05:29:29.032Z" title="2021-6-14 14:29:29">2021-06-14</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-21T08:16:40.784Z" title="2021-6-21 17:16:40">2021-06-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">36분안에 읽기 (약 5365 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/14/js-day4-operator/">js-day4-operator</a></h1><div class="content"><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><h1 id="1-표현식과-연산자"><a href="#1-표현식과-연산자" class="headerlink" title="1.표현식과 연산자"></a>1.표현식과 연산자</h1><p>값은 다양한 방법으로 생성할 수 있다. 여기서 말하는 다양한 방법이란 표현식을 말한다. 프로그래밍 언어에서 표현식은 중요한 역할을 한다. 다시 한번 표현식에 대해 살펴보자. </p>
<p>표현식(expression)은 리터럴, 식별자, 연산자, 함수 호출 등의 조합을 말한다. 표현식은 평가(evaluation. 표현식을 실행하여 하나의 값을 만드는 과정)되어 하나의 값을 만든다. 즉, 표현식은 하나의 값으로 평가될 수 있는 문(statement, 문과 표현식 참고)이다. </p>
<p>표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등으로 나누어 볼 수 있지만 결국 평가되어 하나의 값을 만든다는 점에서 모두 동일하다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 리터럴 표현식</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 식별자 표현식</span></span><br><span class="line">sum</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 표현식</span></span><br><span class="line"><span class="number">10</span> + <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수/메소드 호출 표현식</span></span><br><span class="line">square()</span><br></pre></td></tr></table></figure>

<p>표현식은 평가되어 결국 하나의 값이 되므로 표현식과 같은 동등한 관계, 즉 동치(Equivalent)다. 다시 말해, 표현식은 값처럼 사용할 수 있다. 이것은 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 의미다. 예를 들어 산술 연산자 +의 좌항과 우항에는 숫자 값이 위치해야 한다. 숫자 값으로 평가될 수 있는 표현식이라면 숫자 값 대신 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 표현식</span></span><br><span class="line">x + <span class="number">30</span>;  <span class="comment">// 식별자 표현식과 숫자 리터럴과 연산자의 조합</span></span><br></pre></td></tr></table></figure>

<p>이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다. 연산자 표현식은 표현식을 결합해 새로운 값을 만들어 내는 가장 일반적인 표현식이다.</p>
<h1 id="2-문과-표현식"><a href="#2-문과-표현식" class="headerlink" title="2.문과 표현식"></a>2.문과 표현식</h1><p>문(statement)은 자바스크립트 엔진에서 내리는 명령이다. 문이 실행되면 무슨 일인가가 일어나게 된다. 변수 선언문을 실행하면 변수가 신언이 되고, 할당문을 실행하면 할당이 된다. 조건문을 실행하면 주어진 조건에 따라 코드 블록({…})의 실행이 결정되고, 반복문을 실행하면 코드 블록이 반복 실행된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문</span></span><br><span class="line">x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 조건문</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">5</span>) &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복문</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>문은 리터럴, 연산자, 표현식, 키워드 등으로 구성되며 세미콜론(;)으로 끝나야 한다. (코드 블록{…}은 제외)</p>
<p>문의 끝에 붙이는 세미콜론은 옵션으로 쓰지 않아도 상관없다. 자바스크립트 엔진이 스크립트를 해석할 때, 자바스크립트 엔진에는 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 있기 때문이다. 하지만 세미콜론 자동 삽입 기능의 예측과 개발자의 예측과 다른 경우가 간혹 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>세미콜론을 반드시 붙여야 한다는 주장이 대다수를 차지하지만 붙이지 말아야한다는 주장도 설득력이 있다. 하지만 <a target="_blank" rel="noopener" href="https://eslint.org/">ESLint</a>와 같은 정적 분석 도구에서도 세미콜론 사용을 기본으로 설정하고 있고 TC39(ECMAScript 기술 위원회)도 세미콜론 사용을 권장하는 분위기이므로 세미콜론을 붙이도록 하겠다. </p>
<p>자바스크립트의 모든 코드는 문 또는 표현식이다. 자연어에서 문이 마침표로 끝나는 하나의 완전한 문장(Sentence)이라고 한다면 표현식은 문을 구성하는 요소이다. 표현식은 그 자체로 하나의 문이 될 수도 있다. </p>
<p>표현식과 문은 유사하여 구별이 어려울 수 있다. 표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. 문은 var, let, const, function, class와 같은 선언 키워드를 사용하여 변수나 함수를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다. </p>
<p>표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 컴퓨터에게 명령을 내리는 것이다. 문에는 표현식인 문과 표현식이 아닌 문이 있다. 예를 들어 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 그 자체가 표현식인 문이다. 아래의 예제를 살펴보자 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선언문(Declaration statement)</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> * <span class="number">10</span>; <span class="comment">// 표현식 x = 5 * 10를 포함하는 문이다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문(Assignment statement)</span></span><br><span class="line">x = <span class="number">100</span>; <span class="comment">// 이 자체가 표현식이지만 완전한 문이기도 하다.</span></span><br></pre></td></tr></table></figure>

<p>이에 반해 할당문은 그 자체가 표현식이다. 다시 말해 할당문은 표현식인 문이다. </p>
<blockquote>
<p>크롬 DevTools에서 표현식이 아닌 문은 언제나 Undefined를 반환하고, 표현식인 문은 언제나 값을 반환한다. </p>
</blockquote>
<p>할당문은 표현식인 문이기 때문에 값처럼 사용할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>할당문을 값처럼 변수에 할당했다. 할당문은 할당한 값으로 평가된다. 즉, x=100은 변수 x에 할당한 값 100으로 평가 될 수 있다. 따라서 변수 foo에는 100이 할당된다.</p>
<h1 id="3-연산자란"><a href="#3-연산자란" class="headerlink" title="3.연산자란?"></a>3.연산자란?</h1><p>연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다. 피연산자도 평가되어 하나의 값이 되므로 표현식이고 피연산자를 연산자와 결합한 연산자 표현식도 물론 표현식이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="number">5</span> * <span class="number">4</span> <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">&#x27;My name is &#x27;</span> + <span class="string">&#x27;Lee&#x27;</span> <span class="comment">// &quot;My name is Lee&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당 연산자</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// &quot;red&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 비교 연산자</span></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">5</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리 연산자</span></span><br><span class="line">(<span class="number">5</span> &gt; <span class="number">3</span>) &amp;&amp; (<span class="number">2</span> &lt; <span class="number">4</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 연산자</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;Hi&#x27;</span> <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<p>피연산자가 “값”이라는 명사의 역할을 한다면 연산자는 “값을 만든다”라는 동사의 역할을 한다고 볼 수 있다. 다시 말해, 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 값으로 평가된 피연산자를 연산해 새로운 값을 만든다. </p>
<p>자바스크립트가 제공하는 다양한 연산자에 대해 살펴보도록 하자. </p>
<h1 id="4-산술-연산자"><a href="#4-산술-연산자" class="headerlink" title="4.산술 연산자"></a>4.산술 연산자</h1><p>산술 연산자(Arithmetic Operator)는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산을 할 수 없는 경우에는 NaN을 반환한다. 산술연산자는 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다. </p>
<h2 id="4-1-이항-산술-연산자"><a href="#4-1-이항-산술-연산자" class="headerlink" title="4.1 이항 산술 연산자"></a>4.1 이항 산술 연산자</h2><p>이항 산술 연산자는 2개의 피연산자를 대상으로 연산하여 숫자 타입의 값을 만든다. </p>
<p>모든 이항 산술 연산자의 값을 변경하는 부수 효과(Side effect)가 없다. 다시 말해, 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 단기 새로운 값을 만들 뿐이다. </p>
<table>
<thead>
<tr>
<th>이항 산술 연산자</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>덧셈</td>
</tr>
<tr>
<td>-</td>
<td>뺄셈</td>
</tr>
<tr>
<td>*</td>
<td>곱셈</td>
</tr>
<tr>
<td>/</td>
<td>나눗셈</td>
</tr>
<tr>
<td>%</td>
<td>나머지</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> + <span class="number">2</span>  <span class="comment">// 7</span></span><br><span class="line"><span class="number">5</span> - <span class="number">2</span>  <span class="comment">// 3</span></span><br><span class="line"><span class="number">5</span> * <span class="number">2</span>  <span class="comment">// 10</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>  <span class="comment">// 2.5</span></span><br><span class="line"><span class="number">5</span> % <span class="number">2</span>  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="4-2-단항-산술-연산자"><a href="#4-2-단항-산술-연산자" class="headerlink" title="4.2.단항 산술 연산자"></a>4.2.단항 산술 연산자</h1><p>단항 산술 연산자는 1개의 피연산자를 대상으로 연산한다. </p>
<p>증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수효과가 있다. 다시 말해, 증가/감소 연산을 하면 피연산자의 값이 바뀐다. </p>
<table>
<thead>
<tr>
<th>단항 산술 연산자</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>증가</td>
</tr>
<tr>
<td>–</td>
<td>감소</td>
</tr>
<tr>
<td>+</td>
<td>어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.</td>
</tr>
<tr>
<td>-</td>
<td>양수를 음수로 음수를 양수로 반전한 값을 반환한다.</td>
</tr>
</tbody></table>
<p>증가/감소(++/–) 연산자는 위치에 의미가 있다. 피연산자 앞에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다. 피연산자 뒤에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소 시킨다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>, result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 선대입 후증가 (Postfix increment operator)</span></span><br><span class="line">result = x++;</span><br><span class="line"><span class="built_in">console</span>.log(result, x); <span class="comment">// 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선증가 후대입 (Prefix increment operator)</span></span><br><span class="line">result = ++x;</span><br><span class="line"><span class="built_in">console</span>.log(result, x); <span class="comment">// 7 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선대입 후감소 (Postfix decrement operator)</span></span><br><span class="line">result = x--;</span><br><span class="line"><span class="built_in">console</span>.log(result, x); <span class="comment">// 7 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선감소 후대입 (Prefix decrement operator)</span></span><br><span class="line">result = --x;</span><br><span class="line"><span class="built_in">console</span>.log(result, x); <span class="comment">// 5 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>단항 연산자는 피연산자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. 그런데 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">10</span> <span class="comment">// 10</span></span><br><span class="line">+<span class="string">&#x27;10&#x27;</span> <span class="comment">// 10</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">+<span class="literal">false</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>단항 연산자는 피연산자의 부호를 반전한 값을 반환한다. _ 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">10</span> <span class="comment">// -10</span></span><br><span class="line">-<span class="string">&#x27;10&#x27;</span> <span class="comment">// -10</span></span><br><span class="line">-<span class="literal">true</span> <span class="comment">// -1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// -0</span></span><br></pre></td></tr></table></figure>

<h1 id="4-3-문자열-연결-연산자"><a href="#4-3-문자열-연결-연산자" class="headerlink" title="4.3.문자열 연결 연산자"></a>4.3.문자열 연결 연산자</h1><ul>
<li>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다. 아래 예제를 살펴보자. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="string">&#x27;2&#x27;</span>      <span class="comment">// &#x27;12&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">2</span>       <span class="comment">// &#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>          <span class="comment">// 3</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>       <span class="comment">// 2 (true → 1)</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">false</span>      <span class="comment">// 1 (false → 0)</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">false</span>    <span class="comment">// 1 (true → 1 / false → 0)</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>       <span class="comment">// 1 (null → 0)</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span> <span class="comment">// NaN (undefined → NaN)</span></span><br></pre></td></tr></table></figure>

<p>이 예제에서 주목할 것은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 다입이 자동 변환되기도 한다는 것이다. 위 예제에서 1+true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 앞서 살펴본 +/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다. 이에 대해서는 타입 변환에서 자세히 살펴볼 것이다.</p>
<h1 id="5-할당-연산자"><a href="#5-할당-연산자" class="headerlink" title="5.할당 연산자"></a>5.할당 연산자</h1><p>할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 부수효과가 있다.</p>
<table>
<thead>
<tr>
<th>할당 연산자</th>
<th>사례</th>
<th>동일 표현</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>x = y</td>
<td>x = y</td>
</tr>
<tr>
<td>+=</td>
<td>x += y</td>
<td>x = x + y</td>
</tr>
<tr>
<td>-=</td>
<td>x -= y</td>
<td>x = x - y</td>
</tr>
<tr>
<td>*=</td>
<td>x *= y</td>
<td>x = x * y</td>
</tr>
<tr>
<td>/=</td>
<td>x /= y</td>
<td>x = x / y</td>
</tr>
<tr>
<td>%=</td>
<td>x %= y</td>
<td>x = x % y</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;   <span class="comment">// 10</span></span><br><span class="line">x += <span class="number">5</span>;   <span class="comment">// 15</span></span><br><span class="line">x -= <span class="number">5</span>;   <span class="comment">// 10</span></span><br><span class="line">x *= <span class="number">5</span>;   <span class="comment">// 50</span></span><br><span class="line">x /= <span class="number">5</span>;   <span class="comment">// 10</span></span><br><span class="line">x %= <span class="number">5</span>;   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;My name is &#x27;</span>;</span><br><span class="line">str += <span class="string">&#x27;Lee&#x27;</span>; <span class="comment">// My name is Lee</span></span><br></pre></td></tr></table></figure>

<p>표현식은 “하나의 값으로 평가된다”고 하였다. 그렇다면 할당 연산은 표현식일까? 아래의 예제를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x = <span class="number">10</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>할당 연산은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만 할당 연산은 하나의 값으로 평가되는 표현식이다. 할당 표현식은 할당된 값으로 평가된다. 위 예제의 경우 x에 할당된 숫자 값 10으로 평가된다. 따라서 아래와 같이 할당 연산 표현식을 다른 변수에 할당할 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line">y = x = <span class="number">10</span>; <span class="comment">// 연쇄 할당(Chained assignment)</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// 10 10</span></span><br></pre></td></tr></table></figure>

<h1 id="6-비교-연산자"><a href="#6-비교-연산자" class="headerlink" title="6.비교 연산자"></a>6.비교 연산자</h1><p>비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교하여 불리언 값을 반환한다. if문이나 for문과 같은 제어문의 조건식에서 주로 사용한다. </p>
<h2 id="6-1-동등-일치-비교-연산자"><a href="#6-1-동등-일치-비교-연산자" class="headerlink" title="6.1 동등 / 일치 비교 연산자"></a>6.1 동등 / 일치 비교 연산자</h2><table>
<thead>
<tr>
<th>비교 연산자</th>
<th>의미</th>
<th>사례</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>동등 비교</td>
<td>x==y</td>
<td>x와 y의 값이 같음</td>
</tr>
<tr>
<td>===</td>
<td>일치 비교</td>
<td>x===y</td>
<td>x와 y의 값과 타입이 같음</td>
</tr>
<tr>
<td>!=</td>
<td>부등 비교</td>
<td>x!=y</td>
<td>x와 y의 값이 다름</td>
</tr>
<tr>
<td>!==</td>
<td>불일치 비교</td>
<td>x!==y</td>
<td>x와 y의 값과 타입이 다름</td>
</tr>
</tbody></table>
<p>문자열 연결 연산자에서 언급했듯이 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되지도 한다. 이를 암묵적 타입 변환이라 부른다. </p>
<p>동등 비교(==) 연산자는 좌항과 우항의 피연사자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값을 갖는지 비교한다. 따라서 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값을 수 있으면 true를 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 동등 비교</span></span><br><span class="line"><span class="number">5</span> == <span class="number">5</span>    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 같은 값을 같는다.</span></span><br><span class="line"><span class="number">5</span> == <span class="string">&#x27;5&#x27;</span>   <span class="comment">//true</span></span><br><span class="line"><span class="number">5</span> == <span class="number">8</span>    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>결론부터 말하자면 동등 비교 연산자는 편리한 경우도 있지만 수많은 부작용을 일으키므로 사용하지 않는 편이 좋다. 아래 예제를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="string">&#x27;0&#x27;</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>             <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span>            <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span>    <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span>        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>위 예제와 같은 코드를 작성할 개발자는 드물겠지만 이처럼 동등 비교(==)연산자는 예측하기 어려운 겨로가를 만들어낸다. 위 예제는 이해하려 하지 않아도 된다. 다만 동등 비교 연산자를 사용하지 말고 일치 비교 연산자를 사용하면 된다. </p>
<p>일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일치 비교</span></span><br><span class="line"><span class="number">5</span> === <span class="number">5</span>   <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> === <span class="string">&#x27;5&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>일치 비교 연산자는 예측하기 쉽다. 위에 살펴본 동등 비교 연산자의 해괴망측한 예제는 모두 false를 반환한다. 일치 비교 연산자에서 주의할 것은 NaN이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>숫자 0도 주의하도록 하자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>===<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 부동등 비교</span></span><br><span class="line"><span class="number">5</span> != <span class="number">8</span>    <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> != <span class="number">5</span>    <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> != <span class="string">&#x27;5&#x27;</span>  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불일치 비교</span></span><br><span class="line"><span class="number">5</span> !== <span class="number">8</span>   <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> !== <span class="number">5</span>   <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> !== <span class="string">&#x27;5&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="6-2-대소-관계-비교-연산자"><a href="#6-2-대소-관계-비교-연산자" class="headerlink" title="6.2 대소 관계 비교 연산자"></a>6.2 대소 관계 비교 연산자</h1><p>대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.<br>|대소 관계 비교 연산자|예제|설명|<br>|———————|—-|—-|<br>|&gt;|x &gt; y|x가 y보다 크다 X|<br>|&lt;|x &lt; y|x가 y보다 작다 X|<br>|&gt;=|x &gt;= y|x가 y보다 같거나 크다 X|<br>|&lt;=|x &lt;= y|x가 y보다 같거나 작다 X|</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 대소 관계 비교</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">0</span>    <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">5</span>    <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">8</span>    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> &lt; <span class="number">0</span>    <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> &lt; <span class="number">5</span>    <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> &lt; <span class="number">8</span>    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">0</span>   <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">5</span>   <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">8</span>   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> &lt;= <span class="number">0</span>   <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> &lt;= <span class="number">5</span>   <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> &lt;= <span class="number">8</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="7-삼항-조건-연산자"><a href="#7-삼항-조건-연산자" class="headerlink" title="7.삼항 조건 연산자"></a>7.삼항 조건 연산자</h1><p>삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 연산자이며 부수 효과는 없다. 삼항 조건 연산자 표현식은 아래와 같이 사용한다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값</span><br></pre></td></tr></table></figure>

<p>물음표(?) 앞의 첫번째 피연산자가 조건식, 즉 불리언 타입의 값으로 평가될 표현식이다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. 이때 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x가 짝수이면 &#x27;짝수&#x27;를 홀수이면 &#x27;홀수&#x27;를 반환한다.</span></span><br><span class="line"><span class="comment">// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>삼항 조건 연산자는 다음 장에서 살펴볼 if…else 문을 사용해도 동일한 처리를 할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>, result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x가 짝수이면 &#x27;짝수&#x27;를 홀수이면 &#x27;홀수&#x27;를 반환한다.</span></span><br><span class="line"><span class="comment">// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.</span></span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span>) result = <span class="string">&#x27;홀수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>       result = <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else문은 값으로 평가할 수 없다. 하지만 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식이다. 따라서 삼항 조건 연산자식은 다른 표현식의 일부가 될 수 있어 매우 유용하다. </p>
<h1 id="8-논리-연산자"><a href="#8-논리-연산자" class="headerlink" title="8.논리 연산자"></a>8.논리 연산자</h1><p>논리 연산자(Logical Operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다. </p>
<p>논리 부정(!) 연산자는 언제나 분리언 값을 반환한다. 하지만 논리합(||) 연산자와 논리곱 (&amp;&amp;) 연산자는 일반적으로 불리언 값을 반환하지만 반드시 불리언 값을 반환해야 하는 것은 아니다.</p>
<table>
<thead>
<tr>
<th>논리 연산자</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>&#124;&#124;</td>
<td>논리합(OR)</td>
</tr>
<tr>
<td>&#38;&#38;</td>
<td>논리곱(AND)</td>
</tr>
<tr>
<td>!</td>
<td>부정(NOT)</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">true</span>   <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">true</span>   <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리 부정(!) 연산자</span></span><br><span class="line">!<span class="literal">true</span>  <span class="comment">// false</span></span><br><span class="line">!<span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자는 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 암묵적 타입 변환</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>하지만 논리합 (||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 언제나 피연산자 중 어느 한쪽 값을 반환한다. 이에 대해서는 단축 평가에서 자세히 살펴보기로 하자</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 단축 평가</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span> <span class="comment">// “Dog”</span></span><br></pre></td></tr></table></figure>

<h1 id="9-쉼표-연산자"><a href="#9-쉼표-연산자" class="headerlink" title="9.쉼표 연산자"></a>9.쉼표 연산자</h1><p>쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y, z;</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h1 id="10-그룹-연산자"><a href="#10-그룹-연산자" class="headerlink" title="10. 그룹 연산자"></a>10. 그룹 연산자</h1><p>그룹((…)) 연산자는 그룹 내의 표현식을 최우선으로 평가한다. 그룹 연산자를 사용하면 연산자의 우선 순위를 1순위로 높일 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> * <span class="number">2</span> + <span class="number">3</span>   <span class="comment">// 23</span></span><br><span class="line"><span class="number">10</span> * (<span class="number">2</span> + <span class="number">3</span>) <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<h1 id="11-typeof-연산자"><a href="#11-typeof-연산자" class="headerlink" title="11. typeof 연산자"></a>11. typeof 연산자</h1><p>typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 일치하지는 않는다. typeof 연산자는 7가지 문자열 ‘string’, ‘number’, ‘boolean’, ‘undefined’, ‘symbol’, ‘object’, ‘function’중 하나를 반환한다. ‘null’을 반환하는 경우는 없으며 함수의 경우 ‘function’을 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span>              <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>               <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>             <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>            <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>       <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>            <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []              <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;              <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()      <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> /test/gi        <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>주의해야 할 것은 typeof 연산자로 null 값을 연산해 보면 null이 아닌 ‘object’를 반환한다는 것이다. 이것은 자바스크립트의 첫번째 버전에서 이렇게 설계된 것을 현재의 버전에 반영하지 못하고 있지 때문이다. (<a target="_blank" rel="noopener" href="https://2ality.com/2013/10/typeof-null.html">참고</a>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>  <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>따라서 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하도록한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo === <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">null</span>);        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>또 하나 주의해야 할 것이 있다. 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 ‘undefined’를 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared  <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p>typeof 연산자가 선언하지 않은 식별자를 연산했을 때 ‘undefined’를 반환하는 것을 카일 심슨의 ‘You don’t know JS’에서는 특별한 안전 가드(safety guard)로 설명한다. 하지만 모던 자바스크립트 개발에서는 대부분 모듈을 사용하고 전역변수인 플래그를 사용하지 않으므로 의도적으로 사용할 필요는 없다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-operator">poiemaweb.com/js-operator</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-07T07:20:28.147Z" title="2021-6-7 16:20:28">2021-06-07</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-11T03:29:34.636Z" title="2021-6-11 12:29:34">2021-06-11</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">44분안에 읽기 (약 6590 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/07/js-day3-datatype-variable/">js-day3-datatype-variable</a></h1><div class="content"><h3 id="Data-type-amp-Variable"><a href="#Data-type-amp-Variable" class="headerlink" title="Data type &amp; Variable"></a>Data type &amp; Variable</h3><h2 id="데이터-타입과-변수"><a href="#데이터-타입과-변수" class="headerlink" title="데이터 타입과 변수"></a>데이터 타입과 변수</h2><p>프로그래밍은 변수를 통해 값을 저장하고 참조하며 연산자로 값을 연산, 평가하고 조건문과 반복문에 의한 흐름제어로 데이터의 흐름을 제어하고 함수로 재사용이 가능한 구문의 집합을 만들며 객체, 배열 등으로 자료를 구조화하는 것이다. </p>
<p>변수는 값의 위치(주소)를 기억하는 저장소이다. 값의 위치란 값이 위치하고 있는 메모리 상의 주소(address)를 의미한다. 즉, 변수란 값이 위치하고 있는 메모리 주소(Memory address)에 접근하기 위해 사람이 이해할 수 있는 언어로 명명한 식별자(identifier)이다. </p>
<p>메모리에 값을 저장하기 위해서는 먼저 메모리 공간을 확보해야 할 메모리의 크기(byte)를 알아야한다. 이는 값의 종류에 따라 확보해야 할 메모리의 크기가 다르기 때문이다. 이때 값의 종류, 즉 데이터의 종류를 데이터 타입(Data Type)이라 한다. </p>
<p>예를 들어 1byte(8bit)로 표현할 수 있는 경우의 수, 즉 값의 총 개수는 256개(2^8)로 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/ASCII">아스키코드(ASCII)</a>를 표현할 수 있으며, 4byte(32bit)로 표현할 수 있는 값의 총수는 4,294,967,296개(2^32)로 -2,147,483,648 ~ 2,147,483,647의 정수를 표현할 수 있다. </p>
<p>C나 Java 같은 C-family 언어는 정적 타입(Static/Strong Type)언어로 변수 선언 시 변수에 저장할 값의 종류를 사전에 타입 지정(Type annotation)하여야 한다. 다음은 C에서 정수형 변수를 선언하는 예이다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1byte 정수형: -128 ~ 127</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4byte 정수형: -2,124,483,648 ~ 2,124,483,647</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br></pre></td></tr></table></figure>

<p>C 언어의 경우, 4byte 정수형인 int형 선언을 만나면 시스템은 이후 할당될 값과는 상관없이 4byte의 메모리 영역을 확보한다. 이후 int형 변수에 할당할 때에는 int형 값을 할당해야한다. 다음은 C에서 정수형 변수에 문자열을 잘못 할당한 예이다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">46</span>;</span><br><span class="line">  <span class="keyword">char</span> * str = <span class="string">&quot;String&quot;</span>;</span><br><span class="line"></span><br><span class="line">  num = <span class="string">&quot;String&quot;</span>; <span class="comment">// warning: incompatible pointer to integer conversion assigning to &#x27;int&#x27; from &#x27;char [7]&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자바스크립트는 동적타입(Dynamic/Weak Type)언어이다. 변수의 타입 지정(Type annotation)없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정(타입추론, Type Inference)된다. 즉, 변수는 고정된 타입이 없다. 따라서 같은 변수에 여러 타입의 값을 자유롭게 할당할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str  = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> num  = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">// string</span></span><br><span class="line">foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트에는 어떠한 데이터 타입이 있는지 그리고 변수는 어떻게 사용하는지 알아보도록 하자.</p>
<h1 id="1-데이터-타입"><a href="#1-데이터-타입" class="headerlink" title="1. 데이터 타입"></a>1. 데이터 타입</h1><p>데이터 타입(Data Type)은 프로그래밍 언어에서 사용할 수 있는 데이터(숫자, 문자열, 불리언 등)의 종류를 말한다.</p>
<p>코드에서 사용되는 모든 데이터는 메모리에 저장하고 참조할 수 있어야 한다. 데이터 타입은 데이터를 메모리에 저장할 떄 확보해야 하는 메모리 공간의 크기와 할당할 수 있는 유효한 값에 대한 저옵, 그리고 메모리에 저장되어 있는 2진수 데이터를 어떻게 해석할지에 대한 정보를 컴퓨터와 개발자에게 제공한다. </p>
<p>데이터 다입은 한정된 메모리 공간을 효율적으로 사용하기 위해서, 그리고 2진수 데이터로 메모리에 저장된 데이터를 다양한 형태로 사용하기 위해 존재한다. </p>
<p>자바스크립트의 모든 값은 데이터 타입을 갖는다. ECMAScript 표준(ECMAScript 2015(6th Edition), 이하 ES6)은 7개의 데이터 타입을 제공한다. </p>
<ul>
<li><p>원시 타입(primitive data type)</p>
<blockquote>
<ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>number</li>
<li>string</li>
<li>symbol (ES6에서 추가)</li>
</ul>
</blockquote>
</li>
<li><p>객체 타입(object)</p>
</li>
</ul>
<p>예를 들어 숫자(number)타입 1과 문자열(string) 타입 ‘1’은 비슷하게 보이지만 다른 타입의 값이다. 숫자 타입의 값은 주로 산술 연산을 위해 만들지만 문자열 타입의 값은 주로 텍스트로 출력하기 위해 만든다. 이처럼 개발자는 명확한 의도를 가지고 타입을 구별하여 값을 만들 것이고 자바스크립트 엔진은 타입을 구별하여 값을 취급할 것이다. </p>
<p>자바스크립트에서 제공하는 7개의 데이터 타입은 크게 원시 타입(primitive data type)과 객체 타입(object/reference type)으로 구분할 수 있다. </p>
<h2 id="1-1-원시타입-Primitive-Data-Type"><a href="#1-1-원시타입-Primitive-Data-Type" class="headerlink" title="1.1 원시타입 (Primitive Data Type)"></a>1.1 원시타입 (Primitive Data Type)</h2><p>원시 타입의 값은 변경 불가능한 값(immutable value)이며 pass-by-value(값에 의한 전달)이다. </p>
<h3 id="1-1-1-number"><a href="#1-1-1-number" class="headerlink" title="1.1.1 number"></a>1.1.1 number</h3><p>C나 Java의 경우, 정수와 실수를 구분하여 int, long, float, double 등과 같은 다양한 숫자 타입이 존재한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다. </p>
<p>ECMAScript 표준에 따르면, 숫자 타입의 값은 배정밀도 64비트 부동소수점 형(double-precision 64-bit floating-point format : -(2^53-1)와 2^53-1 사이의 숫자값)을 따른다. 즉, 모든 수를 실수를 처리하며 정수만을 표현하기 위한 특별한 데이터 타입(integer type)은 없다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> integer = <span class="number">10</span>;        <span class="comment">// 정수</span></span><br><span class="line"><span class="keyword">var</span> double = <span class="number">10.12</span>;      <span class="comment">// 실수</span></span><br><span class="line"><span class="keyword">var</span> negative = -<span class="number">20</span>;      <span class="comment">// 음의 정수</span></span><br><span class="line"><span class="keyword">var</span> binary = <span class="number">0b01000001</span>; <span class="comment">// 2진수</span></span><br><span class="line"><span class="keyword">var</span> octal = <span class="number">0o101</span>;       <span class="comment">// 8진수</span></span><br><span class="line"><span class="keyword">var</span> hex = <span class="number">0x41</span>;          <span class="comment">// 16진수</span></span><br></pre></td></tr></table></figure>

<p>2진수, 8진수, 16진수 리터럴은 메모리에 동일한 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(binary); <span class="comment">// 65</span></span><br><span class="line"><span class="built_in">console</span>.log(octal);  <span class="comment">// 65</span></span><br><span class="line"><span class="built_in">console</span>.log(hex);    <span class="comment">// 65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표기법만 다를뿐 같은 값이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(binary === octal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(octal === hex);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수를 처리한다. 정수로 표시된다해도 사실은 실수다. 따라서 정수로 표시되는 수 끼리 나누더라도 실수가 나올 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="number">1.0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">4</span> / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 2</span></span><br><span class="line">result = <span class="number">3</span> /<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure>

<p>추가적으로 3가지 특별한 값들도 표현할 수 있다. </p>
<ul>
<li>Infinity: 양의 무한대</li>
<li>-Infinity: 음의 무한대</li>
<li>NaN: 산술 연산 불가(not-a-number)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pInf = <span class="number">10</span> / <span class="number">0</span>;  <span class="comment">// 양의 무한대</span></span><br><span class="line"><span class="built_in">console</span>.log(pInf);  <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nInf = <span class="number">10</span> / -<span class="number">0</span>; <span class="comment">// 음의 무한대</span></span><br><span class="line"><span class="built_in">console</span>.log(nInf);  <span class="comment">// -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nan = <span class="number">1</span> * <span class="string">&#x27;string&#x27;</span>; <span class="comment">// 산술 연산 불가</span></span><br><span class="line"><span class="built_in">console</span>.log(nan);       <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>수학적 의미의 실수(real number)는 허수(imaginary number)가 아닌 유리수와 무리수를 통틀은 말이지만 프로그래밍 언어에서 실수는 일반적으로 소수를 가리킨다. </p>
<h3 id="1-1-2-string"><a href="#1-1-2-string" class="headerlink" title="1.1.2 string"></a>1.1.2 string</h3><p>문자열(String) 타입은 텍스트 데이터를 나타내는데 사용한다. 문자열은 0개 이상의 유니코드 문자(UTF-16)들의 집합으로 대부분의 전세계의 문자를 표현 할 수 있다. 문자열은 작은 따옴표(‘’) 또는 큰 따옴표(“”)안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;string&quot;</span>; <span class="comment">// 큰 따옴표</span></span><br><span class="line">str = <span class="string">&#x27;string&#x27;</span>;     <span class="comment">// 작은 따옴표</span></span><br><span class="line">str = <span class="string">`string`</span>;     <span class="comment">// 백틱(ES6 템플릿 리터럴)</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;큰 따옴표로 감싼 문자열 내의 &#x27;작은 따옴표&#x27;는 문자열이다.&quot;</span>;</span><br><span class="line">str = <span class="string">&#x27;작은 따옴표로 감싼 문자열 내의 &quot;큰 따옴표&quot;는 문자열이다.&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>C와 같은 언어와는 다르게, 자바스크립트의 문자열은 원시 타입이며 변경 불가능(immutable)하다. 이것은 한 번 문자열이 생성되면, 그 문자열을 변경할 수 없다는 것을 의미한다. 아래의 코드를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>첫번째 구문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 메모리에 생성된 문자열’Hello’의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 변수 str은 문자열 ‘world’를 가리키도록 변경되었을 뿐이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="comment">// 문자열은 유사배열이다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 변경할 수 없다.</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>문자열은 배열처럼 인덱스를 통해 접근할 수 있다. 이와 같은 특성을 갖는 데이터를 유사배열이라 한다. </p>
<p>str[0] = ‘S’처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다(이때 에러가 발생하지 않는다). 한번 생성된 문자열은 read only로서 변경할 수 없다. 이것을 변경 불가능(immutable)이라 한다. </p>
<p>그러나 새로운 문자열을 재할당하는 것은 물론 가능하다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&#x27;String&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// String</span></span><br><span class="line"></span><br><span class="line">str += <span class="string">&#x27; test&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// String test</span></span><br><span class="line"></span><br><span class="line">str = str.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// Str</span></span><br><span class="line"></span><br><span class="line">str = str.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// STR</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-boolean"><a href="#1-1-3-boolean" class="headerlink" title="1.1.3 boolean"></a>1.1.3 boolean</h3><p>불리언(boolean)타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof 연산자는 타입을 나타내는 문자열을 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar); <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<p>불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용한다. 비어있는 문자열과 null, undefined, 숫자 0은 false로 간주된다. 이에 대해서는 타입 변환에서 살펴볼 것이다. </p>
<h3 id="1-1-4-undefined"><a href="#1-1-4-undefined" class="headerlink" title="1.1.4 undefined"></a>1.1.4 undefined</h3><p>undefined 타입의 값은 undefined가 유일하다. 선언 이후 값을 할당하지 않은 변수는 undefined 값을 가진다. 즉, 선언은 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 undefined가 반환된다. </p>
<p>이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값(Garbage value)이 들어 있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문이다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>이처럼 undefined는 개발자가 의도적으로 할당한 값이 아니라 자바스크립트 엔진에 의해 초기화된 값이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는 변수라는 것을 개발자는 간파할 수 있다. 그렇다면 개발자가 의도적으로 undefined를 할당해야하는 경우가 있을까? 자바스크립트 엔진이 변수 초기화에 사용하는 이 값을 만약 개발자가 마음대로 할당한다면 undefined의 본래의 취지와 어긋날 뿐더러 혼란을 줄수 있으므로 권장하지 않는다. 그럼 변수의 값이 없다는 것을 명시하고 싶은 경우 어떻게 하면 좋을까? 그런 경우는 undefined를 할당하는 것이 아니라 null을 할당한다. </p>
<h3 id="1-1-5-null"><a href="#1-1-5-null" class="headerlink" title="1.1.5 null"></a>1.1.5 null</h3><p>null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 NULL, Null등과 다르다. </p>
<p>프로그래밍 언어에서 null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 이는 변수가 기억하는 메모리 어드레스의 참조 정보를 제거하는 것을 의미하며 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 가비지 콜렉션을 수행할 것이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line">foo = <span class="literal">null</span>;  <span class="comment">// 참조 정보가 제거됨</span></span><br></pre></td></tr></table></figure>

<p>또는 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우, 명시적으로 null을 반환하기도 한다. 예를 들어, 조건에 부합하는 HTML 요소를 검색해 반환하는 Documnet.querySelector()는 조건에 부합하는 HTML 요소를 검색할 수 없는 겨우, null을 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.myElem&#x27;</span>);</span><br><span class="line"><span class="comment">// HTML 문서에 myElem 클래스를 갖는 요소가 없다면 null을 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(element); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>타입을 나타내는 문자열을 반환하는 typeof 연산자로 null 값을 연산해 보면 null이 아닌 object가 나온다. 이는 자바스크립트의 설계상의 오류이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>따라서 null 타입을 확인할 때 typeof 연산자를 사용하면 안되고 일치 연산자(===)를 사용하여야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo === <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">null</span>);        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-6-symbol"><a href="#1-1-6-symbol" class="headerlink" title="1.1.6 symbol"></a>1.1.6 symbol</h3><p>심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다. 심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 심볼 key는 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="built_in">Symbol</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> key); <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[key] = <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[key]); <span class="comment">// value</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-객체-타입-Object-type-Reference-type"><a href="#1-2-객체-타입-Object-type-Reference-type" class="headerlink" title="1.2 객체 타입(Object type, Reference type)"></a>1.2 객체 타입(Object type, Reference type)</h2><p>객체는 데이터와 그 데이터에 관련한 동작(절차, 방법, 기능)을 모두 포함할 수 있는 개념적 존재이다. 달리말해, 이름과 값을 가지는 데이터를 의미하는 프로퍼티(property)와 동작을 의미하는 메소드(method)를 포함할 수 있는 독립적 주체이다. </p>
<p>자바스크립트는 개체(object) 기반의 스크립트 언어로서 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입(Primitives)을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체이다. 또한 객체는 pass-by-regerence(참조에 의한 전달)방식으로 전달 된다.</p>
<h1 id="2-변수"><a href="#2-변수" class="headerlink" title="2. 변수"></a>2. 변수</h1><p>변수(Variable)는 프로그램에서 사용되는 데이터를 일정 기간 동안 기억하여 필요한 때에 다시 사용하기 위해 데이터에 고유의 이름인 식별자(identifier)를 명시한 것이다. 변수에 명시한 고유한 식별자를 변수명이라 하고 변수로 참조할 수 있는 데이터를 변수값이라 한다. </p>
<blockquote>
<p>식별자는 어떤 대상을 유일하게 식별할 수 있는 이름을 말한다. 식별자에는 변수명, 함수명, 프로퍼티명, 클래스명 등이 있다. </p>
</blockquote>
<p>변수 var, let, const 키워드를 사용하여 선언하고 할당 연산자를 사용해 값을 할당한다. 그리고 식별자인 변수명을 사용해 변수에 저장된 값을 <strong>참조</strong>한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score;  <span class="comment">// 변수의 선언</span></span><br><span class="line">score = <span class="number">80</span>; <span class="comment">// 값의 할당</span></span><br><span class="line">score = <span class="number">90</span>; <span class="comment">// 값의 재할당</span></span><br><span class="line">score;      <span class="comment">// 변수의 참조</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수의 선언과 할당</span></span><br><span class="line"><span class="keyword">var</span> average = (<span class="number">50</span> + <span class="number">100</span>) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-변수의-선언"><a href="#2-1-변수의-선언" class="headerlink" title="2.1 변수의 선언"></a>2.1 변수의 선언</h2><p>예를 들어 반지름의 길이가 2인 원의 넓이를 구해보자. 이때 원주율은 3.141592653589793라고 하자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.141592653589793</span> * <span class="number">2</span> * <span class="number">2</span>; <span class="comment">// 12.566370614359172</span></span><br></pre></td></tr></table></figure>

<p>원의 넓이를 구하였으나 그 결과를 기억할 수 없다. 만약에 원의 넓이를 다시 사용해야 한다면 다시 구해야 한다. 변수를 사용하여 원의 넓이를 기억(캐싱)하고 기억된 원의 넓이를 재사용하여 높이가 5인 원기둥의 부피를 구해보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circleArea = <span class="number">3.141592653589793</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> cylinderVolume = circleArea * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>원주율 3.141592653589793은 재사용할 가능성이 크므로 변수에 저장하도록 하자. 원주율은 변하지 않는 상수이지만 자바스크립트는 상수를 별도 지원하지 않으므로 변수 이름을 대문자로 하여 상수임을 암시하도록 하자. 그리고 반지름과 원기둥의 높이도 값의 의미를 명확히하고 변화에 대처하기 쉽도록 변수에 저장하도록 하자. </p>
<blockquote>
<p>원주율은 자바스크립트 빌트인 상수인 Math.PI을 통해 참조할 수 있다. 상수는 ES6의 const 키워드를 사용해 표현할 수 있다.<br>이것에 대해서는 나중에 자세히 살펴볼 것이다. </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PI = <span class="number">3.141592653589793</span>; <span class="comment">// 상수</span></span><br><span class="line"><span class="keyword">var</span> radius = <span class="number">2</span>; <span class="comment">// 변수</span></span><br><span class="line"><span class="keyword">var</span> circleArea = PI * radius * radius;</span><br><span class="line"><span class="keyword">var</span> cylinderHeight = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> cylinderVolume = circleArea * cylinderHeight;</span><br></pre></td></tr></table></figure>
<p>이처럼 변수는 애플리케이션에서 한번 쓰고 버리는 값이 아닌 일정기간 유지할 필요가 있는 값에 사용한다. 또한 변수를 사용하면 값의 믜미가 명확해져서 코드의 가독성이 좋아진다. </p>
<p>변수의 존재 목적을 쉽게 이해할 수 있도록 의미있는 변수명을 지정하여야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;        <span class="comment">// NG</span></span><br><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>변수명은 식별자(identifier)로 불리기도 하며 명명 규칙이 존재한다. </p>
<ul>
<li>반드시 영문자(특수문자 제외), underscore(_), 또는 달러 기호($)로 시작하여야 한다. 이어지는 문자에는 숫자(0~9)도 사용할 수 있다. </li>
<li>자바스크립트는 대/소문자를 구별하므로 사용할 수 있는 문자는 A<del>Z (대문자)와 a</del>z (소문자)이다. </li>
</ul>
<p>변수를 선언할 때는 var 키워드를 사용한다. 등호(=, equal sign)는 변수에 값을 할당하는 할당 연산자이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;     <span class="comment">// 선언</span></span><br><span class="line">name = <span class="string">&#x27;Lee&#x27;</span>; <span class="comment">// 할당</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">30</span>; <span class="comment">// 선언과 할당</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">    address = <span class="string">&#x27;Seoul&#x27;</span>,</span><br><span class="line">    price = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> price = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> tax   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> total = price + tax;</span><br></pre></td></tr></table></figure>

<p>값을 할당하지 않은 변수 즉 선언만 되어 있는 변수는 undefined로 초기값을 갖는다. 선언하지 않은 변수에 접근하면 ReferenceError가 발생한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<h2 id="2-1-변수의-중복-선언"><a href="#2-1-변수의-중복-선언" class="headerlink" title="2.1 변수의 중복 선언"></a>2.1 변수의 중복 선언</h2><p>var 키워드로 선언한 변수는 중복 선언이 가능하다. 다시 말해 변수명이 같은 변수를 중복해 선언해도 에러가 발생하지 않는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수의 중복 선언</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 변수 x는 중복 선언되었다. 이처럼 변수를 중복 선언하면 에러없이 이전 변수의 값을 덮어쓴다. 만약 동일한 변수명이 선언되어 있는 것을 모르고 변수를 중복 선언했다면 의도치 않게 변수의 값을 변경하는 부작용을 발생시킨다. 따라서 변수의 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다. </p>
<h2 id="2-2-동적-타이핑-Dynamic-Typing"><a href="#2-2-동적-타이핑-Dynamic-Typing" class="headerlink" title="2.2 동적 타이핑 (Dynamic Typing)"></a>2.2 동적 타이핑 (Dynamic Typing)</h2><p>자바스크립트는 동적 타입(dynamin/ weak type)언어이다. 이것은 변수의 지정(Type annotation)없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결정(Type Inference)될 것이라는 뜻이다. 따라서 같은 변수에 여러 타입의 값을 할당할 수 있다. 이를 동적 타이핑(Dynamic Typing)이라 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">&#x27;Hi&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-변수-호이스팅-Variable-Hoisting"><a href="#2-3-변수-호이스팅-Variable-Hoisting" class="headerlink" title="2.3 변수 호이스팅(Variable Hoisting)"></a>2.3 변수 호이스팅(Variable Hoisting)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ① undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ② 123</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ③ 456</span></span><br></pre></td></tr></table></figure>

<p>var 키워드를 사용하여 선언한 변수는 중복 선언이 가능하기 때문에 위의 코드는 문법적으로 문제가 없다. </p>
<p>1 에서 변수 foo는 아직 선언되지 않았으므로 RegerenceError: foo is not defined가 발생하는 것을 기대했겠지만 콘솔에는 undefiend가 출력된다. 이것은 다른 C-family 언어와는 차별되는 자바스크립트의 특징으로 모든 선언문은 호이스팅(Hoisting)되기 때문이다. 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문 (var, let, const, function, function*, class)이  선언되기 이전에 참조 가능하다. </p>
<p>변수가 어떻게 생성되며 호이스팅은 어떻게 이루어지는지 좀더 자세히 살펴보자. 변수는 3단계에 걸쳐 생성된다. 자세한 내용은 Execution Context을 참조하기 바란다. </p>
<blockquote>
<p><strong>선언 단계(Declaration phase)</strong><br>변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.</p>
</blockquote>
<blockquote>
<p><strong>초기화 단계(Initialization phase)</strong><br>변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화 된다. </p>
</blockquote>
<blockquote>
<p><strong>할당 단계(Assignment phase</strong><br>undefined로 초기화된 변수에 실제값을 할당한다. </p>
</blockquote>
<p>var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 즉, 스코프에 변수가 등로고디고 변수는 메모리에 공간을 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라고 한다.</p>
<p>이후 변수 할당문에 도달하면 비로소 값의 할당이 이루어진다.</p>
<ul>
<li>참고 키워드<ul>
<li>변수 생명주기</li>
<li>변수 호이스팅</li>
</ul>
</li>
</ul>
<p>앞에서 살펴본 예제를 호이스팅 관점에서 다시 확인해 보자. </p>
<p>(1) 이 실행되기 이전에 <em>var foo = 123;</em> 이 호이스팅되어 (1) 구문 앞에 <em>var foo;</em> 가 옮겨진다.(실제로 변수 선언이 코드 레벨로 옮겨진 것은 아니고 변수 객체(Variable object)에 등록되고 undefined로 초기화된 것이다.) 하지만 변수 선언 단계와 초기화 단계가 할당 단계와 분리되어 진행되기 때문에 이 단계에서는 foo에는 undefined가 할당되어 있다. 변수 foo에 값이 할당되는 것은 2행에서 실시된다. </p>
<p>(2)에서는 변수에 값이 할당되었기 때문에 123이 출력된다. </p>
<p>자바스크립트의 변수는 다른 C-family와는 달리 <strong>블록 레벨 스코프(block-level scope)</strong> 를 가지지 않고 <strong>함수 레벨 스코프(function-level scope)</strong> 를 갖는다. 단, ECMAScript 6에서 도입된 let, const 키워드를 사용하면 블록 레벨 스코프를 사용할 수 있다. 자세한 내용은 Scope를 참조하기 바란다.</p>
<blockquote>
<p><strong>함수 레벨 스코프(Function-level scope)</strong><br>함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다. </p>
</blockquote>
<blockquote>
<p><strong>블록 레벨 스코프(Block-level scope)</strong><br>코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. </p>
</blockquote>
<p>따라서 코드 블록 내의 변수 foo는 적역변수이므로 적연에 선언된 변수 foo에 할당된 값을 재할당하기 때문에 (3)의 결과는 456이 된다. </p>
<h2 id="2-4-var-키워드로-선언된-변수의-문제점"><a href="#2-4-var-키워드로-선언된-변수의-문제점" class="headerlink" title="2.4 var 키워드로 선언된 변수의 문제점"></a>2.4 var 키워드로 선언된 변수의 문제점</h2><p>ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이다. var 키워드로 선언된 변수는 아래와 같은 특징을 갖는다. 이는 다른 C-family언어와는 차별되는 특징(설계상 오류)으로 주의를 기울이지 않으면 심각한 문제를 발생시킨다. </p>
<ol>
<li><p>함수 레벨 스코프(Function-level scope)     </p>
<ul>
<li>전역 변수의 남발</li>
<li>for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다. </li>
</ul>
</li>
<li><p>var 키워드 생략 허용</p>
<ul>
<li>의도하지 않은 변수의 전역화</li>
</ul>
</li>
<li><p>중복 선언 허용</p>
<ul>
<li>의도하지 않은 변수값 변경</li>
</ul>
</li>
<li><p>변수 호이스팅</p>
<ul>
<li>변수를 선언하기 전에 참조가 가능하다. </li>
</ul>
</li>
</ol>
<p>대부분의 문제는 전역변수로 인해 발생한다. 전역 변수는 간단한 애플리케이션의 경우, 사용이 편리한 면이 있지만 불가피한 상황을 제외하고 사용을 억제해야 한다. 전역 변수는 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될지 파악하기 힘들다. 이는 의도치 않은 변수의 변경이 발생할 수 있는 가능성이 증가한다. 또한 여러 함수와 상호 의존하는 등 부수 효과(side effect)가 있을 수 있어서 복잡성이 증가한다.</p>
<p>변수의 유효 범위(scope)가 좁을수록 좋다.</p>
<p>ES6는 이러한 var의 단점을 보안하기 위해 let과 const 키워드를 도입하였다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-data-type-variable">poiemaweb.com/js-data-type-variable</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management">자바스크립트의 메모리관리</a></p>
<p><a target="_blank" rel="noopener" href="https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d?gi=e8696956a639">자바스크립트는 어떻게 동작하는가</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-01T08:01:44.184Z" title="2021-6-1 17:01:44">2021-06-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-06-07T07:33:41.252Z" title="2021-6-7 16:33:41">2021-06-07</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">18분안에 읽기 (약 2715 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/01/js-day2-syntax-basics/">js-day2-syntax-basics</a></h1><div class="content"><h3 id="Syntax-Basics"><a href="#Syntax-Basics" class="headerlink" title="Syntax Basics"></a>Syntax Basics</h3><h2 id="자바스크립트의-기본-문법"><a href="#자바스크립트의-기본-문법" class="headerlink" title="자바스크립트의 기본 문법"></a>자바스크립트의 기본 문법</h2><h1 id="1-변수"><a href="#1-변수" class="headerlink" title="1. 변수"></a>1. 변수</h1><p>변수(Variable)는 값(Value)을 저장(할당)하고 그 저장된 값을 참조하기 위해 사용한다. 한번 쓰고 버리는 값이 아닌 유지(캐싱)할 필요가 있는 값은 변수에 담아 사용한다. 이름을 통해 값의 의미를 명확히 할 수 있어 코드의 가독성이 좋아진다. </p>
<p>변수는 위치(주소)를 기억하는 저장소이다. 위치란 메모리 상의 주소(address)를 의미한다. 즉, 변수란 메모리 주소(Memory address)에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자(identifier)이다. </p>
<p>변수를 선언할 때 <strong>var</strong> 키워드를 사용한다. 할당 연산자 <strong>=</strong> 는 변수에 값을 할당하기 위해 사용한다. </p>
<p>아래의 예에서 x는 변수로 선언되었고 변수 x에는 정수값 6이 할당되었다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h1 id="2-값"><a href="#2-값" class="headerlink" title="2. 값"></a>2. 값</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>위 예제는 str이라는 이름의 변수를 선언하고 문자열 리터럴 ‘Hello World’를 값으로 할당하였다. 이때 문자열 리터럴 ‘Hello World’는 문자열 타입의 값이다. </p>
<table>
<thead>
<tr>
<th>용어</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>데이터 타입(Data Type)</td>
<td>프로그래밍 언어에서 사용할 수 있는 값의 종류</td>
</tr>
<tr>
<td>변수(Varialble)</td>
<td>값이 저장된 메모리 공간의 주소를 가르키는 식별자(identifier)</td>
</tr>
<tr>
<td>리터럴(literal)</td>
<td>소스코드 안에서 직접 만들어 낸 상수 값 자체를 말하며 값을 구성하는 최소 단위</td>
</tr>
</tbody></table>
<p>값(Value)은 프로그램에 의해 조작될 수 있는 대상을 말한다. 값은 다양한 방법으로 생성할 수 있다. 가장 간단한 방법은 리터럴 표기법(literal notation)을 사용하는 것이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 숫자 리터럴</span></span><br><span class="line"><span class="number">10.50</span></span><br><span class="line"><span class="number">1001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 리터럴</span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 리터럴</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 리터럴</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 리터럴</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 리터럴</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 리터럴</span></span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정규표현식 리터럴</span></span><br><span class="line">/ab+c/</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 리터럴</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>숫자, 문자열, 불리언과 같은 원시 타입의 리터럴은 다양한 연산자의 피연산자가 되어 하나의 값으로 평가될 수 있다. 이렇게 리터럴은 연산에 의해 하나의 값이 될 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 산술연산</span></span><br><span class="line"><span class="number">10.50</span> + <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 7가지 데이터 타입을 제공한다. </p>
<ul>
<li><p>원시 타입(primitive data type)</p>
<blockquote>
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol (new in ECMAScript 6)</li>
</ul>
</blockquote>
</li>
<li><p>객체 타입(object data type)</p>
<blockquote>
<ul>
<li>object</li>
</ul>
</blockquote>
</li>
</ul>
<p>자바스크립트는 C나 Java외는 다르게 변수를 선언할 때 데이터 타입을 미리 지정하지 않는다. 다시 말해, 변수에 할당된 값의 타입에 의해 동적으로 변수의 타입이 결정된다. 이를 동적 타이핑이라 하며 자바스크립트가 다른 프로그래밍 언어와 구별되는 특징 중 하나이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">10.50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> array = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h1><p>연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="keyword">var</span> area = <span class="number">5</span> * <span class="number">4</span>; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;My name is &#x27;</span> + <span class="string">&#x27;Lee&#x27;</span>; <span class="comment">// &quot;My name is Lee&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당 연산자</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// &quot;red&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 비교 연산자</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">3</span> &gt; <span class="number">5</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리 연산자</span></span><br><span class="line"><span class="keyword">var</span> bar = (<span class="number">5</span> &gt; <span class="number">3</span>) &amp;&amp; (<span class="number">2</span> &lt; <span class="number">4</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 연산자</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span> <span class="string">&#x27;Hi&#x27;</span>; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성 연산자</span></span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// (한국 표준시)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span> + <span class="string">&#x27;10&#x27;</span>; <span class="comment">// &#x27;110&#x27;</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">1</span> * <span class="string">&#x27;10&#x27;</span>; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h1 id="4-키워드"><a href="#4-키워드" class="headerlink" title="4. 키워드"></a>4. 키워드</h1><p>키워드(keyword)는 수행할 동작을 규정한 것이다. 예를 들어 var 키워드는 새로운 변수를 생성할 것을 지시한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수의 선언</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수의 선언</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 함수 종료 및 값의 반환</span></span><br><span class="line">  <span class="keyword">return</span> ++arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 반복문</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// 반복문 탈출</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-주석"><a href="#5-주석" class="headerlink" title="5. 주석"></a>5. 주석</h1><p>주석(Comment)은 작성된 코드의 의미를 설명하기 위해 사용한다. </p>
<p>코드는 읽기(이해하기) 쉬워야 한다. (가독성이 좋아야 한다.) 내가 작성한 코드를 다른 누군가가 읽는다면 주석을 다는것이 좋다. </p>
<p>한줄 주석은 // 다음에 작성하며 여러줄 주석은 /* 과 */ 의 사이에 작성한다. 주석은 해석기(parser)가 무시하며 실행되지 않는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 주석(Comment)은 작성된 코드의 의미를 설명하기 위해 사용한다. 코드는 읽기(이해하기) 쉬워야 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  주석(Comment)은 작성된 코드의 의미를 설명하기 위해 사용한다.</span></span><br><span class="line"><span class="comment">  코드는 읽기(이해하기) 쉬워야 한다.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>하지만 과도한 주석은 오히려 가독성을 해칠 수 있다. 주석 없이도 읽을 수 있는 코드가 최선이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="comment">// 변수 x는 나이를 나타낸다. x에는 정수 10을 할당한다. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h1 id="6-문"><a href="#6-문" class="headerlink" title="6. 문"></a>6. 문</h1><p>프로그램(스크립트)은 컴퓨터(Client-side Javascript의 경우, 엄밀히 말하면 웹브라우저)에 의해 단계별로 수행될 명령들의 집합이다. </p>
<p>각각의 명령을 문(statement)이라 하며 문이 실행되면 무슨 일인가가 일어나게 된다.</p>
<p>문은 리터럴, 연산자(Operator), 표현식(Expression), 키워드(keyword)등으로 구성되며 세미콜론(;)으로 끝나야 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> z = x + y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(z);</span><br></pre></td></tr></table></figure>

<p>문은 코드 블록(code block, {…})으로 그룹화할 수 있다. 그룹화의 목적은 함께 실행되어져야 하는 문을 정의하기 위함이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 문</span></span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 문</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>문들은 일반적으로 위에서 아래로 순서대로 실행된다. 이러한 실행 순서는 조건문 (if, switch)이나 반복문(while, for)의 사용으로 제어할 수 있다. 이를 흐름제어(Control Flow)라 한다. 또는 함수 호출로 변경될 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> greeting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (time &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  greeting = <span class="string">&#x27;Good morning&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="number">20</span>) &#123;</span><br><span class="line">  greeting = <span class="string">&#x27;Good day&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  greeting = <span class="string">&#x27;Good evening&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting);</span><br></pre></td></tr></table></figure>

<p>다른 언어와 달리 자바스크립트에서는블록 유효범위(Block-level-scope)를 생성하지 않는다. 함수 단위의 유효범위(Function-level-scope)만이 생성된다. </p>
<h1 id="7-표현식"><a href="#7-표현식" class="headerlink" title="7. 표현식"></a>7. 표현식</h1><p>표현식(Expression)은 하나의 값으로 평가(Evaluation)된다. 값(리터럴), 변수, 객체의 프로퍼티, 배열의 요소, 함수 호출, 메소드 호출, 피연산자와 연산자의 표합은 모두 표현식이며 하나의 값으로 평가(Evaluation)된다. ㅠㅛ현식은 결국 하나의 값이 되기 때문에 다른 표현식의 일부가 되어 조금 더 복잡한 표현식을 구성할 수도 있다. 아래의 예에서 5 * 10은 50으로 평가(연산) 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 표현식</span></span><br><span class="line"><span class="number">5</span>               <span class="comment">// 5</span></span><br><span class="line"><span class="number">5</span> * <span class="number">10</span>          <span class="comment">// 50</span></span><br><span class="line"><span class="number">5</span> * <span class="number">10</span> &gt; <span class="number">10</span>     <span class="comment">// true</span></span><br><span class="line">(<span class="number">5</span> * <span class="number">10</span> &gt; <span class="number">10</span>) &amp;&amp; (<span class="number">5</span> * <span class="number">10</span> &lt; <span class="number">100</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="8-문과-표현식의-비교"><a href="#8-문과-표현식의-비교" class="headerlink" title="8. 문과 표현식의 비교"></a>8. 문과 표현식의 비교</h1><p>자연어에서 문(Statement)이 마침표로 끝나는 하나의 완전한 문장(Sentence)이라고 한다면 표현식은 문을 구성하는 요소이다. 표현식은 그자체로 하나의 문이 될 수도 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선언문(Declaration statement)</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> * <span class="number">10</span>; <span class="comment">// 표현식 x = 5 * 10를 포함하는 문이다.</span></span><br><span class="line"><span class="comment">// 할당문(Assignment statement)</span></span><br><span class="line">x = <span class="number">100</span>; <span class="comment">// 이 자체가 표현식이지만 완전한 문이기도 하다.</span></span><br></pre></td></tr></table></figure>

<p>표현식과 문은 매우 유사하여 구별이 어려울 수 있다. 표현식은 평가되어 값을 만들지만 그 이상의 행위는 할 수 없다. 문은 var, function과 같은 선언 키워드를 사용하여 변수나 함수를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다. 표현식을 통해 평가한 값을 통해 실제로 컴퓨터에게 명령을 하여 무언가를 하는 것은 문이다. </p>
<h1 id="9-함수"><a href="#9-함수" class="headerlink" title="9. 함수"></a>9. 함수</h1><p>함수란 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 불록에 담긴 문들을 일괄적으로 실행할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수의 정의(함수 선언문)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>함수는 호출에 의해 실행되는데 한번만 호출할 수 있는 것이 효율적이다. 이러한 특성은 코드의 재사용이라는 측면에서 매우 유용하다. </p>
<h1 id="10-객체"><a href="#10-객체" class="headerlink" title="10. 객체"></a>10. 객체</h1><p>자바스크립트는 객체(object) 기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든것”이 객체이다. 원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. </p>
<p>자바스크립트 객체는 키(이름)와 값으로 구성된 프로퍼티(property)의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Lee&#x27;, gender: &#x27;male&#x27;, sayHello: [Function: sayHello] &#125;</span></span><br><span class="line"></span><br><span class="line">person.sayHello(); <span class="comment">// Hi! My name is Lee</span></span><br></pre></td></tr></table></figure>

<p>이와 같이 객체를 데이터를 의미하는 프로퍼티(property)와 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드(method)로 구성된 집합이다. 객체는 데이터(프로퍼티)와 그 데이터에 관련되는 동작(메소드)을 모두 포함할 수 있기 때문에 데이터와 동작을 하나의 단위로 구조화할 수 있어 유용하다. </p>
<p>자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 ‘프로토타입’이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다. 이 프로토타입은 타 언어와 구별되는 중요한 개념이다. </p>
<h1 id="11-배열"><a href="#11-배열" class="headerlink" title="11. 배열"></a>11. 배열</h1><p>배열(array)은 1개의 변수에 여러개의 값을 순차적으로 저장할 때 사용한다. 자바스크립트의 배열은 객체이며 유용한 내장 메소드를 포함하고 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-syntax-basics">poiemaweb.com/js-syntax-basics</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-31T06:55:35.481Z" title="2021-5-31 15:55:35">2021-05-31</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-05-31T07:12:26.181Z" title="2021-5-31 16:12:26">2021-05-31</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">5분안에 읽기 (약 769 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/31/js-day1-javascript-environment/">js-day1-javascript-environment</a></h1><div class="content"><h2 id="브라우저-동작-원리"><a href="#브라우저-동작-원리" class="headerlink" title="브라우저 동작 원리"></a>브라우저 동작 원리</h2><p>구글의 Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경(Runtime Environment)인 <strong>Node.js</strong>의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용되는 범용 개발 언어가 되었다. 하지만 자바스크립트가 가장 많이 사용되는 분야는 역시 웹 브라우저 환경에서 동작하는 웹 페이지/애플리케이션이다. </p>
<p>대부분의 프로그래밍 언어는 운영체제(Operating System, OS) 위에서 실행되지만 웹 애플리케이션의 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다. 따라서 브라우저 환경을 고려할 때 보다 효율적인 자바스크립트 프로그래밍이 가능하다. </p>
<p>브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저는 서버로부터 HTML, CSS, Javascript, 이미지 파일 등을 응답받는다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 표시한다. </p>
<p>자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. </p>
<p>이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, Javascript를 처리한다. 이것은 script 태그의 위치에 따로 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다. </p>
<ul>
<li><p>body 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. </p>
</li>
<li><p>DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다.</p>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-browser">poiemaweb.com/js-browser</a></p>
<p><a target="_blank" rel="noopener" href="https://d2.naver.com/helloworld/59361">브라우저는 어떻게 동작하는가?</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/javascript/">이전</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/javascript/page/3/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/javascript/">1</a></li><li><a class="pagination-link is-current" href="/categories/javascript/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/main.jpg" alt="WT.Jang"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">WT.Jang</p><p class="is-size-6 is-block">Programmer/Dancer/Gamer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Asia/Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">19</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wontaejang" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wontaejang"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/ASP-NET/"><span class="level-start"><span class="level-item">ASP.NET</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/html/"><span class="level-start"><span class="level-item">html</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-booleans/"><span class="level-start"><span class="level-item">python-booleans</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-comments/"><span class="level-start"><span class="level-item">python-comments</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-datatypes/"><span class="level-start"><span class="level-item">python-datatypes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-exercises/"><span class="level-start"><span class="level-item">python-exercises</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/python-for/"><span class="level-start"><span class="level-item">python-for</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-function/"><span class="level-start"><span class="level-item">python-function</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-if/"><span class="level-start"><span class="level-item">python-if</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-inheritance/"><span class="level-start"><span class="level-item">python-inheritance</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/python-iterators/"><span class="level-start"><span class="level-item">python-iterators</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-list/"><span class="level-start"><span class="level-item">python-list</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/python-modules/"><span class="level-start"><span class="level-item">python-modules</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-numbers/"><span class="level-start"><span class="level-item">python-numbers</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-object/"><span class="level-start"><span class="level-item">python-object</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-operators/"><span class="level-start"><span class="level-item">python-operators</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-scope/"><span class="level-start"><span class="level-item">python-scope</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-string/"><span class="level-start"><span class="level-item">python-string</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/python-syntax/"><span class="level-start"><span class="level-item">python-syntax</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/python-test/"><span class="level-start"><span class="level-item">python-test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/python-variables/"><span class="level-start"><span class="level-item">python-variables</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/python-while/"><span class="level-start"><span class="level-item">python-while</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-27T07:52:20.516Z">2021-10-27</time></p><p class="title"><a href="/2021/10/27/js-day21-Number/">js-day21-Number</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-26T07:54:57.289Z">2021-10-26</time></p><p class="title"><a href="/2021/10/26/js-day20-global-object/">js-day20-global-object</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-13T08:35:00.962Z">2021-10-13</time></p><p class="title"><a href="/2021/10/13/js-day19-built-in-object/">js-day19-built-in-object</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T07:19:08.843Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/js-day18-Object-Oriented-Programming/">js-day18-Object-Oriented-Programming</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-31T00:34:48.186Z">2021-08-31</time></p><p class="title"><a href="/2021/08/31/js-day17-closure/">js-day17-closure</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">10월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">51</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Structure/"><span class="tag">Structure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/asp-net/"><span class="tag">asp.net</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/audio/"><span class="tag">audio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c#</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/execution-context/"><span class="tag">execution_context</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/form/"><span class="tag">form</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5/"><span class="tag">html5</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/img/"><span class="tag">img</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/request/"><span class="tag">request</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/response/"><span class="tag">response</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syntax/"><span class="tag">syntax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tag/"><span class="tag">tag</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typechecking/"><span class="tag">typechecking</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/video/"><span class="tag">video</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">업데이트 소식 받기</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="구독"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="git blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 WT.Jang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>