<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>카테고리: javascript - git blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="git blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="git blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="git blog"><meta property="og:url" content="https://wontaejang.github.io/"><meta property="og:site_name" content="git blog"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://wontaejang.github.io/img/og_image.png"><meta property="article:author" content="WT.Jang"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wontaejang.github.io"},"headline":"git blog","image":["https://wontaejang.github.io/img/og_image.png"],"author":{"@type":"Person","name":"WT.Jang"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="git blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">카테고리</a></li><li class="is-active"><a href="#" aria-current="page">javascript</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-01T07:46:14.536Z" title="2021-11-1 16:46:14">2021-11-01</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-11-01T07:46:14.536Z" title="2021-11-1 16:46:14">2021-11-01</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">5분안에 읽기 (약 706 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/01/js-day22-Math/">js-day22-Math</a></h1><div class="content"><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>Math 객체는 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다. Math 객체는 생성자 함수가 아니다. 따라서 Math 객체는 정적(static) 프로퍼티와 메소드만을 제공한다.</p>
<p>사용 빈도가 높은 프로퍼티와 메소드만을 설명한다.</p>
<h1 id="1-Math-Property"><a href="#1-Math-Property" class="headerlink" title="1. Math Property"></a>1. Math Property</h1><h2 id="1-1-Math-PI"><a href="#1-1-Math-PI" class="headerlink" title="1.1 Math.PI"></a>1.1 Math.PI</h2><p>PI 값(π ≈ 3.141592653589793)을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.PI; <span class="comment">// 3.141592653589793</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Math-Method"><a href="#2-Math-Method" class="headerlink" title="2. Math  Method"></a>2. Math  Method</h1><h2 id="2-1-Math-abs-x-number-number"><a href="#2-1-Math-abs-x-number-number" class="headerlink" title="2.1 Math.abs(x:number): number"></a>2.1 Math.abs(x:number): number</h2><p>인수의 절댓값(absolute value)을 반환한다. 절댓값은 반드시 0 또는 양수이어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(-<span class="number">1</span>);       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">&#x27;-1&#x27;</span>);     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">&#x27;&#x27;</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.abs([]);       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="literal">null</span>);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="literal">undefined</span>);<span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.abs(&#123;&#125;);       <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="string">&#x27;string&#x27;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.abs();         <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Math-round-x-number-number"><a href="#2-2-Math-round-x-number-number" class="headerlink" title="2.2 Math.round(x:number): number"></a>2.2 Math.round(x:number): number</h2><p>인수의 소수점 이하를 반올림한 정수를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">1.4</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">1.6</span>);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.4</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.6</span>); <span class="comment">// -2</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.round();     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-Math-ceil-x-number-number"><a href="#2-3-Math-ceil-x-number-number" class="headerlink" title="2.3 Math.ceil(x:number): number"></a>2.3 Math.ceil(x:number): number</h2><p>인수의 소수점 이하를 올림한 정수를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">1.4</span>);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">1.6</span>);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(-<span class="number">1.4</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(-<span class="number">1.6</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.ceil();     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-Math-floor-x-number-number"><a href="#2-4-Math-floor-x-number-number" class="headerlink" title="2.4 Math.floor(x:number): number"></a>2.4 Math.floor(x:number): number</h2><p>인수의 소수점 이하를 내림한 정수를 반환한다. Math.ceil의 반대 개념이다.</p>
<ul>
<li>양수인 경우, 소수점 이하를 떼어 버린 다음 정수를 반환한다.</li>
<li>음수인 경우, 소수점 이하를 떼어 버린 다음 -1을 한 정수를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">1.9</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">9.1</span>);  <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">Math</span>.floor(-<span class="number">1.9</span>); <span class="comment">// -2</span></span><br><span class="line"><span class="built_in">Math</span>.floor(-<span class="number">9.1</span>); <span class="comment">// -10</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.floor();     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-Math-sqrt-x-number-number"><a href="#2-5-Math-sqrt-x-number-number" class="headerlink" title="2.5 Math.sqrt(x:number): number"></a>2.5 Math.sqrt(x:number): number</h2><p>인수의 제곱근을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">9</span>);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(-<span class="number">9</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">2</span>);  <span class="comment">// 1.414213562373095</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">1</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">0</span>);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt();   <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-Math-random-number"><a href="#2-6-Math-random-number" class="headerlink" title="2.6 Math.random(): number"></a>2.6 Math.random(): number</h2><p>임의의 부동 소수점을 반환한다. 반환된 부동 소수점은 0부터 1 미만이다. 즉, 0은 포함되지만 1은 포함되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random(); <span class="comment">// 0 ~ 1 미만의 부동 소수점 (0.8208720231391746)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 ~ 10의 랜덤 정수 취득</span></span><br><span class="line"><span class="comment">// 1) Math.random로 0 ~ 1 미만의 부동 소수점을 구한 다음, 10을 곱해 0 ~ 10 미만의 부동 소수점을 구한다.</span></span><br><span class="line"><span class="comment">// 2) 0 ~ 10 미만의 부동 소수점에 1을 더해 1 ~ 10까지의 부동 소수점을 구한다.</span></span><br><span class="line"><span class="comment">// 3) Math.floor으로 1 ~ 10까지의 부동 소수점의 소수점 이하를 떼어 버린 다음 정수를 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> random = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(random); <span class="comment">// 1 ~ 10까지의 정수</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-Math-pow-x-number-y-number-number"><a href="#2-7-Math-pow-x-number-y-number-number" class="headerlink" title="2.7 Math.pow(x:number, y:number): number"></a>2.7 Math.pow(x:number, y:number): number</h2><p>첫번째 인수를 밑(base), 두번째 인수를 지수(exponent)로하여 거듭제곱을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">8</span>);  <span class="comment">// 256</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1</span>); <span class="comment">// 0.5</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>);     <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES7(ECMAScript 2016) Exponentiation operator(거듭 제곱 연산자)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">8</span>; <span class="comment">// 256</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-Math-max-values-number-number"><a href="#2-8-Math-max-values-number-number" class="headerlink" title="2.8 Math.max(..values: number[]): number"></a>2.8 Math.max(..values: number[]): number</h2><p>인수 중에서 가장 큰 수를 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 요소 중에서 최대값 취득</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 Spread operator</span></span><br><span class="line"><span class="built_in">Math</span>.max(...arr); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-9-Math-min-…values-number-number"><a href="#2-9-Math-min-…values-number-number" class="headerlink" title="2.9 Math.min(…values: number[]): number"></a>2.9 Math.min(…values: number[]): number</h2><p>인수 중에서 가장 작은 수를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.min(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 요소 중에서 최소값 취득</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 Spread operator</span></span><br><span class="line"><span class="built_in">Math</span>.min(...arr); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-math">poiemaweb.com/js-math</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-27T07:52:20.516Z" title="2021-10-27 16:52:20">2021-10-27</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-11-01T07:46:14.536Z" title="2021-11-1 16:46:14">2021-11-01</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">17분안에 읽기 (약 2612 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/27/js-day21-Number/">js-day21-Number</a></h1><div class="content"><h1 id="Number-레퍼-객체"><a href="#Number-레퍼-객체" class="headerlink" title="Number 레퍼 객체"></a>Number 레퍼 객체</h1><p>Number 객체는 원시 타입 number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 레퍼(wrapper) 객체이다. 변수 또는 객체의 프로퍼티가 숫자를 값으로 가지고 있다면 Number 객체의 별도 생성없이 Number 객체의 프로퍼티와 메소드를 사용할 수 있다.</p>
<p>원시 타입이 wrapper 객체의 메소드를 사용할 수 있는 이유는 원시 타입으로 프로퍼티나 메소드를 호출할 때 원시 타입과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1.5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>위에서 원시 타입을 담고 있는 변수 num이 Number.prototype.toFixed() 메소드를 호출할 수 있는 것은 변수 num의 값이 일시적으로 wrapper객체로 변환되었기 때문이다.</p>
<h1 id="1-Number-Constructor"><a href="#1-Number-Constructor" class="headerlink" title="1. Number Constructor"></a>1. Number Constructor</h1><p>Number 객체는 Number() 생성자 함수를 통해 생성할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(value);</span><br></pre></td></tr></table></figure>

<p>만일 인자가 숫자로 변환될 수 없다면 NaN을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">&#x27;str&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(z); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>Number() 생성자 함수를 new 연산자를 붙이지 않아 생성자로 사용하지 않으면 Number 객체를 반환하지 않고 원시 타입 숫자를 반환한다. 이때 형 변환이 발생할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Number</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x, x); <span class="comment">// number 123</span></span><br></pre></td></tr></table></figure>

<p>일반적으로 숫자를 사용할 때는 원시 타입 숫자를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x == y);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Number-Property"><a href="#2-Number-Property" class="headerlink" title="2. Number Property"></a>2. Number Property</h1><p>정적(static)프로퍼티로 Number 객체를 생성할 필요없이 Number.propertyName의 형태로 사용한다. </p>
<h2 id="2-1-Number-EPSILON"><a href="#2-1-Number-EPSILON" class="headerlink" title="2.1 Number.EPSILON"></a>2.1 Number.EPSILON</h2><p>Number.EPSILON은 JavaScript에서 표현할 수 있는 가장 작은 수이다. 이는 임의의 수와 그 수보다 큰 수 중 가장 작은 수와의 차이와 같다. Number.EPSILON은 약 2.2204460492503130808472633361816E-16 또는 2-52이다.</p>
<p>부동소수점 산술 연산 비교는 정확한 값을 기대하기 어렵다. 정수는 2진법으로 오차없이 저장이 가능하지만 부동소수점을 표현하는 가장 널리 쓰이는 표준인 IEEE 754은 2진법으로 변환시 무한소수가 되어 미세한 오차가 발생할 수밖에 없는 구조적 한계를 갖는다.</p>
<p>따라서 부동소수점의 비교는 Number.EPSILON을 사용하여 비교 기능을 갖는 함수를 작성하여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>);        <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>); <span class="comment">// false!!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// Math.abs는 절댓값을 반환한다.</span></span><br><span class="line">  <span class="comment">// 즉 a와 b의 차이가 JavaScript에서 표현할 수 있는 가장 작은 수인 Number.EPSILON보다 작으면 같은 수로 인정할 수 있다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a - b) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEqual(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>));</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Number-MAX-VALUE"><a href="#2-2-Number-MAX-VALUE" class="headerlink" title="2.2 Number.MAX_VALUE"></a>2.2 Number.MAX_VALUE</h2><p>자바스크립트에서 사용 가능한 가장 큰 숫자(1.7976931348623157e+308)를 반환한다. MAX_VALUE보다 큰 숫자는 Infinity이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE; <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.MAX_VALUE;    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">Infinity</span> &gt; <span class="built_in">Number</span>.MAX_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-Number-MIN-VALUE"><a href="#2-3-Number-MIN-VALUE" class="headerlink" title="2.3 Number.MIN_VALUE"></a>2.3 Number.MIN_VALUE</h2><p>자바스크립트에서 사용 가능한 가장 작은 숫자(5e-324)를 반환한다. MIN_VALUE는 0에 가장 가까운 양수 값이다. MIN_VALUE보다 작은 숫자는 0으로 변환된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE; <span class="comment">// 5e-324</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.MIN_VALUE;    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE &gt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-Number-POSITIVE-INFINITY"><a href="#2-4-Number-POSITIVE-INFINITY" class="headerlink" title="2.4 Number.POSITIVE_INFINITY"></a>2.4 Number.POSITIVE_INFINITY</h2><p>양의 무한대 Infinity를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.POSITIVE_INFINITY <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.POSITIVE_INFINITY;   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-Number-NEGATIVE-INFINITY"><a href="#2-5-Number-NEGATIVE-INFINITY" class="headerlink" title="2.5 Number.NEGATIVE_INFINITY"></a>2.5 Number.NEGATIVE_INFINITY</h2><p>음의 무한대 -Infinity를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY <span class="comment">// -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.NEGATIVE_INFINITY;   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-Number-NaN"><a href="#2-6-Number-NaN" class="headerlink" title="2.6 Number.NaN"></a>2.6 Number.NaN</h2><p>숫자가 아님(Not-a-Number)을 나타내는 숫자값이다. Number.NaN 프로퍼티는 window.NaN 프로퍼티와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;xyz&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> * <span class="string">&#x27;string&#x27;</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>);    <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Number-Method"><a href="#3-Number-Method" class="headerlink" title="3. Number Method"></a>3. Number Method</h1><h2 id="3-1-Number-isFinite-testValue-number-boolean"><a href="#3-1-Number-isFinite-testValue-number-boolean" class="headerlink" title="3.1 Number.isFinite(testValue:number): boolean"></a>3.1 Number.isFinite(testValue:number): boolean</h2><p>매개변수에 전달된 값이 정상적인 유한수인지를 검사하여 그 결과를 Boolean으로 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">testValue</span></span> - 검사 대상 값. 암묵적 형변환되지 않는다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(testValue)</span><br></pre></td></tr></table></figure>

<p>Number.isFinite()는 전역 함수 isFinite()와 차이가 있다. 전역 함수 isFinite()는 인수를 숫자로 변환하여 검사를 수행하지만 Number.isFinite()는 인수를 변환하지 않는다. 따라서 숫자가 아닌 인수가 주어졌을 때 반환값은 언제나 false가 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>)       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;Hello&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;2005/12/12&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0</span>)         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">2e64</span>)      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">null</span>)      <span class="comment">// false. isFinite(null) =&gt; true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-Number-isInteger-testValue-number-boolean"><a href="#3-2-Number-isInteger-testValue-number-boolean" class="headerlink" title="3.2 Number.isInteger(testValue:number):boolean"></a>3.2 Number.isInteger(testValue:number):boolean</h2><p>매개변수에 전달된 값이 정수(Integer)인지 검사하여 그 결과를 Boolean으로 반환한다. 검사전에 인수를 숫자로 변환하지 않는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">testValue</span></span> - 검사 대상 값. 암묵적 형변환되지 않는다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(testValue)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">123</span>)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(-<span class="number">123</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5</span>-<span class="number">2</span>)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">0</span>)     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">0.5</span>)   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">&#x27;123&#x27;</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">false</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">Infinity</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(-<span class="literal">Infinity</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">0</span> / <span class="number">0</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-Number-isNaN-testValue-number-boolean"><a href="#3-3-Number-isNaN-testValue-number-boolean" class="headerlink" title="3.3 Number.isNaN(testValue:number):boolean"></a>3.3 Number.isNaN(testValue:number):boolean</h2><p>매개변수에 전달된 값이 NaN인지를 검사하여 그 결과를 Boolean으로 반환한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">testValue</span></span> - 검사 대상 값. 암묵적 형변환되지 않는다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(testValue)</span><br></pre></td></tr></table></figure>

<p>Number.isNaN()는 전역함수 isNaN()와 차이가 있다. 전역 함수 isNaN()는 인수를 숫자로 변환하여 검사를 수행하지만 Number.isNaN()는 인수를 변환하지 않는다. 따라서 숫자가 아닌 인수가 주어졌을 때 반환값은 언제나 false가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>)       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>) <span class="comment">// false. undefined → NaN. isNaN(undefined) → true.</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(&#123;&#125;)        <span class="comment">// false. &#123;&#125; → NaN.        isNaN(&#123;&#125;) → true.</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;blabla&#x27;</span>)  <span class="comment">// false. &#x27;blabla&#x27; → NaN.  isNaN(&#x27;blabla&#x27;) → true.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>)      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">null</span>)      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">37</span>)        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;37&#x27;</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;37.37&#x27;</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;&#x27;</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27; &#x27;</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="keyword">new</span> <span class="built_in">Date</span>())             <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="keyword">new</span> <span class="built_in">Date</span>().toString())  <span class="comment">// false. String → NaN. isNaN(String) → true.</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-Number-isSafeInteger-testValue-number-boolean"><a href="#3-4-Number-isSafeInteger-testValue-number-boolean" class="headerlink" title="3.4 Number.isSafeInteger(testValue:number):boolean"></a>3.4 Number.isSafeInteger(testValue:number):boolean</h2><p>매개변수에 전달된 값이 안전한(safe) 정수값인지 검사하여 그 결과를 Boolean으로 반환한다. 안전한 정수값은 -(2^53 - 1)와 2^53 - 1 사이의 정수값이다. 검사전에 인수를 숫자로 변환하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">testValue</span></span> - 검사 대상 값. 암묵적 형변환되지 않는다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(testValue)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">123</span>)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="number">123</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">5</span>-<span class="number">2</span>)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">0</span>)     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1000000000000000</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">10000000000000001</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">0.5</span>)   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">&#x27;123&#x27;</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">false</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">0</span> / <span class="number">0</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-Number-prototype-toExponential-fractionDigits-number-string"><a href="#3-5-Number-prototype-toExponential-fractionDigits-number-string" class="headerlink" title="3.5 Number.prototype.toExponential(fractionDigits?: number): string"></a>3.5 Number.prototype.toExponential(fractionDigits?: number): string</h2><p>대상을 지수 표기법으로 변환하여 문자열로 반환한다. 지수 표기법이란 매우 큰 숫자를 표기할 때 주로 사용하며 e(Exponent) 앞에 있는 숫자에 10의 n승이 곱하는 형식으로 수를 나타내는 방식이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234 &#x3D; 1.234e+3</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>[fractionDigits] - 0~20 사이의 정수값으로 소숫점 이하의 자릿수를 나타낸다. 옵션으로 생략 가능하다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">numObj.toExponential([fractionDigits])</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numObj = <span class="number">77.1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toExponential());  <span class="comment">// logs 7.71234e+1</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toExponential(<span class="number">4</span>)); <span class="comment">// logs 7.7123e+1</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toExponential(<span class="number">2</span>)); <span class="comment">// logs 7.71e+1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">77.1234</span>.toExponential()); <span class="comment">// logs 7.71234e+1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">77.</span>toExponential());      <span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">77</span> .toExponential());     <span class="comment">// logs 7.7e+1</span></span><br></pre></td></tr></table></figure>

<p>정수 리터럴과 함께 메소드를 사용할 경우<br>아래의 예제를 실행하면 에러가 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">77.</span>toString(); <span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<p>숫자 뒤의 .은 의미가 모호하다. 소수 구분 기호일 수도 있고 객체 프로퍼티에 접근하기 위한 마침표 표기법(Dot notation)일 수도 있다. 따라서 자바스크립트 엔진은 숫자 뒤의 .을 부동 소수점 숫자의 일부로 해석한다. 그러나 77.toString()은 숫자로 해석할 수 없으므로 에러(SyntaxError: Invalid or unexpected token)가 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span>.toString (); <span class="comment">// &#x27;1.23&#x27;</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 경우, 숫자 뒤의 첫 번째 . 뒤에는 숫자가 이어지므로 .은 명백하게 부동 소수점 숫자의 일부이다. 숫자에 소수점은 하나만 존재하므로 두 번째 .은 마침표 표기법(Dot notation)으로 해석된다.</p>
<p>따라서 정수 리터럴과 함께 메소드를 사용할 경우, 아래의 방법을 권장한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">77</span>).toString();<span class="comment">//&#x27;77&#x27;</span></span><br></pre></td></tr></table></figure>

<p>또한 아래 방법도 허용되기는 한다. 자바스크립트 숫자는 정수 부분과 소수 부분 사이에 공백을 포함할 수 없다. 따라서 숫자 뒤의 . 뒤에 공백이 오면 .을 마침표 표기법(Dot notation)으로 해석하기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">77</span> .toString(); <span class="comment">// &#x27;77&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-6-Number-prototype-toFixed-fractionDigits-number-string"><a href="#3-6-Number-prototype-toFixed-fractionDigits-number-string" class="headerlink" title="3.6 Number.prototype.toFixed(fractionDigits?: number): string"></a>3.6 Number.prototype.toFixed(fractionDigits?: number): string</h2><p>매개변수로 지정된 소숫점자리를 반올림하여 문자열로 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>[fractionDigits] - 0~20 사이의 정수값으로 소숫점 이하 자릿수를 나타낸다. 기본값은 0이며 옵션으로 생략 가능하다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">numObj.toFixed([fractionDigits])</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numObj = <span class="number">12345.6789</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 소숫점 이하 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toFixed());   <span class="comment">// &#x27;12346&#x27;</span></span><br><span class="line"><span class="comment">// 소숫점 이하 1자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toFixed(<span class="number">1</span>));  <span class="comment">// &#x27;12345.7&#x27;</span></span><br><span class="line"><span class="comment">// 소숫점 이하 2자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toFixed(<span class="number">2</span>));  <span class="comment">// &#x27;12345.68&#x27;</span></span><br><span class="line"><span class="comment">// 소숫점 이하 3자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toFixed(<span class="number">3</span>));  <span class="comment">// &#x27;12345.679&#x27;</span></span><br><span class="line"><span class="comment">// 소숫점 이하 6자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toFixed(<span class="number">6</span>));  <span class="comment">// &#x27;12345.678900&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-7-Number-prototype-toPrecision-precision-number-string"><a href="#3-7-Number-prototype-toPrecision-precision-number-string" class="headerlink" title="3.7 Number.prototype.toPrecision(precision?: number): string"></a>3.7 Number.prototype.toPrecision(precision?: number): string</h2><p>매개변수로 지정된 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환한다. 지정된 전체 자릿수로 표현할 수 없는 경우 지수 표기법으로 결과를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>[precision] - 1~21 사이의 정수값으로 전체 자릿수를 나타낸다. 옵션으로 생략 가능하다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">numObj.toPrecision([precision])</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numObj = <span class="number">15345.6789</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 전체자리수 유효</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toPrecision());   <span class="comment">// &#x27;12345.6789&#x27;</span></span><br><span class="line"><span class="comment">// 전체 1자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toPrecision(<span class="number">1</span>));  <span class="comment">// &#x27;2e+4&#x27;</span></span><br><span class="line"><span class="comment">// 전체 2자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toPrecision(<span class="number">2</span>));  <span class="comment">// &#x27;1.5e+4&#x27;</span></span><br><span class="line"><span class="comment">// 전체 3자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toPrecision(<span class="number">3</span>));  <span class="comment">// &#x27;1.53e+4&#x27;</span></span><br><span class="line"><span class="comment">// 전체 6자리수 유효, 나머지 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toPrecision(<span class="number">6</span>));  <span class="comment">// &#x27;12345.7&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-8-Number-prototype-toString-radix-number-string"><a href="#3-8-Number-prototype-toString-radix-number-string" class="headerlink" title="3.8 Number.prototype.toString(radix?: number): string"></a>3.8 Number.prototype.toString(radix?: number): string</h2><p>숫자를 문자열로 변환하여 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>[radix] - 2~36 사이의 정수값으로 진법을 나타낸다. 옵션으로 생략 가능하다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">numObj.toString([radix])</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count.toString());   <span class="comment">// &#x27;10&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">17</span>).toString());    <span class="comment">// &#x27;17&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">17</span> .toString());     <span class="comment">// &#x27;17&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">17.2</span>).toString());  <span class="comment">// &#x27;17.2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">16</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x.toString(<span class="number">2</span>));       <span class="comment">// &#x27;10000&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(x.toString(<span class="number">8</span>));       <span class="comment">// &#x27;20&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(x.toString(<span class="number">16</span>));      <span class="comment">// &#x27;10&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">254</span>).toString(<span class="number">16</span>));  <span class="comment">// &#x27;fe&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log((-<span class="number">10</span>).toString(<span class="number">2</span>));   <span class="comment">// &#x27;-1010&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log((-<span class="number">0xff</span>).toString(<span class="number">2</span>)); <span class="comment">// &#x27;-11111111&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-9-Number-prototype-valueOf-number"><a href="#3-9-Number-prototype-valueOf-number" class="headerlink" title="3.9 Number.prototype.valueOf(): number"></a>3.9 Number.prototype.valueOf(): number</h2><p>Number 객체의 원시 타입 값(primitive value)을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = numObj.valueOf();</span><br><span class="line"><span class="built_in">console</span>.log(num);           <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);    <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-number">poiemaweb.com/js-number</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-26T07:54:57.289Z" title="2021-10-26 16:54:57">2021-10-26</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-10-26T08:46:28.021Z" title="2021-10-26 17:46:28">2021-10-26</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">19분안에 읽기 (약 2825 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/26/js-day20-global-object/">js-day20-global-object</a></h1><div class="content"><h1 id="Global-Object"><a href="#Global-Object" class="headerlink" title="Global Object"></a>Global Object</h1><p>전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side( Node.js)에서는 global 객체를 의미한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in browser console</span></span><br><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in Terminal</span></span><br><span class="line">node</span><br><span class="line"><span class="built_in">this</span> === <span class="built_in">global</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>전역 객체는 실행 컨텍스트에 컨트롤이 들어가기 이전에 생성이 되며 contructor가 없기 때문에 new 연산자를 이용하여 새롭게 생성할 수 없다. 즉, 개발자가 전역 객체를 생성하는 것은 불가능하다. </p>
</li>
<li><p>전역 객체는 전역 스코프(Global Scope)를 갖게 된다. </p>
</li>
<li><p>전역 객체의 자식 객체를 사용할 때 전역 객체의 기술은 생략할 수 있다. 예를 들어 document 객체는 전역 객체 window의 자식 객체로서 window.document… 와 같이 기술할 수 있으나 일반적으로 전역 객체의 기술은 생략한다. </p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line"><span class="comment">// window.document.getElementById(&#x27;foo&#x27;).style.display = &#x27;none&#x27;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>그러나 사용자가 정의한 변수와 전역 객체의 자식 객체 이름이 충돌하는 경우, 명확히 전역 객체를 기술하여 혼동을 방지할 수 있다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveTo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> location = &#123;<span class="string">&#x27;href&#x27;</span>:<span class="string">&#x27;move to &#x27;</span>&#125;;</span><br><span class="line">  alert(location.href + url);</span><br><span class="line">  <span class="comment">// location.href = url;</span></span><br><span class="line">  <span class="built_in">window</span>.location.href = url;</span><br><span class="line">&#125;</span><br><span class="line">moveTo(<span class="string">&#x27;http://www.google.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>전역 객체는 전역변수(Global variable)를 프로퍼티로 가지게 된다. 다시 말해 전역 변수는 전역 객체의 프로퍼티이다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ga = <span class="string">&#x27;Global variable&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ga);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ga);</span><br></pre></td></tr></table></figure>

<ul>
<li>글로벌 영역에 선언한 함수도 전역 객체의 프로퍼티로 접근할 수 있다. 다시 말해 전역 함수는 전역 객체의 메소드이다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;invoked!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.foo();</span><br></pre></td></tr></table></figure>

<ul>
<li>Standard Built-in Object(표준 빌트인 객체)도 역시 전역 객체의 자식 객체이다. 전역 객체의 자식 객체를 사용할 때 전역 객체의 기술은 생략할 수 있으므로 표준 빌트인 객체도 전역 객체의 기술을 생략할 수 있다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window.alert(&#x27;Hello world!&#x27;);</span></span><br><span class="line">alert(<span class="string">&#x27;Hello world!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="1-전역-프로퍼티-Global-property"><a href="#1-전역-프로퍼티-Global-property" class="headerlink" title="1. 전역 프로퍼티(Global property)"></a>1. 전역 프로퍼티(Global property)</h1><p>전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다. 애플리케이션 전역에서 사용하는 값들을 나타내기 위해 사용한다. 전역 프로퍼티는 간단한 값이 대부분이며 다른 프로퍼티나 메소드를 가지고 있지 않다. </p>
<h2 id="1-1-Infinity"><a href="#1-1-Infinity" class="headerlink" title="1.1 Infinity"></a>1.1 Infinity</h2><p>Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.Infinity); <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>/<span class="number">0</span>);  <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">3</span>/<span class="number">0</span>); <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>); <span class="comment">// 1.7976931348623157e+308 * 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">Infinity</span>); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-NaN"><a href="#1-2-NaN" class="headerlink" title="1.2 NaN"></a>1.2 NaN</h2><p>NaN 프로퍼티는 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. NaN 프로퍼티는 Number.NaN 프로퍼티와 같다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.NaN); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;xyz&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> * <span class="string">&#x27;string&#x27;</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>);    <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-undefined"><a href="#1-3-undefined" class="headerlink" title="1.3 undefined"></a>1.3 undefined</h2><p>undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.undefined); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="2-전역-함수-Global-function"><a href="#2-전역-함수-Global-function" class="headerlink" title="2. 전역 함수 (Global function)"></a>2. 전역 함수 (Global function)</h1><p>전역 함수는 애플리케이션 전역에서 호출할 수 있는 함수로서 전역 객체의 메소드이다. </p>
<h2 id="2-1-eval"><a href="#2-1-eval" class="headerlink" title="2.1 eval()"></a>2.1 eval()</h2><p>매개변수에 전달된 문자열 구문 또는 표현식을 평가 또는 실행한다. 사용자로 부터 입력받은 콘텐츠(untrusted data)를 eval()로 실행하는 것은 보안에 매우 취약하다. eval()의 사용은 가급적으로 금지되어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(string)</span><br><span class="line"><span class="comment">// string: code 또는 표현식을 나타내는 문자열. 표현식은 존재하는 객체들의 프로퍼티들과 변수들을 포함할 수 있다.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">eval</span>(<span class="string">&#x27;2 + 2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;x * y&#x27;</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-isFinite"><a href="#2-2-isFinite" class="headerlink" title="2.2 isFinite()"></a>2.2 isFinite()</h2><p>매개변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 Boolean으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 변환한 수 검사를 수행한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(testValue) <span class="comment">// testValue: 검사 대상 값</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="literal">Infinity</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="literal">NaN</span>));       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="string">&#x27;Hello&#x27;</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="string">&#x27;2005/12/12&#x27;</span>));   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">0</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">2e64</span>));      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="string">&#x27;10&#x27;</span>));      <span class="comment">// true: &#x27;10&#x27; → 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="literal">null</span>));      <span class="comment">// true: null → 0</span></span><br></pre></td></tr></table></figure>

<p>isFinite(null)은 true를 반환하는데 이것은 null을 숫자로 변환하여 검사를 수행하였기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null이 숫자로 암묵적 강제 형변환이 일어난 경우</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// null이 불리언로 암묵적 강제 형변환이 일어난 경우</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-inNaN"><a href="#2-3-inNaN" class="headerlink" title="2.3 inNaN()"></a>2.3 inNaN()</h2><p>매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 Boolean으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 변환한 후 검사를 수행한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(testValue) <span class="comment">// testValue: 검사 대상 값</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>)       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>) <span class="comment">// true: undefined → NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;)        <span class="comment">// true: &#123;&#125; → NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;blabla&#x27;</span>)  <span class="comment">// true: &#x27;blabla&#x27; → NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>)      <span class="comment">// false: true → 1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>)      <span class="comment">// false: null → 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">37</span>)        <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strings</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;37&#x27;</span>)      <span class="comment">// false: &#x27;37&#x27; → 37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;37.37&#x27;</span>)   <span class="comment">// false: &#x27;37.37&#x27; → 37.37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;&#x27;</span>)        <span class="comment">// false: &#x27;&#x27; → 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27; &#x27;</span>)       <span class="comment">// false: &#x27; &#x27; → 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dates</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())             <span class="comment">// false: new Date() → Number</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().toString())  <span class="comment">// true:  String → NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-parseFloat"><a href="#2-4-parseFloat" class="headerlink" title="2.4 parseFloat()"></a>2.4 parseFloat()</h2><p>매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(string)</span><br><span class="line"><span class="comment">// string: 변환 대상 문자열</span></span><br></pre></td></tr></table></figure>

<p>문자열의 첫 숫자만 반환되며 전후 공백은 무시된다. 그리고 첫문자를 숫자로 변환할 수 없다면 NaN을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>);     <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;10.00&#x27;</span>);    <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;34 45 66&#x27;</span>); <span class="comment">// 34</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27; 60 &#x27;</span>);     <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;40 years&#x27;</span>); <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;He was 40&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-parseInt"><a href="#2-5-parseInt" class="headerlink" title="2.5 parseInt()"></a>2.5 parseInt()</h2><p>매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수 이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix);</span><br><span class="line"><span class="comment">// string: 파싱 대상 문자열</span></span><br><span class="line"><span class="comment">// radix: 진법을 나타내는 기수(2 ~ 36, 기본값 10)</span></span><br></pre></td></tr></table></figure>

<p>첫번째 매개변수에 전달된 값이 문자열이 아니면 문자열로 변환한 후 숫자로 해석하여 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">10</span>);     <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">10.123</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>2번째 매개변수에는 진법을 나타내는 기수(2 ~ 36)를 지정할 수 있다. 기수를 생략하면 첫번째 매개변수에 전달된 문자열을 10진수로 해석하여 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>);     <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10.123&#x27;</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>두번째 매개변수에 진법을 나타내는 기수를 지정하면 첫번째 매개변수에 전달된 문자열을 해당 기수의 숫자로 해석하여 반환한다. 이때 반환값은 언제나 10진수이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">2</span>);  <span class="comment">// 2진수 10 → 10진수 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">8</span>);  <span class="comment">// 8진수 10 → 10진수 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">16</span>); <span class="comment">// 16진수 10 → 10진수 16</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메소드를 사용한다.</p>
</blockquote>
<p>두번째 매개변수에 진법을 나타내는 기수를 지정하지 않더라도 첫번째 매개변수에 전달된 문자열이 “0x” 또는 “0X”로 시작한다면 16진수로 해석하여 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0x10&#x27;</span>); <span class="comment">// 16진수 10 → 10진수 16</span></span><br></pre></td></tr></table></figure>

<p>두번째 매개변수에 진법을 나타내는 기수를 지정하지 않더라도 첫번째 매개변수에 전달된 문자열이 “0”로 시작한다면 8진수로 해석하지 않고 10진수로 해석한다.</p>
<blockquote>
<p>ES5 이전까지는 비록 사용을 금지하고는 있었지만 “0”로 시작하는 숫자를 8진수로 해석하였다. ES6부터는 “0”로 시작하는 숫자를 8진수로 해석하지 않고 10진수로 해석한다.</p>
</blockquote>
<p>따라서 문자열을 8진수로 해석하려면 지수를 반드시 지정하여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;010&#x27;</span>); <span class="comment">// 8진수 10으로 인식하지 않는다.</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;010&#x27;</span>, <span class="number">8</span>); <span class="comment">// 8진수 10 → 10진수 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">8</span>); <span class="comment">// 8진수 10 → 10진수 8</span></span><br></pre></td></tr></table></figure>

<p>parseInt는 첫번째 매개변수에 전달된 문자열의 첫번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;A0&#x27;</span>));   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;20&#x27;</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>하지만 첫번째 매개변수에 전달된 문자열의 두번째 문자부터 해당 진수를 나타내는 숫자가 아닌 문자(예를 들어 2진수의 경우, 2)와 마주치면 이 문자와 계속되는 문자들은 전부 무시되며 해석된 정수값만을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1A0&#x27;</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;102&#x27;</span>, <span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;58&#x27;</span>, <span class="number">8</span>);   <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;FG&#x27;</span>, <span class="number">16</span>);  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>첫번째 매개변수에 전달된 문자열에 공백이 있다면 첫번째 문자열만 해석하여 반환하며 전후 공백은 무시된다. 만일 첫번째 문자열을 숫자로 파싱할 수 없는 경우, NaN을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;34 45 66&#x27;</span>); <span class="comment">// 34</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27; 60 &#x27;</span>);     <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;40 years&#x27;</span>); <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;He was 40&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-encodeURI-decodeURI"><a href="#2-6-encodeURI-decodeURI" class="headerlink" title="2.6 encodeURI() / decodeURI()"></a>2.6 encodeURI() / decodeURI()</h2><p>encodeURI()은 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다.</p>
<p>여기서 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다.</p>
<blockquote>
<p><strong>이스케이프 처리</strong><br>네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 ASCII Character-set로 변환하는 것이다. UTF-8 특수문자의 경우, 1문자당 1~3byte, UTF-8 한글 표현의 경우, 1문자당 3btye이다. 예를 들어 특수문자 공백(space)은 %20, 한글 ‘가’는 %EC%9E%90으로 인코딩된다.</p>
</blockquote>
<blockquote>
<p><strong>이스케이프 처리 이유</strong><br>URI 문법 형식 표준 RFC3986에 따르면 URL은 ASCII Character-set으로만 구성되어야 하며 한글을 포함한 대부분의 외국어나 ASCII에 정의되지 않은 특수문자의 경우 URL에 포함될 수 없다. 따라서 URL 내에서 의미를 갖고 있는 문자(%, ?, #)나 URL에 올 수 없는 문자(한글, 공백 등) 또는 시스템에 의해 해석될 수 있는 문자(&lt;, &gt;)를 이스케이프 처리하여 야기될 수 있는 문제를 예방하기 위함이다.</p>
</blockquote>
<p>단 아래의 문자는 이스케이프 처리에서 제외된다.</p>
<ul>
<li>알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( )</li>
</ul>
<p>decodeURI()은 매개변수로 전달된 URI을 디코딩한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(URI)</span><br><span class="line"><span class="comment">// URI: 완전한 URI</span></span><br><span class="line"><span class="built_in">decodeURI</span>(encodedURI)</span><br><span class="line"><span class="comment">// encodedURI: 인코딩된 완전한 URI</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">&#x27;http://example.com?name=이웅모&amp;job=programmer&amp;teacher&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> enc = <span class="built_in">encodeURI</span>(uri);</span><br><span class="line"><span class="keyword">var</span> dec = <span class="built_in">decodeURI</span>(enc);</span><br><span class="line"><span class="built_in">console</span>.log(enc);</span><br><span class="line"><span class="comment">// http://example.com?name=%EC%9D%B4%EC%9B%85%EB%AA%A8&amp;job=programmer&amp;teacher</span></span><br><span class="line"><span class="built_in">console</span>.log(dec);</span><br><span class="line"><span class="comment">// http://example.com?name=이웅모&amp;job=programmer&amp;teacher</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-encodeURIComponent-decodeURIComponent"><a href="#2-7-encodeURIComponent-decodeURIComponent" class="headerlink" title="2.7 encodeURIComponent() / decodeURIComponent()"></a>2.7 encodeURIComponent() / decodeURIComponent()</h2><p>encodeURIComponent()은 매개변수로 전달된 URI(Uniform Resource Identifier) component(구성 요소)를 인코딩한다. 여기서 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. 단 아래의 문자는 이스케이프 처리에서 제외된다.</p>
<ul>
<li>알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( )</li>
</ul>
<p>decodeURIComponent()은 매개변수로 전달된 URI component(구성 요소)를 디코딩한다.</p>
<p>encodeURIComponent()는 인수를 쿼리스트링의 일부라고 간주한다. 따라서 =, ?, &amp;를 인코딩한다. 반면 encodeURI()는 인수를 URI 전체라고 간주하며 파라미터 구분자인 =, ?, &amp;를 인코딩하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURIComponent</span>(URI)</span><br><span class="line"><span class="comment">// URI: URI component(구성 요소)</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(encodedURI)</span><br><span class="line"><span class="comment">// encodedURI: 인코딩된 URI component(구성 요소)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uriComp = <span class="string">&#x27;이웅모&amp;job=programmer&amp;teacher&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// encodeURI / decodeURI</span></span><br><span class="line"><span class="keyword">var</span> enc = <span class="built_in">encodeURI</span>(uriComp);</span><br><span class="line"><span class="keyword">var</span> dec = <span class="built_in">decodeURI</span>(enc);</span><br><span class="line"><span class="built_in">console</span>.log(enc);</span><br><span class="line"><span class="comment">// %EC%9D%B4%EC%9B%85%EB%AA%A8&amp;job=programmer&amp;teacher</span></span><br><span class="line"><span class="built_in">console</span>.log(dec);</span><br><span class="line"><span class="comment">// 이웅모&amp;job=programmer&amp;teacher</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// encodeURIComponent / decodeURIComponent</span></span><br><span class="line">enc = <span class="built_in">encodeURIComponent</span>(uriComp);</span><br><span class="line">dec = <span class="built_in">decodeURIComponent</span>(enc);</span><br><span class="line"><span class="built_in">console</span>.log(enc);</span><br><span class="line"><span class="comment">// %EC%9D%B4%EC%9B%85%EB%AA%A8%26job%3Dprogrammer%26teacher</span></span><br><span class="line"><span class="built_in">console</span>.log(dec);</span><br><span class="line"><span class="comment">// 이웅모&amp;job=programmer&amp;teacher</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-global-object">poiemaweb.com/js-global-object</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-13T08:35:00.962Z" title="2021-10-13 17:35:00">2021-10-13</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-10-22T02:25:39.683Z" title="2021-10-22 11:25:39">2021-10-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">11분안에 읽기 (약 1706 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/13/js-day19-built-in-object/">js-day19-built-in-object</a></h1><div class="content"><h1 id="Built-in-Object"><a href="#Built-in-Object" class="headerlink" title="Built-in Object"></a>Built-in Object</h1><p>자바스크립트의 객체는 아래와 같이 크게 3개의 객체로 분류할 수 있다. </p>
<ul>
<li>Native object</li>
<li>Host Object</li>
<li>User-defined object</li>
</ul>
<h1 id="1-네이티브-객체"><a href="#1-네이티브-객체" class="headerlink" title="1. 네이티브 객체"></a>1. 네이티브 객체</h1><p>네이티브 객체(Native objects or Built-in objects or Global Objects)는 ECMAScript 명세에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다. 네이티브 객체는 애플리케이션의 환경과 관계없이 언제나 사용할 수 있다.</p>
<p>Object, String, Number, Function, Array, RegExp, Date, Math와 같은 객체 생성에 관계가 있는 함수 객체와 메소드로 구성된다.</p>
<p>네이티브 객체를 Global Objects라고 부르기도 하는데 이것은 전역 객체(Global Object)와 다른 의미로 사용되므로 혼동에 주의하여야 한다.</p>
<p>전역 객체(Global Object)는 모든 객체의 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다.</p>
<h2 id="1-1-Object"><a href="#1-1-Object" class="headerlink" title="1.1 Object"></a>1.1 Object</h2><p>Object() 생성자 함수는 객체를 생성한다. 만약 생성자 인수값이 null이거나 undefined이면 빈 객체를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수 o에 빈 객체를 저장한다</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o + <span class="string">&#x27;: &#x27;</span>, o);</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o + <span class="string">&#x27;: &#x27;</span>, o);</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o + <span class="string">&#x27;: &#x27;</span>, o);</span><br></pre></td></tr></table></figure>

<p>그 이외의 경우 생성자 함수의 인수값에 따라 강제 형변환된 객체가 반환된다. 이때 반환된 객체의 [[Prototype]] 프로퍼티에 바인딩된 객체는 Object.prototype이 아니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 객체를 반환한다</span></span><br><span class="line"><span class="comment">// var obj = new String(&#x27;String&#x27;);과 동치이다</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&#x27;String&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj + <span class="string">&#x27;: &#x27;</span>, obj);</span><br><span class="line"><span class="built_in">console</span>.dir(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;String&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj + <span class="string">&#x27;: &#x27;</span>, strObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number 객체를 반환한다</span></span><br><span class="line"><span class="comment">// var obj = new Number(123);과 동치이다</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj + <span class="string">&#x27;: &#x27;</span>, obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj + <span class="string">&#x27;: &#x27;</span>, numObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean 객체를 반환한다.</span></span><br><span class="line"><span class="comment">// var obj = new Boolean(true);과 동치이다</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj + <span class="string">&#x27;: &#x27;</span>, obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boolObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> boolObj + <span class="string">&#x27;: &#x27;</span>, boolObj);</span><br></pre></td></tr></table></figure>

<p>객체를 생성할 경우 특수한 상황이 아니라면 객체리터럴 방식을 사용하는 것이 일반적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체리터럴을 사용하는 것이 바람직하다.</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>객체에 대한 자세한 내용은 Javascript Object을 참조 바란다.</p>
<h2 id="1-2-Function"><a href="#1-2-Function" class="headerlink" title="1.2 Function"></a>1.2 Function</h2><p>자바스크립트의 모든 함수는 Function 객체이다. 다른 모든 객체들처럼 Function 객체는 new 연산자을 사용해 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;return a + b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">adder(<span class="number">2</span>, <span class="number">6</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>함수에 대한 자세한 내용은 Javascript Function을 참조 바란다.</p>
<h2 id="1-3-Boolean"><a href="#1-3-Boolean" class="headerlink" title="1.3 Boolean"></a>1.3 Boolean</h2><p>Boolean 객체는 원시 타입 boolean을 위한 레퍼(wrapper) 객체이다. Boolean 생성자 함수로 Boolean 객체를 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>();      <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">0</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>Boolean 객체와 원시 타입 boolean을 혼동하기 쉽다. Boolean 객체는 true/false를 포함하고 있는 객체이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123; <span class="comment">// x는 객체로서 존재한다. 따라서 참으로 간주된다.</span></span><br><span class="line">  <span class="comment">// . . . 이 코드는 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-Number"><a href="#1-4-Number" class="headerlink" title="1.4 Number"></a>1.4 Number</h2><h2 id="1-5-Math"><a href="#1-5-Math" class="headerlink" title="1.5 Math"></a>1.5 Math</h2><h2 id="1-6-Date"><a href="#1-6-Date" class="headerlink" title="1.6 Date"></a>1.6 Date</h2><h2 id="1-7-String"><a href="#1-7-String" class="headerlink" title="1.7 String"></a>1.7 String</h2><h2 id="1-8-RegExp"><a href="#1-8-RegExp" class="headerlink" title="1.8 RegExp"></a>1.8 RegExp</h2><h2 id="1-9-Array"><a href="#1-9-Array" class="headerlink" title="1.9 Array"></a>1.9 Array</h2><h2 id="1-10-Error"><a href="#1-10-Error" class="headerlink" title="1.10 Error"></a>1.10 Error</h2><p>Error 생성자는 error 객체를 생성한다. error 객체의 인스턴스는 런타임 에러가 발생하였을 때 throw된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// foo();</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Whoops!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">&#x27;: &#x27;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Error 이외에 Error에 관련한 객체는 아래와 같다.</p>
<ul>
<li>EvalError</li>
<li>InternalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h2 id="1-11-Symbol"><a href="#1-11-Symbol" class="headerlink" title="1.11 Symbol"></a>1.11 Symbol</h2><p>Symbol은 ECMAScript 6(Javascript 2015) 에서 추가된 유일하고 변경 불가능한(immutable) 원시 타입으로 Symbol 객체는 원시 타입 Symbol 값을 생성한다.</p>
<h2 id="1-12-원시-타입과-래퍼객체-Wrapper-Object"><a href="#1-12-원시-타입과-래퍼객체-Wrapper-Object" class="headerlink" title="1.12 원시 타입과 래퍼객체(Wrapper Object)"></a>1.12 원시 타입과 래퍼객체(Wrapper Object)</h2><p>앞서 살펴본 바와 같이 각 네이티브 객체는 각자의 프로퍼티와 메소드를 가진다. 정적(static) 프로퍼티, 메소드는 해당 인스턴스를 생성하지 않아도 사용할 수 있고 prototype에 속해있는 메소드는 해당 prototype을 상속받은 인스턴스가 있어야만 사용할 수 있다.</p>
<p>그런데 원시 타입 값에 대해 표준 빌트인 객체의 메소드를 호출하면 정상적으로 작동한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#x27;HELLO WORLD!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1.5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>이는 원시 타입 값에 대해 표준 빌트인 객체의 메소드를 호출할 때, 원시 타입 값은 연관된 객체(Wrapper 객체)로 일시 변환 되기 때문에 가능한 것이다. 그리고 메소드 호출이 종료되면 객체로 변환된 원시 타입 값은 다시 원시 타입 값으로 복귀한다.</p>
<p>자세한 내용은 Prototype: 6.원시 타입(Primitive data type)의 확장을 참조 바란다.</p>
<p>Wrapper 객체는 String, Number, Boolean이 있다.</p>
<h1 id="2-호스트-객체"><a href="#2-호스트-객체" class="headerlink" title="2. 호스트 객체"></a>2. 호스트 객체</h1><p>호스트 객체(Host object)는 브라우저 환경에서 제공하는 window, XmlHttpRequest, HTMLElement 등의 DOM 노드 객체와 같이 호스트 환경에 정의된 객체를 말한다. 예를 들어 브라우저에서 동작하는 환경과 브라우저 외부에서 동작하는 환경의 자바스크립트(Node.js)는 다른 호스트 객체를 사용할 수 있다.</p>
<p>브라우저에서 동작하는 환경의 호스트 객체는 전역 객체인 window, BOM(Browser Object Model)과 DOM(Document Object Model) 및 XMLHttpRequest 객체 등을 제공한다.</p>
<h2 id="2-1-전역-객체-Global-Object"><a href="#2-1-전역-객체-Global-Object" class="headerlink" title="2.1 전역 객체(Global Object)"></a>2.1 전역 객체(Global Object)</h2><ul>
<li>전역 객체는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. </li>
</ul>
<h2 id="2-2-BOM-Browser-Object-Model"><a href="#2-2-BOM-Browser-Object-Model" class="headerlink" title="2.2 BOM (Browser Object Model)"></a>2.2 BOM (Browser Object Model)</h2><p>브라우저 객체 모델은 브라우저 탭 또는 브라우저 창의 모델을 생성한다. 최상위 객체는 window객체로 현재 브라우저 창 또는 탭을 표현하는 객체이다. 또한 이 객체의 자식 객체 들은 브라우저의 다른 기능들을 표현한다. 이 객체들은 Standard Built-in Object가 구성된 후에 구성된다. </p>
<ul>
<li>Window (현재 브라우저 창 또는 탭)<ul>
<li>document (현재 로드된 웹페이지)</li>
<li>history (브라우저 히스토리에 기록된 웹페이지들)</li>
<li>location (현재 페이지 URL)</li>
<li>navigator (브라우저 관련 정보)</li>
<li>screen (장치의 디스플레이 정보)</li>
</ul>
</li>
</ul>
<h2 id="2-3-DOM-Document-Object-Model"><a href="#2-3-DOM-Document-Object-Model" class="headerlink" title="2.3 DOM (Document Object Model)"></a>2.3 DOM (Document Object Model)</h2><p>문서 객체 모델은 현재 웹페이지의 모델을 생성한다. 최상위 객체는 document 객체로 전체 문서를 표현한다. 또한 이 객체의 자식 객체들은 문서의 다른 요소들을 표현한다. 이 객체들을 Standard Butilt-in Objects 가 구성된 후에 구성된다. </p>
<ul>
<li>document<ul>
<li>&#60;html&gt;<ul>
<li>&#60;head&gt; <ul>
<li>&#60;title&gt;</li>
</ul>
</li>
<li>&#60;body&gt;<ul>
<li>&#60;div&gt;<ul>
<li>&#60;attribute&gt;</li>
<li>&#60;p&gt;<ul>
<li>text</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-built-in-object">poiemaweb.com/js-built-in-object</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-08T07:19:08.843Z" title="2021-10-8 16:19:08">2021-10-08</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-10-08T07:38:05.508Z" title="2021-10-8 16:38:05">2021-10-08</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">40분안에 읽기 (약 5928 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/08/js-day18-Object-Oriented-Programming/">js-day18-Object-Oriented-Programming</a></h1><div class="content"><h1 id="1-객체지향-프로그래밍-Object-Oriented-Programming-개요"><a href="#1-객체지향-프로그래밍-Object-Oriented-Programming-개요" class="headerlink" title="1. 객체지향 프로그래밍(Object-Oriented Programming) 개요"></a>1. 객체지향 프로그래밍(Object-Oriented Programming) 개요</h1><p>오늘날 많은 유명한 프로그래밍 언어(Java, C++, C#, Python, PHP, Ruby, Object-C)는 객체지향 프로그래밍을 지원한다. “객체지향”이라는 개념은 불행히도 명확한 정의가 없는 것이 특징이다. 우리가 어떠한 개념을 이해하려할 때, 그 개념의 특성(attribute, property)을 통해 이해하는 것처럼 객체지향도 객체지향의 특성을 통해 이해할 수밖에 없다.</p>
<p>객체지향 프로그래밍은 실세계에 존재하고 인지하고 있는 객체(Object)를 소프트웨어의 세계에서 표현하기 위해 객체의 핵심적인 개념 또는 기능만을 추출하는 추상화(abstraction)를 통해 모델링하려는 프로그래밍 패러다임을 말한다. 다시 말해, 우리가 주변의 실세계에서 사물을 인지하는 방식을 프로그래밍에 접목하려는 사상을 의미한다.</p>
<p>객체지향 프로그래밍은 함수들의 집합 혹은 단순한 컴퓨터의 명령어들의 목록이라는 전통적인 절차지향 프로그래밍과는 다른, 관계성있는 객체들의 집합이라는 관점으로 접근하는 소프트웨어 디자인으로 볼 수 있다.</p>
<p>각 객체는 메시지를 받을 수도 있고, 데이터를 처리할 수도 있으며, 또다른 객체에게 메시지를 전달할 수도 있다. 각 객체는 별도의 역할이나 책임을 갖는 작은 독립적인 기계 또는 부품으로 볼 수 있다.</p>
<p>객체지향 프로그래밍은 보다 유연하고 유지보수하기 쉬우며 확장성 측면에서서도 유리한 프로그래밍을 하도록 의도되었고, 대규모 소프트웨어 개발에 널리 사용되고 있다.</p>
<h1 id="2-클래스-기반-vs-프로토타입-기반"><a href="#2-클래스-기반-vs-프로토타입-기반" class="headerlink" title="2. 클래스 기반 vs. 프로토타입 기반"></a>2. 클래스 기반 vs. 프로토타입 기반</h1><h2 id="2-1-클래스-기반-언어"><a href="#2-1-클래스-기반-언어" class="headerlink" title="2.1 클래스 기반 언어"></a>2.1 클래스 기반 언어</h2><p>클래스 기반 언어(Java, C++, C#, Python, PHP, Ruby, Object-C)는 클래스로 객체의 자료구조와 기능을 정의하고 생성자를 통해 인스턴스를 생성한다.</p>
<p>클래스란 같은 종류의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것으로 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user define data type)이라고 할 수 있다. 결국 클래스는 객체 생성에 사용되는 패턴 혹은 청사진(blueprint)일 뿐이며 new 연산자를 통한 인스턴스화 과정이 필요하다.</p>
<p>모든 인스턴스는 오직 클래스에서 정의된 범위 내에서만 작동하며 런타임에 그 구조를 변경할 수 없다. 이러한 특성은 정확성, 안정성, 예측성 측면에서 클래스 기반 언어가 프로토타입 기반 언어보다 좀 더 나은 결과를 보장한다.</p>
<p>아래의 예제는 Java로 구현된 클래스이다. Java는 class 키워드를 제공하고 이것으로 클래스를 정의한다. 생성자는 클래스명과 동일하며 메소드로 구현된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person me = <span class="keyword">new</span> Person(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String name= me.getName();</span><br><span class="line">    System.out.println(name); <span class="comment">// Lee</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-프로토타입-기반-언어"><a href="#2-2-프로토타입-기반-언어" class="headerlink" title="2.2 프로토타입 기반 언어"></a>2.2 프로토타입 기반 언어</h2><p>자바스크립트는 멀티-패러다임 언어로 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 언어다. 비록 다른 객체지향 언어들과의 차이점에 대한 논쟁들이 있긴 하지만, 자바스크립트는 강력한 객체지향 프로그래밍 능력들을 지니고 있다. 간혹 클래스가 없어서 객체지향이 아니라고 생각하는 사람들도 있으나 프로토타입 기반의 객체지향 언어다.</p>
<p>자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다.</p>
<ul>
<li>객체 리터럴</li>
<li>Object() 생성자 함수</li>
<li>생성자 함수</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line">obj1.name = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object() 생성자 함수</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj2.name = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> F();</span><br><span class="line">obj3.name = <span class="string">&#x27;Lee&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>자바스크립트는 이미 생성된 인스턴스의 자료구조와 기능을 동적으로 변경할 수 있다는 특징이 있다. 객체 지향의 상속, 캡슐화(정보 은닉) 등의 개념은 프로토타입 체인과 클로저 등으로 구현할 수 있다.</p>
<p>클래스 기반 언어에 익숙한 프로그래머들은 이러한 프로토타입 기반의 특성으로 인해 혼란을 느낀다. 자바스크립트에서는 함수 객체로 많은 것을 할 수 있는데 클래스, 생성자, 메소드도 모두 함수로 구현이 가능하다.</p>
<blockquote>
<p>ECMAScript 6에서 새롭게 클래스가 도입되었다. ES6의 Class는 기존 prototype 기반 객체지향 프로그래밍보다 Class 기반 언어에 익숙한 프로그래머가 보다 빠르게 학습할 수 있는 단순하고 깨끗한 새로운 문법을 제시하고 있다. ES6의 Class가 새로운 객체지향 모델을 제공하는 것이 아니며 Class도 사실 함수이고 기존 prototype 기반 패턴의 Syntactic sugar이다.</p>
</blockquote>
<h1 id="3-생성자-함수와-인스턴스의-생성"><a href="#3-생성자-함수와-인스턴스의-생성" class="headerlink" title="3. 생성자 함수와 인스턴스의 생성"></a>3. 생성자 함수와 인스턴스의 생성</h1><p>자바스크립트는 생성자 함수와 new 연산자를 통해 인스턴스를 생성할 수 있다. 이때 생성자 함수는 클래스이자 생성자의 역할을 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수(Constructor)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 프로퍼티</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메소드</span></span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메소드</span></span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me.getName()); <span class="comment">// Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 호출</span></span><br><span class="line">me.setName(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me.getName()); <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>

<p>위 예제는 잘 동작한다. 하지만 이 예제는 문제가 많다. Person 생성자 함수로 여러 개의 인스턴스를 생성해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> me  = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> you = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> him = <span class="keyword">new</span> Person(<span class="string">&#x27;Choi&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me);  <span class="comment">// Person &#123; name: &#x27;Lee&#x27;, setName: [Function], getName: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(you); <span class="comment">// Person &#123; name: &#x27;Kim&#x27;, setName: [Function], getName: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(him); <span class="comment">// Person &#123; name: &#x27;Choi&#x27;, setName: [Function], getName: [Function] &#125;</span></span><br></pre></td></tr></table></figure>

<p>위와 같이 인스턴스를 생성하면 각각의 인스턴스에 메소드 setName, getName이 중복되어 생성된다. 즉, 각 인스턴스가 내용이 동일한 메소드를 각자 소유한다. 이는 메모리 낭비인데 생성되는 인스턴스가 많아지거나 메소드가 크거나 많다면 무시할 수 없는 문제이다.</p>
<p>이같은 문제를 해결하려면 다른 접근 방식이 필요한데 그 해답은 프로토타입이다.</p>
<h1 id="4-프로토타입-체이노가-메소드의-정의"><a href="#4-프로토타입-체이노가-메소드의-정의" class="headerlink" title="4. 프로토타입 체이노가 메소드의 정의"></a>4. 프로토타입 체이노가 메소드의 정의</h1><p>모든 객체는 프로토타입이라는 다른 객체를 가리키는 내부 링크를 가지고 있다. 즉, 프로토타입을 통해 직접 객체를 연결할 수 있는데 이를 프로토타입 체인이라 한다.</p>
<p>프로토타입을 이용하여 생성자 함수 내부의 메소드를 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체로 이동시키면 생성자 함수에 의해 생성된 모든 인스턴스는 프로토타입 체인을 통해 프로토타입 객체의 메소드를 참조할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 객체에 메소드 정의</span></span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 객체에 메소드 정의</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me  = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> you = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> him = <span class="keyword">new</span> Person(<span class="string">&#x27;choi&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// Person &#123; setName: [Function], getName: [Function] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me);  <span class="comment">// Person &#123; name: &#x27;Lee&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(you); <span class="comment">// Person &#123; name: &#x27;Kim&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(him); <span class="comment">// Person &#123; name: &#x27;choi&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>Person 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체로 이동시킨 setName. getName 메소드는 프로토타입 체인에 의해 모든 인스턴스가 참조할 수 있다. 프로토타입 객체는 상속할 것들이 저장되는 장소이다.</p>
<p>아래는 더글라스 크락포드가 제안한 프로토타입 객체에 메소드를 추가하는 방식이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 모든 생성자 함수의 프로토타입은 Function.prototype이다. 따라서 모든 생성자 함수는 Function.prototype.method()에 접근할 수 있다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method </span>Function.prototype.method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>(&#123;string&#125;) (name) - (메소드 이름)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>(&#123;function&#125;) (func) - (추가할 메소드 본체)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params">name, func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자함수의 프로토타입에 동일한 이름의 메소드가 없으면 생성자함수의 프로토타입에 메소드를 추가</span></span><br><span class="line">  <span class="comment">// this: 생성자함수</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.prototype[name]) &#123;</span><br><span class="line">    <span class="built_in">this</span>.prototype[name] = func;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 생성자 함수</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 생성자함수 Person의 프로토타입에 메소드 setName을 추가</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Person.method(<span class="string">&#x27;setName&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 생성자함수 Person의 프로토타입에 메소드 getName을 추가</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Person.method(<span class="string">&#x27;getName&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me  = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> you = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> him = <span class="keyword">new</span> Person(<span class="string">&#x27;choi&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// Person &#123; setName: [Function], getName: [Function] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me);  <span class="comment">// Person &#123; name: &#x27;Lee&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(you); <span class="comment">// Person &#123; name: &#x27;Kim&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(him); <span class="comment">// Person &#123; name: &#x27;choi&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-상속-Ineheritance"><a href="#5-상속-Ineheritance" class="headerlink" title="5. 상속(Ineheritance)"></a>5. 상속(Ineheritance)</h1><p>Java같은 클래스 기반 언어에서 상속(또는 확장)은 코드 재사용의 관점에서 매우 유용하다. 새롭게 정의할 클래스가 기존에 있는 클래스와 매우 유사하다면, 상속을 통해 다른 점만 구현하면 된다. 코드 재사용은 개발 비용을 현저히 줄일 수 있는 잠재력이 있기 때문에 매우 중요하다.</p>
<p>클래스 기반 언어에서 객체는 클래스의 인스턴스이며 클래스는 다른 클래스로 상속될 수 있다. 자바스크립트는 기본적으로 프로토타입을 통해 상속을 구현한다. 이것은 프로토타입을 통해 객체가 다른 객체로 직접 상속된다는 의미이다. 이러한 점이 자바스크립트의 약점으로 여겨지기도 하지만 프로토타입 상속 모델은 사실 클래스 기반보다 강력한 방법이다.</p>
<p>자바스크립트의 상속 구현 방식은 크게 두 가지로 구분할 수 있다. 하나는 클래스 기반 언어의 상속 방식을 흉내 내는 것(의사 클래스 패턴 상속. Pseudo-classical Inheritance)이고, 두번째는 프로토타입으로 상속을 구현하는 것(프로토타입 패턴 상속. Prototypal Inheritance)이다.</p>
<h2 id="5-1-의사-클래스-패턴-상속-Pseudo-classical-Inheritance"><a href="#5-1-의사-클래스-패턴-상속-Pseudo-classical-Inheritance" class="headerlink" title="5.1 의사 클래스 패턴 상속 (Pseudo-classical Inheritance)"></a>5.1 의사 클래스 패턴 상속 (Pseudo-classical Inheritance)</h2><p>의사 클래스 패턴은 자식 생성자 함수의 prototype 프로퍼티를 부모 생성자 함수의 인스턴스로 교체하여 상속을 구현하는 방법이다. 부모와 자식 모두 생성자 함수를 정의하여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 부모 생성자 함수</span></span><br><span class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return constructor</span></span><br><span class="line">  <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 자식 생성자 함수</span></span><br><span class="line"><span class="keyword">var</span> Child = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 자식 생성자 함수의 프로토타입 객체를 부모 생성자 함수의 인스턴스로 교체.</span></span><br><span class="line">  Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메소드 오버라이드</span></span><br><span class="line">  Child.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;안녕하세요! &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sayBye 메소드는 Parent 생성자함수의 인스턴스에 위치된다</span></span><br><span class="line">  Child.prototype.sayBye = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;안녕히가세요! &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return constructor</span></span><br><span class="line">  <span class="keyword">return</span> Child;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">&#x27;child&#x27;</span>); <span class="comment">// ①</span></span><br><span class="line"><span class="built_in">console</span>.log(child);  <span class="comment">// Parent &#123; name: &#x27;child&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype); <span class="comment">// Parent &#123; name: undefined, sayHi: [Function], sayBye: [Function] &#125;</span></span><br><span class="line"></span><br><span class="line">child.sayHi();  <span class="comment">// 안녕하세요! child</span></span><br><span class="line">child.sayBye(); <span class="comment">// 안녕히가세요! child</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Child);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Child 생성자 함수가 생성한 인스턴스 child(①)의 프로토타입 객체는 Parent 생성자 함수가 생성한 인스턴스(②)이다. 그리고 Parent 생성자 함수가 생성한 인스턴스의 프로토타입 객체는 Parent.prototype이다.</p>
<p>이로써 child는 프로토타입 체인에 의해 Parent 생성자 함수가 생성한 인스턴스와 Parent.prototype의 모든 프로퍼티에 접근할 수 있게 되었다. 이름은 의사 클래스 패턴 상속이지만 내부에서는 프로토타입을 사용하는 것은 변함이 없다.</p>
<p>의사 클래스 패턴은 클래스 기반 언어의 상속을 흉내내어 상속을 구현하였다. 구동 상에 문제는 없지만 의사 클래스 패턴은 아래와 같은 문제를 가지고 있다.</p>
<ol>
<li><p>new 연산자를 통해 인스턴스를 생성한다.<br>이는 자바스크립트의 프로토타입 본질에 모순되는 것이다. 프로토타입 본성에 맞게 객체에서 다른 객체로 직접 상속하는 방법을 갖는 대신 생성자 함수와 new 연산자를 통해 객체를 생성하는 불필요한 간접적인 단계가 있다. 클래스와 비슷하게 보이는 일부 복잡한 구문은 프로토타입 메커니즘을 명확히 나타내지 못하게 한다.<br>게다가 생성자 함수의 사용에는 심각한 위험이 존재한다. 만약 생성자 함수를 호출할 때 new 연산자를 포함하는 것을 잊게 되면 this는 새로운 객체와 바인딩되지 않고 전역객체에 바인딩된다. (new 연산자와 함께 호출된 생성자 함수 내부의 this는 새로 생성된 객체를 참조한다.)<br>이런 문제점을 경감시키기 위해 파스칼 표시법(첫글자를 대문자 표기)으로 생성자 함수 이름을 표기하는 방법을 사용하지만, 더 나은 대안은 new 연산자의 사용을 피하는 것이다.</p>
</li>
<li><p>생성자 링크의 파괴<br>위 그림을 보면 child 객체의 프로토타입 객체는 Parent 생성자 함수가 생성한 new Parent() 객체이다. 프로토타입 객체는 내부 프로퍼티로 constructor를 가지며 이는 생성자 함수를 가리킨다. 하지만 의사 클래스 패턴 상속은 프로토타입 객체를 인스턴스로 교체하는 과정에서 constructor의 연결이 깨지게 된다. 즉, child 객체를 생성한 것은 Child 생성자 함수이지만 child.constructor의 출력 결과는 Child 생성자 함수가 아닌 Parent 생성자 함수를 나타낸다. 이는 child 객체의 프로토타입 객체인 new Parent() 객체는 constructor가 없기 때문에 프로토타입 체인에 의해 Parent.prototype의 constructor를 참조했기 때문이다.</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.constructor);  <span class="comment">// [Function: Parent]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>객체리터럴<br>의사 클래스 패턴 상속은 기본적으로 생성자 함수를 사용하기 때문에 객체리터럴 패턴으로 생성한 객체의 상속에는 적합하지 않다. 이는 객체리터럴 패턴으로 생성한 객체의 생성자 함수는 Object()이고 이를 변경할 방법이 없기 때문이다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-프로토타입-패턴-상속-Prototypal-Inheritance"><a href="#5-2-프로토타입-패턴-상속-Prototypal-Inheritance" class="headerlink" title="5.2 프로토타입 패턴 상속 (Prototypal Inheritance)"></a>5.2 프로토타입 패턴 상속 (Prototypal Inheritance)</h2><p>프로토타입 패턴 상속은 Object.create 함수를 사용하여 객체에서 다른 객체로 직접 상속을 구현하는 방식이다. 프로토타입 패턴 상속은 개념적으로 의사 클래스 패턴 상속보다 더 간단하다. 또한 의사 클래스 패턴의 단점인 new 연산자가 필요없으며, 생성자 링크도 파괴되지 않으며, 객체리터럴에도 사용할 수 있다.</p>
<p>생성자 함수를 사용한 프로토타입 패턴 상속은 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 부모 생성자 함수</span></span><br><span class="line"><span class="keyword">var</span> Parent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return constructor</span></span><br><span class="line">  <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// create 함수의 인수는 프로토타입이다.</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">child.name = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line"></span><br><span class="line">child.sayHi();  <span class="comment">// Hi! child</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Parent); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>객체리터럴 패턴으로 생성한 객체에도 프로토타입 패턴 상속을 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  name: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create 함수의 인자는 객체이다.</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent);</span><br><span class="line">child.name = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var child = Object.create(parent, &#123;name: &#123;value: &#x27;child&#x27;&#125;&#125;);</span></span><br><span class="line"></span><br><span class="line">parent.sayHi(); <span class="comment">// Hi! parent</span></span><br><span class="line">child.sayHi();  <span class="comment">// Hi! child</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parent.isPrototypeOf(child)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Object.create 함수는 매개변수에 프로토타입으로 설정할 객체 또는 인스턴스를 전달하고 이를 상속하는 새로운 객체를 생성한다. Object.create 함수는 표준에 비교적 늦게 추가되어 IE9 이상에서 정상적으로 동작한다. 따라서 크로스 브라우징에 주의하여야 한다. Object.create 함수의 폴리필(Polyfill: 특정 기능이 지원되지 않는 브라우저를 위해 사용할 수 있는 코드 조각이나 플러그인)을 살펴보면 상속의 핵심을 이해할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create 함수의 폴리필</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// 1</span></span><br><span class="line">    F.prototype = o; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();  <span class="comment">// 3</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 폴리필은 프로토타입 패턴 상속의 핵심을 담고 있다.</p>
<ol>
<li>비어있는 생성자 함수 F를 생성한다.</li>
<li>생성자 함수 F의 prototype 프로퍼티에 매개변수로 전달받은 객체를 할당한다.</li>
<li>생성자 함수 F를 생성자로 하여 새로운 객채를 생성하고 반환한다.</li>
</ol>
<h1 id="6-캡슐화-Encapsulation-와-모듈-패턴-Module-Pattern"><a href="#6-캡슐화-Encapsulation-와-모듈-패턴-Module-Pattern" class="headerlink" title="6. 캡슐화(Encapsulation)와 모듈 패턴(Module Pattern)"></a>6. 캡슐화(Encapsulation)와 모듈 패턴(Module Pattern)</h1><p>캡슐화는 관련있는 멤버 변수와 메소드를 클래스와 같은 하나의 틀 안에 담고 외부에 공개될 필요가 없는 정보는 숨기는 것을 말하며 다른 말로 정보 은닉(information hiding)이라고 한다.</p>
<p>Java의 경우, 클래스를 정의하고 그 클래스를 구성하는 멤버에 대하여 public 또는 private 등으로 한정할 수 있다. public으로 선언된 메소드 또는 데이터는 외부에서 사용이 가능하며, private으로 선언된 경우는 외부에서 참조할 수 없고 내부에서만 사용된다.</p>
<p>이것은 클래스 외부에는 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 작용을 한다. 이렇게 함으로써 이들 부분이 프로그램의 다른 부분들에 영향을 미치지 않고 변경될 수 있다.</p>
<p>하지만 자바스크립트는 public 또는 private 등의 키워드를 제공하지 않는다. 하지만 정보 은닉이 불가능한 것은 아니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = arg ? arg : <span class="string">&#x27;&#x27;</span>; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    name = arg;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = me.getName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line">me.setName(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line">name = me.getName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>

<p>①의 name 변수는 private 변수가 된다. 자바스크립트는 function-level scope를 제공하므로 함수 내의 변수는 외부에서 참조할 수 없다. 만약에 var 때신 this를 사용하면 public 멤버가 된다. 단 new 키워드로 객체를 생성하지 않으면 this는 생성된 객체에 바인딩되지 않고 전역객체에 연결된다.</p>
<p>그리고 public 메소드 getName, setName은 클로저로서 private 변수(자유 변수)에 접근할 수 있다. 이것이 기본적인 정보 은닉 방법이다.</p>
<p>위 예제를 조금 더 정리해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = arg ? arg : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">      name = arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = person(<span class="string">&#x27;Lee&#x27;</span>); <span class="comment">/* or var me = new person(&#x27;Lee&#x27;); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = me.getName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line">me.setName(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line">name = me.getName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>

<p>person 함수는 객체를 반환한다. 이 객체 내의 메소드 getName, setName은 클로저로서 private 변수 name에 접근할 수 있다. 이러한 방식을 모듈 패턴이라 하며 캡슐화와 정보 은닉를 제공한다. 많은 라이브러리에서 사용되는 유용한 패턴이다.</p>
<p>이 모듈 패턴은 다음과 같은 주의할 점이 있다.</p>
<ul>
<li>private 멤버가 객체나 배열일 경우, 반환된 해당 멤버의 변경이 가능하다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span> (<span class="params">personInfo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = personInfo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getPersonInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = person(&#123; <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myInfo = me.getPersonInfo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;myInfo: &#x27;</span>, myInfo);</span><br><span class="line"><span class="comment">// myInfo:  &#123; name: &#x27;Lee&#x27;, gender: &#x27;male&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">myInfo.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"></span><br><span class="line">myInfo = me.getPersonInfo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;myInfo: &#x27;</span>, myInfo);</span><br><span class="line"><span class="comment">// myInfo:  &#123; name: &#x27;Kim&#x27;, gender: &#x27;male&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>객체를 반환하는 경우 반환값은 얕은 복사(shallow copy)로 private 멤버의 참조값을 반환하게 된다. 따라서 외부에서도 private 멤버의 값을 변경할 수 있다. 이를 회피하기 위해서는 객체를 그대로 반환하지 않고 반환해야 할 객체의 정보를 새로운 객체에 담아 반환해야 한다. 반드시 객체 전체가 그대로 반환되어야 하는 경우에는 깊은 복사(deep copy)로 복사본을 만들어 반환한다.</p>
<ul>
<li>person 함수가 반환한 객체는 person 함수 객체의 프로토타입에 접근할 수 없다. 이는 상속을 구현할 수 없음을 의미한다.<br>앞에서 살펴본 모듈 패턴은 생성자 함수가 아니며 단순히 메소드를 담은 객체를 반환한다. 반환된 객체는 객체 리터럴 방식으로 생성된 객체로 함수 person의 프로토타입에 접근할 수 없다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = arg ? arg : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">      name = arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.prototype === me.__proto__); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true: 객체 리터럴 방식으로 생성된 객체와 동일하다</span></span><br></pre></td></tr></table></figure>

<p>반환된 객체가 함수 person의 프로토타입에 접근할 수 없다는 것은 person을 부모 객체로 상속할 수 없다는 것을 의미한다.<br>함수 person을 부모 객체로 상속할 수 없다는 것은 함수 person이 반환하는 객체에 모든 메소드를 포함시켜야한다는 것을 의미한다.</p>
<p>이 문제를 해결하기 위해서는 객체를 반환하는 것이 아닌 함수를 반환해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123; name = arg ? arg : <span class="string">&#x27;&#x27;</span>; &#125;;</span><br><span class="line"></span><br><span class="line">  F.prototype = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">      name = arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype === me.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.getName());</span><br><span class="line">me.setName(<span class="string">&#x27;Kim&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(me.getName());</span><br></pre></td></tr></table></figure>
<p>캡슐화를 구현하는 패턴은 다양하며 각각의 패턴에는 장단점이 있다. 다양한 패턴의 장단점을 분석하고 파악하는 것이 보다 효율적인 코드를 작성하는데 중요하다.</p>
<p>지금까지 자바스크립트에서의 객체지향 프로그래밍을 구현하는 방법을 알아보았다. 사실 자바스크립트는 클래스 기반 언어가 아니므로 기존의 전통적 방식으로 구현하려는 시도는 바른 판단은 아니다. 다만 객체지향 프로그래밍이 추구하는 재사용성, 유지보수의 용이성 등을 극대화하기 위한 노력의 일환으로 보아야 한다. 자바스크립트만의 방식을 잘 활용하여 기존의 방식에 얽매이지 않는다면 보다 효율적인 프로그래밍이 가능할 것이다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-object-oriented-programming">poiemaweb.com/js-object-oriented-programming</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-31T00:34:48.186Z" title="2021-8-31 9:34:48">2021-08-31</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-10-08T07:19:12.953Z" title="2021-10-8 16:19:12">2021-10-08</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">35분안에 읽기 (약 5186 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/31/js-day17-closure/">js-day17-closure</a></h1><div class="content"><h1 id="1-크로저-closure-의-개념"><a href="#1-크로저-closure-의-개념" class="headerlink" title="1. 크로저(closure)의 개념"></a>1. 크로저(closure)의 개념</h1><p>클로저(closure)는 자바스크립트에서 중요한 개념중 하나로 자바스크립트에 관심을 가지고 있다면 한번쯤은 들어보았을 내용이다. excution context에 대한 사전 지식이 있으면 이해하기 어렵지 않은 개념이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급객체로 취급하는 함수형 프로그래밍 언어(Functional Programming language: 얼랭(Erlnag), 스칼라(Scala), 하스켈(Haskell), 리스프(Lisp)…)에서 사용되는 중요한 특성이다.</p>
<p>클로저는 자바스크립트 고유의 개념이 아니므로 ECMAScript 명세에 클로저의 정의가 등장하지 않는다. 클로저에 대해 MDN은 아래와 같이 정의하고 있다. </p>
<blockquote>
<p>“A closure is the combination of a function and the lexical environment within which that function was declared.”<br>클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(x); &#125;;</span><br><span class="line">  innerFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerFunc(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>함수 outerFunc 내에서 내부함수 innerFunc가 선언되고 호출되었다. 이때 내부함수 innerFunc는 자신을 포함하고 있는 외부함수 outerFunc의 변수 x에 접근할 수 있다. 이는 함수 innerFunc가 함수 outerFunc의 내부에 선언되었기 때문이다. </p>
<blockquote>
<p>스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정된다. 이를 렉시컬 스코핑(Lexical scoping)라 한다. 위 예제의 함수 innerFunc는 함수 outerFunc의 내부에서 선언되었기 때문에 함수 innerFunc의 상위 스코프는 함수 outerFunc이다. 함수 innerFunc가 전역에 선언되었다면 함수 innerFunc의 상위 스코프는 전역 스코프가 된다.</p>
</blockquote>
<p>함수 innerFunc가 함수 outerFunc의 내부에 선언된 내부함수이므로 함수 innerFunc는 자신이 혹한 렉시컬 스코프(전역, 함수 outerFunc, 자신의 스코프)를 참조할 수 있다. 이것을 실행 컨텍스트의 관점에서 설명해보자. </p>
<p>내부함수 innerFunc가 호출되면 자신의 실행 컨텍스트가 실행 컨텍스트 스택에 쌓이고 변수 객체(Variable Object)와 스코프 체인(Scope chain) 그리고 this에 바인딩할 객체가 결정된다. 이때 스코프 체인은 전역 스코프를 가리키는 전역객체와 함수 outerFunc의 스코프를 가리키는 함수 outerFunc의 활성객체(Activation object) 그리고 함수 자신의 스코프를 가리키는 활성객체를 순차적으로 바인딩한다. 스코프 체인이 바인딩한 객체가 바로 렉시컬 스코프의 실체이다. </p>
<p>내부함수 innerFunc가 자신을 포함하고 있는 외부함수 outerFunc의 변수 x에 접근할 수 있는것, 다시 말해 상위 스코프에 접근할 수 있는것은 렉시컬 스코프의 레퍼런스를 차례대로 저장하고 있는 실행 컨텍스트의 스코프 체인을 자바스크립트 엔진이 검색하였기에 가능한 것이다. 좀더 자세히 설명하면 아래와 같다. </p>
<ol>
<li><p>innerFunc 함수 스코프(함수 자신의 스코프를 가리키는 활성 객체) 내에서 변수 x를 검색한다. 검색이 실패하였다. </p>
</li>
<li><p>innerFunc 함수를 포함하는 외부 함수 outerFunc의 스코프(함수 outerFunc의 스코프를 가리키는 함수 outerFunc의 활성 객체)에서 변수 x를 검색한다. 검색이 성공하였다. </p>
</li>
</ol>
<p>이번에는 내부함수 innerFunc를 함수 outerFunc 내에서 호출하는 것이 아니라 반환하도록 변경해 보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(x); &#125;;</span><br><span class="line">  <span class="keyword">return</span> innerFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다.</span></span><br><span class="line"><span class="comment"> *  그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inner = outerFunc();</span><br><span class="line">inner(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>함수 outerFunc는 내부함수 innerFunc를 반환하고 생을 마감했다. 즉, 함수 outerFunc는 실행된 이후 콜스택(실행 컨텍스트 스택)에서 제거되었으므로 함수 outerFunc의 변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법은 달리 없어 보인다. 그러나 위 코드의 실행 결과는 변수 x의 값인 10이다. 이미 life-cycle이 종료되어 실행 컨텍스트 스택에서 제거된 함수 outerFunc의 지역변수 x가 다시 부활이라도 한 듯이 동작하고 있다. 뭔가 특별한 일이 일어나고 있는것 같다. </p>
<p>이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부른다. </p>
<p>다시 MDN의 정의로 돌아가 보자.</p>
<blockquote>
<p>“A closure is the combination of a function and the lexical environment within which that function was declared.”<br>클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.</p>
</blockquote>
<p>위 정의에서 말하는 ‘함수’란 반환된 내부함수를 의미하고 ‘그 함수가 선언될 때의 렉시컬 환경(Lexical environment’란 내부 함수가 선언됐을 때의 스코프를 의미한다. 즉, 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호추로디어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다. 이를 조금 더 간단히 말하면 클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다라고 말할 수 있겠다. </p>
<p>클로저에 의해 참조되는 외부함수의 변수 즉 outerFunc 함수의 변수 x를 자유변수(Free variable)라고 부른다. 클로저라는 이름은 자유변수에 함수가 닫혀있다(closed)라는 의미로 의역하면 자유변수에 엮여있는 함수라는 뜻이다. </p>
<p>실행 컨텍스트의 관점에 설명하면, 내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 활정객체(Activation object)(변수, 함수 선언 등의 정보를 가지고 있다)는 내부함수에 의해 참조되는 한 유효하여 내부함수가 스코프 체인을 통해 참조할 수 있는 것을 의미한다.</p>
<p>즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다.</p>
<h1 id="2-클로저의-활용"><a href="#2-클로저의-활용" class="headerlink" title="2. 클로저의 활용"></a>2. 클로저의 활용</h1><p>클로저는 자신이 생성될때의 환경(Lexical environment)을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있다. 하지만 클로저는 자바스크립트의 강력한 기능으로 이를 적극적으로 사용해야 한다. 크롤저가 유용하게 사용되는 상황에 대해 살펴보자. </p>
<h2 id="2-1-상태-유지"><a href="#2-1-상태-유지" class="headerlink" title="2.1 상태 유지"></a>2.1 상태 유지</h2><p>클로저가 가장 유용하게 사용되는 상황은 현재 상태를 기억하고 변경된 최신 상태를 유지하는 것이다. 아래 예제를 살펴보자.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span>toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px; background: red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> toggleBtn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.toggle&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> toggle = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> isShow = <span class="literal">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// ① 클로저를 반환</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        box.style.display = isShow ? <span class="string">&#x27;block&#x27;</span> : <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// ③ 상태 변경</span></span></span><br><span class="line">        isShow = !isShow;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// ② 이벤트 프로퍼티에 클로저를 할당</span></span></span><br><span class="line">    toggleBtn.onclick = toggle;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="result"><a href="#result" class="headerlink" title="result"></a><em><strong>result</strong></em></h3><iframe width='100%' height='150px' srcdoc="
<!DOCTYPE html>
<html>
<body>
  <button class='toggle'>toggle</button>
  <div class='box' style='width: 100px; height: 100px; background: red;'></div>
  <script>
    var box = document.querySelector('.box');
    var toggleBtn = document.querySelector('.toggle');
    var toggle = (function () {
      var isShow = false;
      // ① 클로저를 반환
      return function () {
        box.style.display = isShow ? 'block' : 'none';
        // ③ 상태 변경
        isShow = !isShow;
      };
    })();
    // ② 이벤트 프로퍼티에 클로저를 할당
    toggleBtn.onclick = toggle;
  </script>
</body>
</html>
">
</iframe>

<p>① 즉시실행함수는 함수를 반환하고 즉시 소멸한다. 즉시실행함수가 반환한 함수는 자신이 생성됐을 때의 렉시컬 환경(Lexical environment)에 속한 변수 isShow를 기억하는 클로저다. 클로저가 기억하는 변수 isShow는 box 요소의 표시 상태를 나타낸다.</p>
<p>② 클로저를 이벤트 핸들러로서 이벤트 프로퍼티에 할당했다. 이벤트 프로퍼티에서 이벤트 핸들러인 클로저를 제거하지 않는 한 클로저가 기억하는 렉시컬 환경의 변수 isShow는 소멸하지 않는다. 다시 말해 현재 상태를 기억한다.</p>
<p>③ 버튼을 클릭하면 이벤트 프로퍼티에 할당한 이벤트 핸들러인 클로저가 호출된다. 이때 .box 요소의 표시 상태를 나타내는 변수 isShow의 값이 변경된다. 변수 isShow는 클로저에 의해 참조되고 있기 때문에 유효하며 자신의 변경된 최신 상태를 게속해서 유지한다.</p>
<p>이처럼 클로저는 현재 상태(위 예제의 경우 .box 요소의 표시 상태를 나타내는 isShow 변수)를 기억하고 이 상태가 변경되어도 최신 상태를 유지해야 하는 상황에 매우 유용하다. 만약 자바스크립트에 클로저라는 기능이 없다면 상태를 유지하기 위해 전역 변수를 사용할 수 밖에 없다. 전역 변수는 언제든지 누구나 접근할 수 있고 변경할 수 있기 때문에 많은 부작용을 유발해 오류의 원인이 되므로 사용을 억제해야 한다.</p>
<h2 id="2-2-전역-변수의-사용-억제"><a href="#2-2-전역-변수의-사용-억제" class="headerlink" title="2.2 전역 변수의 사용 억제"></a>2.2 전역 변수의 사용 억제</h2><p>버튼이 클릭될 때마다 클릭한 횟수가 누적되어 화면에 표시되는 카운터를 만들어보자. 이 예제의 클릭된 횟수가 바로 유지해야할 상태이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;전역 변수를 사용한 Counting&lt;/p&gt;</span><br><span class="line">  &lt;button id=<span class="string">&quot;inclease&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;p id=<span class="string">&quot;count&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> incleaseBtn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inclease&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> count = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;count&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 카운트 상태를 유지하기 위한 전역 변수</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incleaseBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      count.innerHTML = increase();</span><br><span class="line">    &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="result-1"><a href="#result-1" class="headerlink" title="result"></a><em><strong>result</strong></em></h3><iframe width='100%' height='150px' srcdoc="
<!DOCTYPE html>
<html>
<body>
  <p>전역 변수를 사용한 Counting</p>
  <button id='inclease'>+</button>
  <p id='count'>0</p>
  <script>
    var incleaseBtn = document.getElementById('inclease');
    var count = document.getElementById('count');
    // 카운트 상태를 유지하기 위한 전역 변수
    var counter = 0;
    function increase() {
      return ++counter;
    }
    incleaseBtn.onclick = function () {
      count.innerHTML = increase();
    };
  </script>
</body>
</html>
">
</iframe>

<p>위 코드는 잘 동작하지만 오류를 발생시킬 가능성을 내포하고 있는 좋지 않은 코드다. increase 함수는 호출되기 직전에 전역변수 counter의 값이 반드시 0이여야 제대로 동작한다. 하지만 변수 counter는 전역 변수이기 때문에 언제든지 누구나 접근할 수 있고 변경할 수 있다. 이는 의도치 않게 값이 변경될 수 있다는 것을 의미한다. 만약 누군가에 의해 의도치 않게 전역 변수 counter의 값이 변경됐다면 이는 오류로 이어진다. 변수 counter는 카운터를 관리하는 increase 함수가 관리하는 것이 바람직하다. 전역 변수 counter를 increase 함수의 지역 변수로 바꾸어 의도치 않은 상태 변경을 방지해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;지역 변수를 사용한 Counting&lt;/p&gt;</span><br><span class="line">  &lt;button id=<span class="string">&quot;inclease&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;p id=<span class="string">&quot;count&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> incleaseBtn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inclease&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> count = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;count&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 카운트 상태를 유지하기 위한 지역 변수</span></span><br><span class="line">      <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incleaseBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      count.innerHTML = increase();</span><br><span class="line">    &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="result-2"><a href="#result-2" class="headerlink" title="result"></a><em><strong>result</strong></em></h3><iframe width='100%' height='150px' srcdoc="
<!DOCTYPE html>
<html>
<body>
  <p>지역 변수를 사용한 Counting</p>
  <button id='inclease'>+</button>
  <p id='count'>0</p>
  <script>
    var incleaseBtn = document.getElementById('inclease');
    var count = document.getElementById('count');
    function increase() {
      // 카운트 상태를 유지하기 위한 지역 변수
      var counter = 0;
      return ++counter;
    }
    incleaseBtn.onclick = function () {
      count.innerHTML = increase();
    };
  </script>
</body>
</html>
">
</iframe>

<p>전역변수를 지역변수로 변경하여 의도치 않은 상태 변경은 방지했다. 하지만 increase 함수가 호출될 때마다 지역변수 counter를 0으로 초기화하기 때문에 언제나 1이 표시된다. 다시 말해 변경된 이전 상태를 기억하지 못한다. 이전 상태를 기억하도록 클로저를 사용하여 이 문제를 해결해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;p&gt;클로저를 사용한 Counting&lt;/p&gt;</span><br><span class="line">  &lt;button id=<span class="string">&quot;inclease&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;p id=<span class="string">&quot;count&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> incleaseBtn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inclease&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> count = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;count&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> increase = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">      <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 클로저를 반환</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;());</span><br><span class="line"></span><br><span class="line">    incleaseBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      count.innerHTML = increase();</span><br><span class="line">    &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="result-3"><a href="#result-3" class="headerlink" title="result"></a><em><strong>result</strong></em></h3><iframe width='100%' height='150px' srcdoc="
<!DOCTYPE html>
<html>
  <body>
  <p>클로저를 사용한 Counting</p>
  <button id='inclease'>+</button>
  <p id='count'>0</p>
  <script>
    var incleaseBtn = document.getElementById('inclease');
    var count = document.getElementById('count');
    var increase = (function () {
      // 카운트 상태를 유지하기 위한 자유 변수
      var counter = 0;
      // 클로저를 반환
      return function () {
        return ++counter;
      };
    }());
    incleaseBtn.onclick = function () {
      count.innerHTML = increase();
    };
  </script>
</body>
</html>
">
</iframe>

<p>스크립트가 실행되면 즉시실행함수(immediately-invoked function expression)가 호출되고 변수 increase에는 함수 function () { return ++counter; }가 할당된다. 이 함수는 자신이 생성됐을 때의 렉시컬 환경(Lexical environment)을 기억하는 클로저다. 즉시실행함수는 호출된 이후 소멸되지만 즉시실행함수가 반환한 함수는 변수 increase에 할당되어 inclease 버튼을 클릭하면 클릭 이벤트 핸들러 내부에서 호출된다. 이때 클로저인 이 함수는 자신이 선언됐을 때의 렉시컬 환경인 즉시실행함수의 스코프에 속한 지역변수 counter를 기억한다. 따라서 즉시실행함수의 변수 counter에 접근할 수 있고 변수 counter는 자신을 참조하는 함수가 소멸될 때가지 유지된다.</p>
<p>즉시실행함수는 한번만 실행되므로 increase가 호출될 때마다 변수 counter가 재차 초기화될 일은 없을 것이다. 변수 counter는 외부에서 직접 접근할 수 없는 private 변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없기 때문이 보다 안정적인 프로그래밍이 가능하다.</p>
<blockquote>
<p>변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 함수형 프로그래밍에서 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.</p>
</blockquote>
<p>아래는 함수형 프로그래밍에서 클로저를 활용하는 간단한 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수를 인자로 전달받고 함수를 반환하는 고차 함수</span></span><br><span class="line"><span class="comment">// 이 함수가 반환하는 함수는 클로저로서 카운트 상태를 유지하기 위한 자유 변수 counter을 기억한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 클로저를 반환</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter = predicate(counter);</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 보조 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 보조 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrease</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수로 함수를 생성한다.</span></span><br><span class="line"><span class="comment">// makeCounter 함수는 보조 함수를 인자로 전달받아 함수를 반환한다</span></span><br><span class="line"><span class="keyword">const</span> increaser = makeCounter(increase);</span><br><span class="line"><span class="built_in">console</span>.log(increaser()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(increaser()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.</span></span><br><span class="line"><span class="keyword">const</span> decreaser = makeCounter(decrease);</span><br><span class="line"><span class="built_in">console</span>.log(decreaser()); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(decreaser()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>

<p>함수 makeCounter는 보조 함수를 인자로 전달받고 함수를 반환하는 고차 함수이다. 함수 makeCounter가 반환하는 함수는 자신이 생성됐을 때의 렉시컬 환경인 함수 makeCounter의 스코프에 속한 변수 counter을 기억하는 클로저다. 함수 makeCounter는 인자로 전달받은 보조 함수를 합성하여 자신이 반환하는 함수의 동작을 변경할 수 있다. 이때 주의해야 할 것은 함수 makeCounter를 호출해 함수를 반환할 때 반환된 함수는 자신만의 독립된 렉시컬 환경을 갖는다는 것이다. 이는 함수를 호출하면 그때마다 새로운 렉시컬 환경이 생성되기 때문이다. 위 예제에서 변수 increaser와 변수 decreaser에 할당된 함수는 각각 자신만의 독립된 렉시컬 환경을 갖기 때문에 카운트를 유지하기 위한 자유 변수 counter를 공유하지 않아 카운터의 증감이 연동하지 않는다. 따라서 독립된 카운터가 아니라 연동하여 증감이 가능한 카운터를 만들려면 렉시컬 환경을 공유하는 클로저를 만들어야 한다.</p>
<h2 id="2-3-정보의-은닉"><a href="#2-3-정보의-은닉" class="headerlink" title="2.3 정보의 은닉"></a>2.3 정보의 은닉</h2><p>이번에는 생성자 함수 Counter를 생성하고 이를 통해 counter 객체를 만들어보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 카운트를 유지하기 위한 자유 변수</span></span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 클로저</span></span><br><span class="line">  <span class="built_in">this</span>.increase = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++counter;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 클로저</span></span><br><span class="line">  <span class="built_in">this</span>.decrease = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> --counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter.increase()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter.decrease()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>생성자 함수 Counter는 increase, decrease 메소드를 갖는 인스턴스를 생성한다. 이 메소드들은 모두 자신이 생성됐을 때의 렉시컬 환경인 생성자 함수 Counter의 스코프에 속한 변수 counter를 기억하는 클로저이며 렉시컬 환경을 공유한다. 생성자 함수가 함수가 생성한 객체의 메소드는 객체의 프로퍼티에만 접근할 수 있는 것이 아니며 자신이 기억하는 렉시컬 환경의 변수에도 접근할 수 있다.</p>
<p>이때 생성자 함수 Counter의 변수 counter는 this에 바인딩된 프로퍼티가 아니라 변수다. counter가 this에 바인딩된 프로퍼티라면 생성자 함수 Counter가 생성한 인스턴스를 통해 외부에서 접근이 가능한 public 프로퍼티가 되지만 생성자 함수 Counter 내에서 선언된 변수 counter는 생성자 함수 Counter 외부에서 접근할 수 없다. 하지만 생성자 함수 Counter가 생성한 인스턴스의 메소드인 increase, decrease는 클로저이기 때문에 자신이 생성됐을 때의 렉시컬 환경인 생성자 함수 Counter의 변수 counter에 접근할 수 있다. 이러한 클로저의 특징을 사용해 클래스 기반 언어의 private 키워드를 흉내낼 수 있다.</p>
<h2 id="2-4-자주-발생하는-실수"><a href="#2-4-자주-발생하는-실수" class="headerlink" title="2.4 자주 발생하는 실수"></a>2.4 자주 발생하는 실수</h2><p>아래의 예제는 클로저를 사용할 때 자주 발생할 수 있는 실수에 관련한 예제다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[j]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. for 문에서 사용한 변수 i는 전역 변수이기 때문이다. 이러한 문제를 클로저를 사용해 바르게 동작하는 코드로 만들어보자</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  arr[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id; <span class="comment">// ③</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;(i)); <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[j]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다.</p>
<p>② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다.</p>
<p>③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다.</p>
<p>위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>또는 함수형 프로그래밍 기법인 고차 함수를 사용하는 방법이 있다. 이 방법은 변수와 반복문의 사용을 억제할 수 있기 때문에 에플리케이션의 오류를 줄이고 가독성을 좋게 만든다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>).fill();</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">v, i, array</span>) =&gt;</span> array[i] = <span class="function">() =&gt;</span> i);</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="params">f</span> =&gt;</span> <span class="built_in">console</span>.log(f()));</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-closure">poiemaweb.com/js-closure</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-19T00:41:35.000Z" title="2021-8-19 9:41:35">2021-08-19</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-25T08:13:41.542Z" title="2021-8-25 17:13:41">2021-08-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">32분안에 읽기 (약 4759 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/19/js-day16-execution-context/">js-day16-execution-context</a></h1><div class="content"><h1 id="실행-컨텍스트와-자바스크립트의-동작-원리"><a href="#실행-컨텍스트와-자바스크립트의-동작-원리" class="headerlink" title="실행 컨텍스트와 자바스크립트의 동작 원리"></a>실행 컨텍스트와 자바스크립트의 동작 원리</h1><blockquote>
<p>이 포스팅의 내용은 ES3를 기반으로 하고 있다.</p>
</blockquote>
<h1 id="1-실행-컨텍스트"><a href="#1-실행-컨텍스트" class="headerlink" title="1. 실행 컨텍스트"></a>1. 실행 컨텍스트</h1><p>실행 컨텍스트(Execution Context)는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다. 실행 컨텍스트를 바로 이해하지 못하면 코드 독해가 어려워지며 디버깅도 매우 곤란해 질 것이다.</p>
<p>ECMAScript 스펙에 따르면 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 좀 더 쉽게 말하자면 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경 이라고 말할 수 있겠다. 여기서 말하는 실행 가능한 코드는 아래와 같다.</p>
<ul>
<li>전역 코드 : 전역 영역에 존재하는 코드</li>
<li>Eval 코드 : eval 함수로 실행되는 코드</li>
<li>함수 코드 : 함수 내에 존재하는 코드</li>
</ul>
<p>일반적으로 실행 가능한 코드는 전역 코드와 함수 내 코드이다.</p>
<ul>
<li>변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티</li>
<li>함수 선언</li>
<li>변수의 유효범위(Scope)</li>
<li>this</li>
</ul>
<p>이와 같이 실행에 필요한 정보를 형상화하고 구분하기 위해 자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 아래의 코드를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="string">&#x27;yyy&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="string">&#x27;zzz&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>위 코드를 실행하면 아래와 같이 실행 컨텍스트 스택(Stack)이 생성하고 소멸한다. 현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련없는 코드(예를 들어 다른 함수)가 실행되면 새로운 컨텍스트가 생성된다. 이 컨텍스트는 스택에 쌓이게 되고 컨트롤(제어권)이 이동한다.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>bar()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>-&gt;</td>
<td>foo()</td>
<td>-&gt;</td>
<td>foo()</td>
<td>-&gt;</td>
<td>foo()</td>
<td>-&gt;</td>
<td></td>
</tr>
<tr>
<td>global</td>
<td></td>
<td>global</td>
<td></td>
<td>global</td>
<td></td>
<td>global</td>
<td></td>
<td>global</td>
</tr>
</tbody></table>
<p>논리적 스택 구조를 가지는 실행 컨텍스트 스택</p>
<ol>
<li><p>컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 LIFO(Last In First Out, 후입 선출)의 구조를 가지는 나열 구조이다.</p>
</li>
<li><p>전역 코드(Global code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다.</p>
</li>
<li><p>함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며 직전에 실행된 코드 블록의 실행 컨텍스트 위에 쌓인다.</p>
</li>
<li><p>함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다.</p>
</li>
</ol>
<h1 id="2-실행-컨텍스트의-3가지-객체"><a href="#2-실행-컨텍스트의-3가지-객체" class="headerlink" title="2. 실행 컨텍스트의 3가지 객체"></a>2. 실행 컨텍스트의 3가지 객체</h1><p>실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 아래의 3가지 프로퍼티를 소유한다. </p>
<table>
<thead>
<tr>
<th>Execution context</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>variable object</td>
<td>{vars, function declarartions, arguments…}</td>
</tr>
<tr>
<td>Scope chain</td>
<td>[Variable object + all parent scopes]</td>
</tr>
<tr>
<td>thisValue</td>
<td>Context object</td>
</tr>
</tbody></table>
<h5 id="실행컨텍스트의-구조"><a href="#실행컨텍스트의-구조" class="headerlink" title="실행컨텍스트의 구조"></a>실행컨텍스트의 구조</h5><h2 id="2-1-Variable-Object-VO-변수객체"><a href="#2-1-Variable-Object-VO-변수객체" class="headerlink" title="2.1 Variable Object(VO / 변수객체)"></a>2.1 Variable Object(VO / 변수객체)</h2><p>실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체를 생성한다. 이를 Variable Object(VO / 변수 객체)라고 한다. Variable Object는 코드가 실행될 때 엔진에 의해 참조되며 코드에서는 접근할 수 없다.</p>
<p>Variable Object는 아래의 정보를 담는 객체이다.</p>
<ul>
<li>변수</li>
<li>매개변수(parameter)와 인수정보(arguments)</li>
<li>함수 선언(함수 표현식은 제외)</li>
</ul>
<p>Variable Object는 실행 컨텍스트의 프로퍼티이기 때문에 값을 갖는데 이 값은 다른 객체를 가리킨다. 그런데 전역 코드 실행시 생성되는 전역 컨텍스트의 경우와 함수를 실행할 때 생성되는 함수 컨텍스트의 경우, 가리키는 객체가 다르다. 이는 전역 코드와 함수의 내용이 다르기 때문이다. 예를 들어 전역 코드에는 매개변수가 없지만 함수에는 매개변수가 있다.</p>
<p>Variable Object가 가리키는 객체는 아래와 같다.</p>
<blockquote>
<p><strong>전역 컨텍스트의 경우</strong><br>Variable Object는 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object / GO)를 가리킨다. 전역 객체는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유한다.</p>
</blockquote>
<blockquote>
<p><strong>함수 컨텍스트의 경우</strong><br>Variable Object는 Activation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다.</p>
</blockquote>
<h2 id="2-2-Scope-Chain-SC"><a href="#2-2-Scope-Chain-SC" class="headerlink" title="2.2 Scope Chain (SC)"></a>2.2 Scope Chain (SC)</h2><p>스코프 체인(Scope Chain)은 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있다. 다시 말해, 스코프 체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 전역 객체(GO) 또는 활성 객체(AO)의 리스트를 가리킨다.</p>
<p>현재 실행 컨텍스트의 활성 객체(AO)를 선두로 하여 순차적으로 상위 컨텍스트의 활성 객체(AO)를 가리키며 마지막 리스트는 전역 객체(GO)를 가리킨다.</p>
<blockquote>
<p>스코프 체인은 식별자 중에서 객체(전역 객체 제외)의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘이다.<br>식별자 중에서 변수가 아닌 객체의 프로퍼티(물론 메소드도 포함된다)를 검색하는 메커니즘은 프로토타입 체인(Prototype Chain)이다.</p>
</blockquote>
<p>엔진은 스코프 체인을 통해 렉시컬 스코프를 파악한다. 함수가 중첩 상태일 때 하위함수 내에서 상위함수의 스코프와 전역 스코프까지 참조할 수 있는데 이것는 스코프 체인을 검색을 통해 가능하다. 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인에 포함된다. 함수 실행중에 변수를 만나면 그 변수를 우선 현재 Scope, 즉 Activation Object에서 검색해보고, 만약 검색에 실패하면 스코프 체인에 담겨진 순서대로 그 검색을 이어가게 되는 것이다. 이것이 스코프 체인이라고 불리는 이유이다.</p>
<p>예를 들어 함수 내의 코드에서 변수를 참조하면 엔진은 스코프 체인의 첫번째 리스트가 가리키는 AO에 접근하여 변수를 검색한다. 만일 검색에 실패하면 다음 리스트가 가리키는 Activation Object(또는 전역 객체)를 검색한다. 이와 같이 순차적으로 스코프 체인에서 변수를 검색하는데 결국 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 Reference 에러를 발생시킨다. 스코프 체인은 함수의 감추인 프로퍼티인 [[Scope]]로 참조할 수 있다.</p>
<h2 id="2-3-this-value"><a href="#2-3-this-value" class="headerlink" title="2.3 this value"></a>2.3 this value</h2><p>this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.</p>
<h1 id="3-실행-컨텍스트의-생성-과정"><a href="#3-실행-컨텍스트의-생성-과정" class="headerlink" title="3. 실행 컨텍스트의 생성 과정"></a>3. 실행 컨텍스트의 생성 과정</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="string">&#x27;yyy&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="string">&#x27;zzz&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h2 id="3-1-전역-코드에서의-진입"><a href="#3-1-전역-코드에서의-진입" class="headerlink" title="3.1 전역 코드에서의 진입"></a>3.1 전역 코드에서의 진입</h2><p>컨트롤이 실행 컨텍스트에 진입하기 이전에 유일한 전역 객체(Global Object)가 생성된다. 전역 객체는 단일 사본으로 존재하며 이 객체의 프로퍼티는 코드의 어떠한 곳에서도 접근할 수 있다. 초기 상태의 전역 객체에는 빌트인 객체(Math, String, Array 등)와 BOM, DOM이 설정되어 있다.</p>
<p>전역 객체가 생성된 이후, 전역 코드로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다.</p>
<p>그리고 이후 이 실행 컨텍스트를 바탕으로 이하의 처리가 실행된다.</p>
<blockquote>
<ol>
<li>스코프 체인의 생성과 초기화</li>
<li>Variable Instantiation(변수 객체화) 실행</li>
<li>this value 결정</li>
</ol>
</blockquote>
<h3 id="3-1-1-스코프-체인의-생성과-초기화"><a href="#3-1-1-스코프-체인의-생성과-초기화" class="headerlink" title="3.1.1 스코프 체인의 생성과 초기화"></a>3.1.1 스코프 체인의 생성과 초기화</h3><p>실행 컨텍스트가 생성된 이후 가장 먼저 스코프 체인의 생성과 초기화가 실행된다. 이때 스코프 체인은 전역 객체의 레퍼런스를 포함하는 리스트가 된다.</p>
<h3 id="3-1-2-Variable-Instantiation-변수-객체화-실행"><a href="#3-1-2-Variable-Instantiation-변수-객체화-실행" class="headerlink" title="3.1.2 Variable Instantiation(변수 객체화) 실행"></a>3.1.2 Variable Instantiation(변수 객체화) 실행</h3><p>스코프 체인의 생성과 초기화가 종료하면 변수 객체화(Variable Instantiation)가 실행된다.</p>
<p>Variable Instantiation은 Variable Object에 프로퍼티와 값을 추가하는 것을 의미한다. 변수 객체화라고 번역하기도 하는데 이는 변수, 매개변수와 인수 정보(arguments), 함수 선언을 Variable Object에 추가하여 객체화하기 때문이다.</p>
<p>전역 코드의 경우, Variable Object는 Global Object를 가리킨다.</p>
<p>Variable Instantiation(변수 객체화)는 아래의 순서로 Variable Object에 프로퍼티와 값을 set한다. (반드시 1→2→3 순서로 실행된다.)</p>
<blockquote>
<ol>
<li>(Function Code인 경우) 매개변수(parameter)가 Variable Object의 프로퍼티로, 인수(argument)가 값으로 설정된다.</li>
<li>대상 코드 내의 함수 선언(함수 표현식 제외)을 대상으로 함수명이 Variable Object의 프로퍼티로, 생성된 함수 객체가 값으로 설정된다.(함수 호이스팅)</li>
<li>대상 코드 내의 변수 선언을 대상으로 변수명이 Variable Object의 프로퍼티로, undefined가 값으로 설정된다.(변수 호이스팅)</li>
</ol>
</blockquote>
<p>위 예제 코드를 보면 전역 코드에 변수 x와 함수 foo(매개변수 없음)가 선언되었다. Variable Instantiation의 실행 순서 상, 우선 2. 함수 foo의 선언이 처리되고(함수 코드가 아닌 전역 코드이기 때문에 1. 매개변수 처리는 실행되지 않는다.) 그 후 3. 변수 x의 선언이 처리된다.</p>
<h3 id="3-1-2-1-함수-foo의-선언-처리"><a href="#3-1-2-1-함수-foo의-선언-처리" class="headerlink" title="3.1.2.1 함수 foo의 선언 처리"></a>3.1.2.1 함수 foo의 선언 처리</h3><p>함수 선언은 Variable Instantiation 실행 순서 2.와 같이 선언된 함수명 foo가 Variable Object(전역 코드인 경우 Global Object)의 프로퍼티로, 생성된 함수 객체가 값으로 설정된다.</p>
<p>생성된 함수 객체는 [[Scopes]] 프로퍼티를 가지게 된다. [[Scopes]] 프로퍼티는 함수 객체만이 소유하는 내부 프로퍼티(Internal Property)로서 함수 객체가 실행되는 환경을 가리킨다. 따라서 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정한다. 내부 함수의 [[Scopes]] 프로퍼티는 자신의 실행 환경(Lexical Enviroment)과 자신을 포함하는 외부 함수의 실행 환경과 전역 객체를 가리키는데 이때 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[Scopes]] 프로퍼티가 가리키는 외부 함수의 실행 환경(Activation object)은 소멸하지 않고 참조할 수 있다. 이것이 <strong>클로저</strong>이다.</p>
<p>지금까지 살펴본 실행 컨텍스트는 아직 코드가 실행되기 이전이다. 하지만 스코프 체인이 가리키는 변수 객체(VO)에 이미 함수가 등록되어 있으므로 이후 코드를 실행할 때 함수선언식 이전에 함수를 호출할 수 있게 되었다.</p>
<p>이때 알 수 있는 것은 함수선언식의 경우, 변수 객체(VO)에 함수표현식과 동일하게 함수명을 프로퍼티로 함수 객체를 할당한다는 것이다. 단, 함수선언식은 변수 객체(VO)에 함수명을 프로퍼티로 추가하고 즉시 함수 객체를 즉시 할당하지만 함수 표현식은 일반 변수의 방식을 따른다. 따라서 함수선언식의 경우, 선언문 이전에 함수를 호출할 수 있다. 이러한 현상을 함수 호이스팅(Function Hoisting)이라 한다.</p>
<h3 id="3-1-2-2-변수-x의-선언-처리"><a href="#3-1-2-2-변수-x의-선언-처리" class="headerlink" title="3.1.2.2 변수 x의 선언 처리"></a>3.1.2.2 변수 x의 선언 처리</h3><p>변수 선언은 Variable Instantiation 실행 순서 3.과 같이 선언된 변수명( x )이 Variable Object의 프로퍼티로, undefined가 값으로 설정된다. 이것을 좀더 세분화 해보면 아래와 같다.</p>
<blockquote>
<p>선언 단계(Declaration phase)<br>변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조할 수 있는 대상이 된다.</p>
</blockquote>
<blockquote>
<p>초기화 단계(Initialization phase)<br>변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.</p>
</blockquote>
<blockquote>
<p>할당 단계(Assignment phase)<br>undefined로 초기화된 변수에 실제값을 할당한다.</p>
</blockquote>
<p>var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 다시 말해 스코프 체인이 가리키는 변수 객체에 변수가 등록되고 변수는 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라한다.</p>
<p>아직 변수 x는 ‘xxx’로 초기화되지 않았다. 이후 변수 할당문에 도달하면 비로소 값의 할당이 이루어진다.</p>
<h3 id="3-1-3-this-value-결정"><a href="#3-1-3-this-value-결정" class="headerlink" title="3.1.3 this value 결정"></a>3.1.3 this value 결정</h3><p>변수 선언 처리가 끝나면 다음은 this value가 결정된다. this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다가 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다. 전역 코드의 경우, this는 전역 객체를 가리킨다.</p>
<p>전역 컨텍스트(전역 코드)의 경우, Variable Object, 스코프 체인, this 값은 언제나 전역 객체이다.</p>
<h2 id="3-2-전역-코드의-실행"><a href="#3-2-전역-코드의-실행" class="headerlink" title="3.2 전역 코드의 실행"></a>3.2 전역 코드의 실행</h2><p>지금까지는 코드 실행 환경을 갖추기 위한 사전 준비였다. 코드의 실행은 지금부터 시작된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="string">&#x27;yyy&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="string">&#x27;zzz&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>위 예제를 보면 전역 변수 x에 문자열 ‘xxx’ 할당과 함수 foo의 호출이 실행된다.</p>
<h3 id="3-2-1-변수-값의-할당"><a href="#3-2-1-변수-값의-할당" class="headerlink" title="3.2.1 변수 값의 할당"></a>3.2.1 변수 값의 할당</h3><p>전역 변수 x에 문자열 ‘xxx’를 할당할 때, 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 Variable Object를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값(‘xxx’)을 할당한다.</p>
<h3 id="3-2-2-함수-foo의-실행"><a href="#3-2-2-함수-foo의-실행" class="headerlink" title="3.2.2 함수 foo의 실행"></a>3.2.2 함수 foo의 실행</h3><p>전역 코드의 함수 foo가 실행되기 시작하면 새로운 함수 실행 컨텍스트가 생성된다. 함수 foo의 실행 컨텍스트로 컨트롤이 이동하면 전역 코드의 경우와 마찬가지로 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순차적으로 실행된다.</p>
<p>단, 전역 코드와 다른 점은 이번 실행되는 코드는 함수 코드라는 것이다. 따라서 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정은 전역 코드의 룰이 아닌 함수 코드의 룰이 적용된다.</p>
<h3 id="3-2-2-1-스코프-체인의-생성과-초기화"><a href="#3-2-2-1-스코프-체인의-생성과-초기화" class="headerlink" title="3.2.2.1 스코프 체인의 생성과 초기화"></a>3.2.2.1 스코프 체인의 생성과 초기화</h3><p>함수 코드의 스코프 체인의 생성과 초기화는 우선 Activation Object에 대한 레퍼런스를 스코프 체인의 선두에 설정하는 것으로 시작된다.</p>
<p>Activation Object는 우선 arguments 프로퍼티의 초기화를 실행하고 그 후, Variable Instantiation가 실행된다. Activation Object는 스펙 상의 개념으로 프로그램이 Activation Object에 직접 접근할 수 없다. (Activation Object의 프로퍼티로의 접근은 가능하다)</p>
<p>그 후, Caller(전역 컨텍스트)의 Scope Chain이 참조하고 있는 객체가 스코프 체인에 push된다. 따라서, 이 경우 함수 foo를 실행한 직후 실행 컨텍스트의 스코프 체인은 Activation Object(함수 foo의 실행으로 만들어진 AO-1)과 전역 객체를 순차적으로 참조하게 된다.</p>
<h3 id="3-2-2-2-Variable-Instantiation-실행"><a href="#3-2-2-2-Variable-Instantiation-실행" class="headerlink" title="3.2.2.2 Variable Instantiation 실행"></a>3.2.2.2 Variable Instantiation 실행</h3><p>Function Code의 경우, 스코프 체인의 생성과 초기화에서 생성된 Activation Object를 Variable Object로서 Variable Instantiation가 실행된다. 이것을 제외하면 전역 코드의 경우와 같은 처리가 실행된다. 즉, 함수 객체를 Variable Object(AO-1)에 바인딩한다. (프로퍼티는 bar, 값은 새로 생성된 Function Object. bar function object의 [[Scope]] 프로퍼티 값은 AO-1과 Global Object를 참조하는 리스트）</p>
<p>변수 y를 Variable Object(AO-1)에 설정한다 이때 프로퍼티는 y, 값은 undefined이다.</p>
<h3 id="3-2-2-3-this-value-결정"><a href="#3-2-2-3-this-value-결정" class="headerlink" title="3.2.2.3 this value 결정"></a>3.2.2.3 this value 결정</h3><p>변수 선언 처리가 끝나면 다음은 this value가 결정된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.</p>
<p>내부 함수의 경우, this의 value는 전역 객체이다.</p>
<h2 id="3-3-foo-함수-코드의-실행"><a href="#3-3-foo-함수-코드의-실행" class="headerlink" title="3.3 foo 함수 코드의 실행"></a>3.3 foo 함수 코드의 실행</h2><p>이제 함수 foo의 코드 블록 내 구문이 실행된다. 위 예제를 보면 변수 y에 문자열 ‘yyy’의 할당과 함수 bar가 실행된다.</p>
<h3 id="3-3-1-변수-값의-할당"><a href="#3-3-1-변수-값의-할당" class="headerlink" title="3.3.1 변수 값의 할당"></a>3.3.1 변수 값의 할당</h3><p>지역 변수 y에 문자열 ‘yyy’를 할당할 때, 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 Variable Object를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값 ‘yyy’를 할당한다.</p>
<h3 id="3-3-2-함수-bar의-실행"><a href="#3-3-2-함수-bar의-실행" class="headerlink" title="3.3.2 함수 bar의 실행"></a>3.3.2 함수 bar의 실행</h3><p>함수 bar가 실행되기 시작하면 새로운 실행 컨텍스트이 생성된다.</p>
<p>이전 함수 foo의 실행 과정과 동일하게 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순차적으로 실행된다.</p>
<p>이 단계에서 console.log(x + y + z); 구문의 실행 결과는 xxxyyyzzz가 된다.</p>
<ul>
<li>x : AO-2에서 x 검색 실패 → AO-1에서 x 검색 실패 → GO에서 x 검색 성공 (값은 ‘xxx’)</li>
<li>y : AO-2에서 y 검색 실패 → AO-1에서 y 검색 성공 (값은 ‘yyy’)</li>
<li>z : AO-2에서 z 검색 성공 (값은 ‘zzz’)</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-execution-context">poiemaweb.com/js-execution-context</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-18T07:55:35.023Z" title="2021-8-18 16:55:35">2021-08-18</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-18T07:56:00.994Z" title="2021-8-18 16:56:00">2021-08-18</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">29분안에 읽기 (약 4354 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/18/js-day15-this/">js-day15-this</a></h1><div class="content"><h1 id="함수-호출-방식에-의해-결정되는-this"><a href="#함수-호출-방식에-의해-결정되는-this" class="headerlink" title="함수 호출 방식에 의해 결정되는 this"></a>함수 호출 방식에 의해 결정되는 this</h1><p>자바스크립트의 함수는 호출될 때, 매개변수로 전달 되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>자바스크립트의 this keyword는 Java와 같은익숙한 언어의 개념과 달라 개발자에게 혼란을 준다. </p>
<p>Java에서의 this는 인스턴스 자신(self)을 가리키는 참조변수이다. this가 객체 자신에 대한 참조 값을 가지고 있다는 뜻이다. 주로 매개변수와 객체 자신이 가지고 있는 멤버변수명이 같을 경우 이를 구분하기 위해서는 사용된다. 아래 Java 코드의 생성자 함수 내의 this.name은 멤버변수를 의미하며 name은 생성자 함수가 전달받은 매개변수를 의미한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Person &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 자바스크립트의 경우 Java와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 방식에 따라 this에 바인딩되는 객체가 달라진다.</p>
<h1 id="함수-호출-방식과-this-바인딩"><a href="#함수-호출-방식과-this-바인딩" class="headerlink" title="함수 호출 방식과 this 바인딩"></a>함수 호출 방식과 this 바인딩</h1><p>자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정된다. 다시말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결저오디는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. </p>
<blockquote>
<p>함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(Lexical scope)는 함수를 선언할 때 결정된다. this 바인딩과 혼동하지 않도록 주의하기 바란다. </p>
</blockquote>
<p>함수의 호출하는 방식은 아래와 같이 다양하다. </p>
<blockquote>
<ol>
<li>함수 호출</li>
<li>메소드 호출</li>
<li>생성자 함수 호출</li>
<li>apply/call/bind 호출</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 함수 호출</span></span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"><span class="comment">// window.foo();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 메소드 호출</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: foo &#125;;</span><br><span class="line">obj.foo(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 생성자 함수 호출</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> foo(); <span class="comment">// instance</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. apply/call/bind 호출</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123; <span class="attr">name</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">foo.call(bar);   <span class="comment">// bar</span></span><br><span class="line">foo.apply(bar);  <span class="comment">// bar</span></span><br><span class="line">foo.bind(bar)(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<h1 id="1-함수-호출"><a href="#1-함수-호출" class="headerlink" title="1. 함수 호출"></a>1. 함수 호출</h1><p>전역객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in browser console</span></span><br><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in Terminal</span></span><br><span class="line">node</span><br><span class="line"><span class="built_in">this</span> === <span class="built_in">global</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>전역객체는 전역 스코프(Global Scope)를 갖는 전역변수(Global variable)를 프로퍼티로 소유한다. 글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역 변수의 메소드이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ga = <span class="string">&#x27;Global variable&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ga);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ga);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;invoked!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.foo();</span><br></pre></td></tr></table></figure>

<p>기본적으로 this는 전역객체(Global Object)에 바인딩된다. 전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&#x27;s this: &quot;</span>,  <span class="built_in">this</span>);  <span class="comment">// window</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s this: &quot;</span>, <span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>또한 메소드의 내부함수일 경우에도 this는 전역객체에 바인딩 된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&#x27;s this: &quot;</span>,  <span class="built_in">this</span>);  <span class="comment">// obj</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&#x27;s this.value: &quot;</span>,  <span class="built_in">this</span>.value); <span class="comment">// 100</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s this: &quot;</span>,  <span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s this.value: &quot;</span>, <span class="built_in">this</span>.value); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>콜백함수의 경우에도 this는 전역객체에 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;callback&#x27;s this: &quot;</span>,  <span class="built_in">this</span>);  <span class="comment">// window</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;callback&#x27;s this.value: &quot;</span>,  <span class="built_in">this</span>.value); <span class="comment">// 1</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 this는 전역객체를 바인딩한다. 더글라스 크락포드는 “이것은 설계 단계의 결함으로 메소드가 내부함수를 사용하여 자신의 작업을 돕게 할 수 없다는 것을 의미한다” 라고 말한다. 내부함수의 this가 전역객체를 참조하는 것을 회피방법은 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;  <span class="comment">// Workaround : this === obj</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&#x27;s this: &quot;</span>,  <span class="built_in">this</span>);  <span class="comment">// obj</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&#x27;s this.value: &quot;</span>,  <span class="built_in">this</span>.value); <span class="comment">// 100</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s this: &quot;</span>,  <span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s this.value: &quot;</span>, <span class="built_in">this</span>.value); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s that: &quot;</span>,  that); <span class="comment">// obj</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s that.value: &quot;</span>, that.value); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>위 방법 이외에도 자바스크립트는 this를 명시적으로 바인딩할 수 있는 apply, call, bind 메소드를 제공한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&#x27;s this: &quot;</span>,  <span class="built_in">this</span>);  <span class="comment">// obj</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&#x27;s this.value: &quot;</span>,  <span class="built_in">this</span>.value); <span class="comment">// 100</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s this: &quot;</span>,  <span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s this.value: &quot;</span>, <span class="built_in">this</span>.value); <span class="comment">// 100</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;bar&#x27;s arguments: &quot;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bar.apply(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">    bar.call(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    bar.bind(obj)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<h1 id="2-메소드-호출"><a href="#2-메소드-호출" class="headerlink" title="2. 메소드 호출"></a>2. 메소드 호출</h1><p>함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Kim&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.sayName = obj1.sayName;</span><br><span class="line"></span><br><span class="line">obj1.sayName();</span><br><span class="line">obj2.sayName();</span><br></pre></td></tr></table></figure>

<p>프로토타입 객체도 메소드를 가실 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me.getName());</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.getName());</span><br></pre></td></tr></table></figure>

<h1 id="3-생성자-함수-호출"><a href="#3-생성자-함수-호출" class="headerlink" title="3. 생성자 함수 호출"></a>3. 생성자 함수 호출</h1><p>자바스크립트의 생성자 함수는 말 그대로 객체를 생성하는 역할을 한다. 하지만 자바와 같은 객체지향 언어의 생성자 함수와는 다르게 그 형식이 정해져 있는 것이 아니라 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. </p>
<p>이는 반대로 생각하면 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출 하면 생성자 함수처럼 동작할 수 있다. 따라서 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼란을 방지하려는 노력을 한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// Person&amp;nbsp;&#123;name: &quot;Lee&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수로 동작하지 않는다.</span></span><br><span class="line"><span class="keyword">var</span> you = Person(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(you); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>new 연산자와 함께 생성자 함수를 호출하면 this 바인딩이 메소드나 함수 호출 때와는 다르게 동작한다.</p>
<h2 id="3-1-생성자-함수-동작-방식"><a href="#3-1-생성자-함수-동작-방식" class="headerlink" title="3.1 생성자 함수 동작 방식"></a>3.1 생성자 함수 동작 방식</h2><p>new 연산자와 함께 생성자 함수를 호출하면 다음과 같은 수순으로 동작한다. </p>
<blockquote>
<ol>
<li><strong>빈 객체 생성 및 this 바인딩</strong><br>생성자 함수의 코드가 실행되기 전 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다. 그리고 생성된 빈 객체는 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. </li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>this를 통한 프로퍼티 생성</strong><br>생성자 함수의 코드가 실행되기 전 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다. 그리고 생성된 빈 객체는 생서자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다. </li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>생성된 객체 반환</strong></li>
</ol>
<ul>
<li>반환문이 없는 경우, this에 바인딩된 새로 생성한 객체가 반환된다. 명시적으로 this를 반환하여도 결과는 같다. </li>
<li>반환문이 this가 아닌 다른 객체를 명시적으로 반환하는 경우, this가 아닌 해당 객체가 반환된다. 이때 this를 반환하지 않은 함수는 생성자 함수로서의 역할을 수행하지 못한다. 따라서 생성자 함수는 반환문을 명시적으로 사용하지 않는다. </li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 코드 실행 전 -------- 1</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;  <span class="comment">// --------- 2</span></span><br><span class="line">  <span class="comment">// 생성된 함수 반환 -------------- 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me.name);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-객체-리터럴-방식과-생성자-함수-방식의-차이"><a href="#3-2-객체-리터럴-방식과-생성자-함수-방식의-차이" class="headerlink" title="3.2 객체 리터럴 방식과 생성자 함수 방식의 차이"></a>3.2 객체 리터럴 방식과 생성자 함수 방식의 차이</h2><p>객체 리터럴 방식과 생성자 함수의 차이를 비교해 보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴 방식</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수 방식</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me  = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(me);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(you);</span><br></pre></td></tr></table></figure>

<p>객체 리터럴 방식과 생성자 함수 방식의 차이는 프로토타입 객체([[Prototype]])에 있다.</p>
<ul>
<li><p>객체 리터럴방식의 경우, 생성된 객체의 프로토타입 객체는 Object.prototype이다. </p>
</li>
<li><p>생성자 함수 방식의 경우, 생성된 객체의 프로토타입 객체는 Person.prototype이다. </p>
</li>
</ul>
<h2 id="3-3-생성자-함수에-new-연산자를-붙이지-않고-호출할-경우"><a href="#3-3-생성자-함수에-new-연산자를-붙이지-않고-호출할-경우" class="headerlink" title="3.3 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우"></a>3.3 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우</h2><p><strong>일반함수와 생성자 함수에 특별한 형식적 차이는 없으며 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.</strong></p>
<p>그러나 객체 생성 목적으로 작성한 생성자 함수를 new 없이 호출하거나 일반함수에 new를 붙여 호출하면 오류가 발생할 수 있다. 일반함수와 생성자 함수의 호출 시 this 바인딩 방식이 다르기 때문이다.</p>
<p>일반 함수를 호출하면 this는 전역객체에 바인딩되지만 new 연산자와 함께 생성자 함수를 호출하면 this는 생성자 함수가 암묵적으로 생성한 빈 객체에 바인딩된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// new없이 호출하는 경우, 전역객체에 name 프로퍼티를 추가</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 함수로서 호출되었기 때문에 객체를 암묵적으로 생성하여 반환하지 않는다.</span></span><br><span class="line"><span class="comment">// 일반 함수의 this는 전역객체를 가리킨다.</span></span><br><span class="line"><span class="keyword">var</span> me = Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>

<p>생성자 함수를 new 없이 호출한 경우, 함수 Person 내부의 this는 전역객체를 가리키므로 name은 전역변수(window)에 바인딩된다. 또한 new와 함께 생성자 함수를 호출하는 경우에 암묵적으로 반환하던 this도 반환하지 않으며, 반환문이 없으므로 undefined를 반환하게 된다.</p>
<p>일반함수와 생성자 함수에 특별한 형식적 차이는 없기 때문에 일반적으로 생성자 함수명은 첫문자를 대문자로 기술하여 혼란을 방지하려는 노력을 한다. 그러나 이러한 규칙을 사용한다 하더라도 실수는 발생할 수 있다.</p>
<p>이러한 위험성을 회피하기 위해 사용되는 패턴(Scope-Safe Constructor)은 다음과 같다. 이 패턴은 대부분의 라이브러리에서 광범위하게 사용된다.</p>
<p>참고로 대부분의 빌트인 생성자(Object, Regex, Array 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다.</p>
<p>다시 말하지만 new 연산자와 함께 생성자 함수를 호출하는 경우, 생성자 함수 내부의 this는 생성자 함수에 의해 생성된 인스턴스를 가리킨다. 따라서 아래 A 함수가 new 연산자와 함께 생성자 함수로써 호출되면 A 함수 내부의 this는 A 생성자 함수에 의해 생성된 인스턴스를 가리킨다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scope-Safe Constructor Pattern</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈객체를 생성하고 this에 바인딩한다.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  this가 호출된 함수(arguments.callee, 본 예제의 경우 A)의 인스턴스가 아니면 new 연산자를 사용하지 않은 것이므로 이 경우 new와 함께 생성자 함수를 호출하여 인스턴스를 반환한다.</span></span><br><span class="line"><span class="comment">  arguments.callee는 호출된 함수의 이름을 나타낸다. 이 예제의 경우 A로 표기하여도 문제없이 동작하지만 특정함수의 이름과 의존성을 없애기 위해서 arguments.callee를 사용하는 것이 좋다.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">arguments</span>.callee(arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로퍼티 생성과 값의 할당</span></span><br><span class="line">  <span class="built_in">this</span>.value = arg ? arg : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> b = A(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.value);</span><br><span class="line"><span class="built_in">console</span>.log(b.value);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>callee는 arguments 객체의 프로퍼티로서 함수 바디 내에서 현재 실행 중인 함수를 참조할 때 사용한다. 다시 말해, 함수 바디 내에서 현재 실행 중인 함수의 이름을 반환한다.</p>
</blockquote>
<h1 id="4-apply-call-bind-호출"><a href="#4-apply-call-bind-호출" class="headerlink" title="4. apply/call/bind 호출"></a>4. apply/call/bind 호출</h1><p>this에 바인딩될 객체는 함수 호출 패턴에 의해 결정된다. 이는 자바스크립트 엔진이 수행하는 것이다. 이러한 자바스크립트 엔진의 암묵적 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인딩하는 방법도 제공된다. 이것을 가능하게 하는 것이 Function.prototype.apply, Function.prototype.call 메소드이다.</p>
<p>이 메소드들은 모든 함수 객체의 프로토타입 객체인 Function.prototype 객체의 메소드이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisArg, [argsArray])</span><br><span class="line"></span><br><span class="line"><span class="comment">// thisArg: 함수 내부의 this에 바인딩할 객체</span></span><br><span class="line"><span class="comment">// argsArray: 함수에 전달할 argument의 배열</span></span><br></pre></td></tr></table></figure>

<p>기억해야 할 것은 apply() 메소드를 호출하는 주체는 함수이며 apply() 메소드는 this를 특정 객체에 바인딩할 뿐 본질적인 기능은 함수 호출이라는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply 메소드는 생성자함수 Person을 호출한다. 이때 this에 객체 foo를 바인딩한다.</span></span><br><span class="line">Person.apply(foo, [<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// &#123; name: &#x27;name&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>빈 객체 foo를 apply() 메소드의 첫번째 매개변수에, argument의 배열을 두번째 매개변수에 전달하면서 Person 함수를 호출하였다. 이때 Person 함수의 this는 foo 객체가 된다. Person 함수는 this의 name 프로퍼티에 매개변수 name에 할당된 인수를 할당하는데 this에 바인딩된 foo 객체에는 name 프로퍼티가 없으므로 name 프로퍼티가 동적 추가되고 값이 할당된다.</p>
<p>apply() 메소드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우이다. arguments 객체는 배열이 아니기 때문에 slice() 같은 배열의 메소드를 사용할 수 없으나 apply() 메소드를 이용하면 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertArgsToArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments 객체를 배열로 변환</span></span><br><span class="line">  <span class="comment">// slice: 배열의 특정 부분에 대한 복사본을 생성한다.</span></span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>); <span class="comment">// arguments.slice</span></span><br><span class="line">  <span class="comment">// var arr = [].slice.apply(arguments);</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convertArgsToArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>Array.prototype.slice.apply(arguments)는 “Array.prototype.slice() 메소드를 호출하라. 단 this는 arguments 객체로 바인딩하라”는 의미가 된다. 결국 Array.prototype.slice() 메소드를 arguments 객체 자신의 메소드인 것처럼 arguments.slice()와 같은 형태로 호출하라는 것이다.</p>
<p>call() 메소드의 경우, apply()와 기능은 같지만 apply()의 두번째 인자에서 배열 형태로 넘긴 것을 각각 하나의 인자로 넘긴다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.apply(foo, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">Person.call(foo, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>apply()와 call() 메소드는 콜백 함수의 this를 위해서 사용되기도 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> callback == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// --------- 1</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// --------- 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line">p.doSomething(foo);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>1의 시점에서 this는 Person 객체이다. 그러나 2의 시점에서 this는 전역 객체 window를 가리킨다. 콜백함수를 호출하는 외부 함수 내부의 this와 콜백함수 내부의 this가 상이하기 때문에 문맥상 문제가 발생한다. 따라서 콜백함수 내부의 this를 콜백함수를 호출하는 함수 내부의 this와 일치시켜 주어야 하는 번거로움이 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.doSomething = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    callback.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line">p.doSomething(foo);  <span class="comment">// &#x27;Lee&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Function.prototype.bind는 함수에 인자로 전달한 this가 바인딩된 새로운 함수를 리턴한다. 즉, Function.prototype.bind는 Function.prototype.apply, Function.prototype.call 메소드와 같이 함수를 실행하지 않기 때문에 명시적으로 함수를 호출할 필요가 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.doSomething = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// callback.call(this);</span></span><br><span class="line">    <span class="comment">// this가 바인딩된 새로운 함수를 호출</span></span><br><span class="line">    callback.bind(<span class="built_in">this</span>)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;#&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line">p.doSomething(foo);  <span class="comment">// &#x27;Lee&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-this">poiemaweb.com/js-this</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-11T02:31:23.933Z" title="2021-8-11 11:31:23">2021-08-11</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-11T03:00:28.899Z" title="2021-8-11 12:00:28">2021-08-11</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">11분안에 읽기 (약 1642 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/11/js-day13-strictmode/">js-day13-strictmode</a></h1><div class="content"><h1 id="1-strict-mode란"><a href="#1-strict-mode란" class="headerlink" title="1. strict mode란?"></a>1. strict mode란?</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>foo 함수 내에서 선언하지 않은 변수 x에 값 10을 할당하였다. 이때 변수 x를 찾아야 x에 값을 할당할 수 있기 때문에 자바스크립트 엔진은 변수 x가 어디에서 선언되었는지 스코프 체인을 통해 검색하기 시작한다. </p>
<p>자바스크립트 엔진은 먼저 foo 함수의 스코프에서 변수 x의 선언을 검색한다. foo 함수의 스코프에는 변수 x의 선언이 없으므로 검색에 실패할 것이고, 자바스크립트 엔진은 변수 x를 검색하기 위해 foo함수 컨텍스트의 상위 스코프(위 예제의 경우, 전역 스코프)에서 변수 x의 선언을 검색한다. </p>
<p>전역 스코프에도 변수 x의 선언이 존재하지 않기 때문에 ReferenceError를 throw할 것 같지만 자바스크립트 엔진은 암묵적으로 전역 객체에 프로퍼티 x를 동적 생성한다. 결국 식별자 x는 전역 변수가 된다. 이렇게 전역 변수가 된 변수를 <strong>암묵적 전역 변수(implicit global)</strong> 라 한다.</p>
<p>개발자의 의도와는 상관없이 자바스크립트 엔진이 생성한 암묵적 전역 변수는 오류를 발생시키는 원인이 될 가능성이 크다. 따라서 반드시 var, let, const 키워드를 사용하여 변수를 선언한 다음 변수를 사용해야 한다.</p>
<p>하지만, 오타나 문법 지식의 미비로 인한 실수는 언제나 발생하는 것이다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 보다 근본적인 접근이 필요하다. 다시 말해, 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발을 하는 것이 보다 근본적인 해결책이라고 할 수 있다.</p>
<p>이를 지원하기 위해 ES5부터 strict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대한 명시적인 에러를 발생시킨다. </p>
<p>ESLint와 같은 린트 도구를 사용하여도 strict mode와 유사한 효과를 얻을 수 있다. 린트 도구는 정적 분석(static analysis) 기능을 통해 소스 코드를 실행하기 전에 소스 코드를 스캔하여 문법적 오류만이 아니라 잠재적 오류까지 찾아내고 오류의 이유를 리포팅해주는 유용한 도구이다.</p>
<p>또한 strict mode가 제한하는 오류는 물론 코딩 컨벤션을 설정 파일 형태로 정의하고 강제할 수 있기 때문에 보다 강력한 효과를 얻을 수 있다. </p>
<p>strict mode의 적용 방법과 strict mode가 발생시키는 에러에 대해 간략히 살펴보도록 하자.</p>
<h1 id="2-strict-mode의-적용"><a href="#2-strict-mode의-적용" class="headerlink" title="2. strict mode의 적용"></a>2. strict mode의 적용</h1><p>strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 ‘use strict’; 를 추가한다. </p>
<p>전역의 선두에 추가하면스크립트 전체에 strict mode가 적용된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역에 strict mode의 적용하는 것은 바람직하지 않다!</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>; <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>함수 몸체의 선두에 추가하면 해당 함수와 중첩된 내부 함수에 strict mode가 적용된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 단위로 strict mode 적용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">10</span>; <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>코드의 선두에 strict mode를 위치시키지 않으면 제대로 동작하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>; <span class="comment">// 에러를 발생시키지 않는다.</span></span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h1 id="3-전역에-strict-mode를-적용하는-것은-피하자"><a href="#3-전역에-strict-mode를-적용하는-것은-피하자" class="headerlink" title="3. 전역에 strict mode를 적용하는 것은 피하자."></a>3. 전역에 strict mode를 적용하는 것은 피하자.</h1><p>전역에 적용한 strict mode는 스크립트 단위로 적용된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">    &#x27;use strict&#x27;</span>;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    x = <span class="number">1</span>; <span class="comment">// 에러가 발생하지 않는다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">    &#x27;use strict&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    y = <span class="number">1</span>; <span class="comment">// ReferenceError: y is not defined</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(y);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>위 예제와 같이 스크립트 단위로 적용된 strict mode는 다른 스크립트에 영향을 주지 않고 자신의 스크립트에 한정되어 적용된다.</p>
<p>하지만 strict mode 스크립트와 non-strict mode 스크립트를 혼용하는 것은 오류를 발생시킬 수 있다. 특히 외부 서드 파티 라이브러리를 사용하는 경우, 라이브러리가 non-strict mode일 경우도 있기 때문에 전역에 strict mode를 적용하는 것은 바람직하지 않다. 이러한 경우, 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시실행 함수에 strict mode 적용</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>따라서 strict mode는 즉시실행함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.</p>
<h1 id="5-strict-mode가-발생시키는-에러"><a href="#5-strict-mode가-발생시키는-에러" class="headerlink" title="5. strict mode가 발생시키는 에러"></a>5. strict mode가 발생시키는 에러</h1><p>다음은 strict mode를 적용했을 때의 에러가 발생하는 대표적인 사례이다. </p>
<h2 id="5-1-암묵적-전역-변수"><a href="#5-1-암묵적-전역-변수" class="headerlink" title="5.1 암묵적 전역 변수"></a>5.1 암묵적 전역 변수</h2><p>선언하지 않은 변수를 참조하면 ReferenceError가 발생한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h2 id="5-2-변수-함수-매개변수의-삭제"><a href="#5-2-변수-함수-매개변수의-삭제" class="headerlink" title="5.2 변수, 함수, 매개변수의 삭제"></a>5.2 변수, 함수, 매개변수의 삭제</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">delete</span> x;</span><br><span class="line">  <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> foo;</span><br><span class="line">  <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h2 id="5-3-매개변수-이름의-중복"><a href="#5-3-매개변수-이름의-중복" class="headerlink" title="5.3 매개변수 이름의 중복"></a>5.3 매개변수 이름의 중복</h2><p>중복된 함수 파라미터 이름을 사용하면 SyntaxError가 발생한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//SyntaxError: Duplicate parameter name not allowed in this context</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h2 id="5-4-with-문의-사용"><a href="#5-4-with-문의-사용" class="headerlink" title="5.4 with 문의 사용"></a>5.4 with 문의 사용</h2><p>with 문을 사용하면 SyntaxError가 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SyntaxError: Strict mode code may not include a with statement</span></span><br><span class="line">  <span class="function"><span class="title">with</span>(<span class="params">&#123; x: <span class="number">1</span> &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h2 id="5-5-일반-함수의-this"><a href="#5-5-일반-함수의-this" class="headerlink" title="5.5 일반 함수의 this"></a>5.5 일반 함수의 this</h2><p>strict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다. 이때 에러는 발생하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// Foo</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h1 id="6-브라우저-호환성"><a href="#6-브라우저-호환성" class="headerlink" title="6. 브라우저 호환성"></a>6. 브라우저 호환성</h1><p>IE 9이하는 지원하지 않는다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-strict-mode">poiemaweb.com/js-strict-mode</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-09T00:57:47.164Z" title="2021-8-9 9:57:47">2021-08-09</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-08-10T02:12:35.560Z" title="2021-8-10 11:12:35">2021-08-10</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">24분안에 읽기 (약 3545 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/09/js-day12-scope/">js-day12-scope</a></h1><div class="content"><h1 id="1-스코프란"><a href="#1-스코프란" class="headerlink" title="1. 스코프란?"></a>1. 스코프란?</h1><p>스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 개념으로 확실한 이해가 필요하다. 먼저 아래 예제의 실행 결과에 대해 생각해보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;function scope&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ?</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>이름이 같은 변수 x가 중복 선언되었다. 전역에서 변수 x를 참조할 때, 그리고 함수 foo 내부에서 변수 x를 참조할 때 이름이 중복된 2개의 변수 중 어떤 변수를 참조해야 하는가? 자바스크립트는 어떻게 변수를 식별하는 것일까?</p>
<p><strong>스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. 자바스크립트는 이 규칙대로 식별자를 찾는다.</strong></p>
<p>프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며 이것으로 프로그램의 상태를 관리할 수 있다. 변수는 전역 또는 코드 블록(if, for, while, try/catch 등)이나 함수 내에 선언하며 코드 블록이나 함수는 중첩될 수 있다. 식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 갖는다.</p>
<p>위 예제에서 전역에 선언된 변수 x는 어디에든 참조할 수 있다. 하지만 함수 foo 내에서 선언된 변수 x는 함수 foo 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없다. 이러한 규칙을 스코프라고 한다.</p>
<h1 id="2-스코프의-구분"><a href="#2-스코프의-구분" class="headerlink" title="2. 스코프의 구분"></a>2. 스코프의 구분</h1><p>자바스크립트에서 스코프를 구분해보면 다음과 같이 2가지로 나눌 수 있다. </p>
<blockquote>
<p><strong>전역 스코프(Global scope)</strong><br>코드 어디에서든지 참조할 수 있다.</p>
</blockquote>
<blockquote>
<p><strong>지역 스코프(Local scope or Function-level scope)</strong><br>함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.</p>
</blockquote>
<p>모든 변수는 스코프를 갖는다. 변수의 관점에서 스코프를 구분하면 다음과 같이 2가지로 나눌 수 있다.</p>
<blockquote>
<p><strong>전역변수(Global variable)</strong><br>전역에서 선언된 변수이며 어디에든 참조할 수 있다.</p>
</blockquote>
<blockquote>
<p><strong>지역변수(Local variable)</strong><br>지역(함수)내에서 선언된 변수이며 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.</p>
</blockquote>
<p>변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가지게 된다. 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다. </p>
<p>전역 스코프를 갖는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다. </p>
<h1 id="3-자바스크립트-스코프의-특징"><a href="#3-자바스크립트-스코프의-특징" class="headerlink" title="3. 자바스크립트 스코프의 특징"></a>3. 자바스크립트 스코프의 특징</h1><p>자바스크립트의 스코프는 타 언어와는 다른 특징을 가지고 있다. </p>
<p>대부분의 C-family language는 블록 레벨 스코프(block-level scope)를 따른다. 블록 레벨 스코프란 코드 블록({…})내에서 유효한 스코프를 의미한다. 여기서 “유효하다”라는 것은 “참조(접근)할 수 있다”라는 뜻이다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// block-level scope</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x); <span class="comment">// use of undeclared identifier &#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 C언어 코드를 보면 if문 내에서 선언된 변수 x는 if문 코드 블록 내에서만 유효하다. 즉, if문 코드 블록 밖에서는 참조가 불가능하다. </p>
<p>하지만 자바스크립트는 <strong>함수 레벨 스코프</strong>를 따른다. 함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것이다.</p>
<p>단, ECMAScript 6에서 도입된 let keyword를 사용하면 <strong>블록 레벨 스코프</strong>를 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(y);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h1 id="4-전역-스코프-Global-scope"><a href="#4-전역-스코프-Global-scope" class="headerlink" title="4. 전역 스코프(Global scope)"></a>4. 전역 스코프(Global scope)</h1><p>전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 전역 스코프를 갖는 전역 변수가 된다. var 키워드로 선언한 전역 변수는 전역 객체(Global Object) window의 프로퍼티이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">global</span> = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">global</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(local);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">global</span>);</span><br><span class="line"><span class="built_in">console</span>.log(local); <span class="comment">// Uncaught ReferenceError: local is not defined</span></span><br></pre></td></tr></table></figure>

<p>변수 global는 함수 영역밖의 전역에서 선언되었다. 자바스크립트는 타 언어와는 달리 특별한 시작점(Entry point)이 없어서 위 코드와 같이 전역에 변수나 함수를 선언하기 쉽다. </p>
<p>C언어의 경우 main 함수가 시작점이 되기 때문에 대부분은 코드는 main 함수 내에 포함된다. C언어의 경우 전역 변수를 선언하기 위해서는 의도적으로 main함수 밖에 변수를 선언하여야 한다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* global variable declaration */</span></span><br><span class="line"><span class="keyword">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// local variable declaration</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// actual initialization</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 자바스크립트는 다른 C-family language와는 달리 특별한 시작점이 없으며 코드가 나타나는 즉시 해석되고 실행된다. 따라서 전역에 변수를 선언하기 쉬우며 이것는 전역 변수를 남발하게 하는 문제를 야기시킨다.</p>
<p>전역 변수의 사용은 변수 이름이 중복될 수 있고, <strong>의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 사용을 억제하여야 한다.</strong></p>
<h1 id="5-비-블록-레벨-스코프-Non-block-level-scope"><a href="#5-비-블록-레벨-스코프-Non-block-level-scope" class="headerlink" title="5. 비 블록 레벨 스코프(Non block-level scope)"></a>5. 비 블록 레벨 스코프(Non block-level scope)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>

<p>변수 x는 코드 블록 내에서 선언되었다. 하지만 자바스크립트는 블록 레벨 스코프를 사용하지 않으므로 <strong>함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 스코프</strong>를 갖게된다. 따라서 변수 x는 전역 변수이다. </p>
<h1 id="6-함수-레벨-스코프-Function-level-scope"><a href="#6-함수-레벨-스코프-Function-level-scope" class="headerlink" title="6. 함수 레벨 스코프(Function-level scope)"></a>6. 함수 레벨 스코프(Function-level scope)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;     <span class="comment">// 전역변수</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;   <span class="comment">// 지역변수</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &quot;b&quot; is not defined</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트는 함수 레벨 스코프를 사용한다. 즉, 함수 내에서  선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다. 따라서 변수 b는 지역변수이다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();          <span class="comment">// local</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>

<p>전역변수 x와 지역변수 x가 중복 선언되었다. 전역 영역에서는 전역변수만이 참조 가능하고 함수 내 지역 영역에서는 전역과 지역 변수 모두 참조 가능하나 위 예제와 같이 변수명이 중복된 경우, 지역변수를 우선하여 참조한다.</p>
<p>다음은 함수 내에 존재하는 함수인 내부 함수의 경우를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 내부함수</span></span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다. 이는 매우 유용하다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보인다.</p>
<p>함수 bar에서 참조하는 변수 x는 함수 foo에서 선언된 지역변수이다. 이는 실행 컨텍스트의 스코프 체인에 의해 참조 순위에서 전역변수 x가 뒤로 밀렸기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>함수(지역) 영역에서 전역변수를 참조할 수 있으므로 전역변수의 값도 변경할 수 있다. 내부 함수의 경우, 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;   <span class="comment">// 내부함수</span></span><br><span class="line">    x = <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>중첩 스코프는 가장 인접한 지역을 우선하여 참조한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"> </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">7</span>, c = <span class="number">11</span>;</span><br><span class="line">    <span class="comment">// 이 시점에서 a는 3, b는 7, c는 11</span></span><br><span class="line">    a += b + c;</span><br><span class="line">    <span class="comment">// 이 시점에서 a는 21, b는 7, c는 11</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 시점에서 a는 3, b는 5, c는 not defined</span></span><br><span class="line">  bar( );</span><br><span class="line">  <span class="comment">// 이 시점에서 a는 21, b는 5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-렉시컬-스코프"><a href="#7-렉시컬-스코프" class="headerlink" title="7. 렉시컬 스코프"></a>7. 렉시컬 스코프</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ?</span></span><br><span class="line">bar(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있는데 첫번째는 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것이고 두번째는 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것이다. 첫번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고, 두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다.</p>
<p>프로그래밍 언어는 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다. 첫번째 방식을 동적 스코프(Dynamic scope)라 하고, 두번째 방식을 렉시컬 스코프(Lexical scope) 또는 정적 스코프(Static scope)라 한다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</p>
<p>**렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다. ** 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다. 위 예제의 함수 bar는 전역에 선언되었다. 따라서 함수 bar의 상위 스코프는 전역 스코프이고 위 예제는 전역 변수 x의 값 1을 두번 출력한다.</p>
<h1 id="8-암묵적-전역"><a href="#8-암묵적-전역" class="headerlink" title="8. 암묵적 전역"></a>8. 암묵적 전역</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 선언하지 않은 식별자</span></span><br><span class="line">  y = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 y는 선언하지 않은 식별자이다. 따라서 y = 20이 실행되면 참조 에러가 발생할 것처럼 보인다. 하지만 선언하지 않은 식별자 y는 마치 선언된 변수처럼 동작한다. 이는 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기 때문이다.</p>
<p>foo 함수가 호출되면 자바스크립트 엔진은 변수 y에 값을 할당하기 위해 먼저 스코프 체인을 통해 선언된 변수인지 확인한다. 이때 foo 함수의 스코프와 전역 스코프 어디에서도 변수 y의 선언을 찾을 수 없으므로 참조 에러가 발생해야 하지만 자바스크립트 엔진은 y = 20을 window.y = 20으로 해석하여 프로퍼티를 동적 생성한다. 결국 y는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다. 이러한 현상을 암묵적 전역(implicit global)이라 한다.</p>
<p>하지만 y는 변수 선언없이 단지 전역 객체의 프로퍼티로 추가되었을 뿐이다. 따라서 y는 변수가 아니다. 따라서 변수가 아닌 y는 변수 호이스팅이 발생하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 변수 x는 호이스팅이 발생한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 전역 변수가 아니라 단지 전역 프로퍼티인 y는 호이스팅이 발생하지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// ReferenceError: y is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 선언하지 않은 변수</span></span><br><span class="line">  y = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>또한 변수가 아니라 단지 프로퍼티인 y는 delete 연산자로 삭제할 수 있다. 전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 선언하지 않은 변수</span></span><br><span class="line">  y = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.y); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 전역 변수는 삭제되지 않는다.</span></span><br><span class="line"><span class="keyword">delete</span> y; <span class="comment">// 프로퍼티는 삭제된다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.y); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="9-최소한의-전역변수-사용"><a href="#9-최소한의-전역변수-사용" class="headerlink" title="9. 최소한의 전역변수 사용"></a>9. 최소한의 전역변수 사용</h1><p>전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역변수 객체 하나를 만들어 사용하는 것이다. (더글라스 크락포드의 제안)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.student = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.student.name);</span><br></pre></td></tr></table></figure>

<h1 id="10-즉시실행함수를-이용한-전역변수-사용-억제"><a href="#10-즉시실행함수를-이용한-전역변수-사용-억제" class="headerlink" title="10. 즉시실행함수를 이용한 전역변수 사용 억제"></a>10. 즉시실행함수를 이용한 전역변수 사용 억제</h1><p>전역변수 사용을 억제하기 위해, 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다. 이 방법을 사용하면 전역변수를 만들지 않으므로 라이브러리 등에 자주 사용된다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  MYAPP.student = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.student.name);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.student.name);</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://poiemaweb.com/js-scope">poiemaweb.com/js-scope</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/javascript/page/0/">이전</a></div><div class="pagination-next"><a href="/categories/javascript/page/2/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/javascript/">1</a></li><li><a class="pagination-link" href="/categories/javascript/page/2/">2</a></li><li><a class="pagination-link" href="/categories/javascript/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/main.jpg" alt="WT.Jang"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">WT.Jang</p><p class="is-size-6 is-block">Programmer/Dancer/Gamer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Asia/Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">94</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">19</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wontaejang" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wontaejang"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/ASP-NET/"><span class="level-start"><span class="level-item">ASP.NET</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/html/"><span class="level-start"><span class="level-item">html</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-booleans/"><span class="level-start"><span class="level-item">python-booleans</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-comments/"><span class="level-start"><span class="level-item">python-comments</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-datatypes/"><span class="level-start"><span class="level-item">python-datatypes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-exercises/"><span class="level-start"><span class="level-item">python-exercises</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/python-for/"><span class="level-start"><span class="level-item">python-for</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-function/"><span class="level-start"><span class="level-item">python-function</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-if/"><span class="level-start"><span class="level-item">python-if</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-inheritance/"><span class="level-start"><span class="level-item">python-inheritance</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/python-iterators/"><span class="level-start"><span class="level-item">python-iterators</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-list/"><span class="level-start"><span class="level-item">python-list</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/python-modules/"><span class="level-start"><span class="level-item">python-modules</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-numbers/"><span class="level-start"><span class="level-item">python-numbers</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-object/"><span class="level-start"><span class="level-item">python-object</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-operators/"><span class="level-start"><span class="level-item">python-operators</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-scope/"><span class="level-start"><span class="level-item">python-scope</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python-string/"><span class="level-start"><span class="level-item">python-string</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/python-syntax/"><span class="level-start"><span class="level-item">python-syntax</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/python-test/"><span class="level-start"><span class="level-item">python-test</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/python-variables/"><span class="level-start"><span class="level-item">python-variables</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/python-while/"><span class="level-start"><span class="level-item">python-while</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-01T07:46:14.536Z">2021-11-01</time></p><p class="title"><a href="/2021/11/01/js-day22-Math/">js-day22-Math</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-27T07:52:20.516Z">2021-10-27</time></p><p class="title"><a href="/2021/10/27/js-day21-Number/">js-day21-Number</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-26T07:54:57.289Z">2021-10-26</time></p><p class="title"><a href="/2021/10/26/js-day20-global-object/">js-day20-global-object</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-13T08:35:00.962Z">2021-10-13</time></p><p class="title"><a href="/2021/10/13/js-day19-built-in-object/">js-day19-built-in-object</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-08T07:19:08.843Z">2021-10-08</time></p><p class="title"><a href="/2021/10/08/js-day18-Object-Oriented-Programming/">js-day18-Object-Oriented-Programming</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">11월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">10월 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">51</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">4월 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Structure/"><span class="tag">Structure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/asp-net/"><span class="tag">asp.net</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/audio/"><span class="tag">audio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c#</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/execution-context/"><span class="tag">execution_context</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/form/"><span class="tag">form</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html/"><span class="tag">html</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5/"><span class="tag">html5</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/img/"><span class="tag">img</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/request/"><span class="tag">request</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/response/"><span class="tag">response</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syntax/"><span class="tag">syntax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tag/"><span class="tag">tag</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typechecking/"><span class="tag">typechecking</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/video/"><span class="tag">video</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">업데이트 소식 받기</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="구독"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="git blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 WT.Jang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>